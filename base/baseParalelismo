PA UNIVERSIDADE DE SAO PAULO
   INSTITUTO DE FISICA DE SAO CARLOS
   PARALELISMO EM VISAO NATURAL E
   ARTIFICIAL
   Odemir Martinez Bruno
   Tese apresentada ao Instituto de Fisica de Sao
   Carlos, da Universidade de Sao Paulo, para a
   obtencao do titulo de Doutor em Ciencias: Fisica
   Aplicada (Fisica Computacional).
   Orientador: Prof. Dr. Luciano da Fontoura Costa
   DEPARTAMENTO DE FISICA E INFORMATICA
   Sao Carlos
   2000
   Bruno, Odemir Martinez
   Paralelismo em Visao Natural e Artificial / Odemir
   Martinez Bruno. Sao Carlos, 200.
   391 p.
   Tese (Doutorado) - Instituto de Fisica de Sao Carlos,
   2000.
   Orientador: Prof. Dr. Luciano da Fontoura Costa
   1. Visao Cibernetica. 2. Computacao Paralela.
   I. Titulo
   A minha esposa Adriana e aos meus
   pais Orlando e Maria Candida.
   AGRADECIMENTOS
   A minha esposa Adriana e aos meus pais Orlando e Maria Candida, pelo
   incentivo, colaboracao, carinho e apoio.
   Ao Prof. Luciano, pela orientacao cientifica, amizade e pelas valiosas
   oportunidades de aprendizado.
   Aos meus amigos, colegas e colaboradores Alan Salvany Felinto e Jander
   Moreira, pela cooperacao nos trabalhos referentes ao sistema Cyvis-1 e pelo
   auxilio na validacao e testes do CVMP, alem da convivencia pessoal.
   A Luis Augusto Consularo, pelo trabalho em conjunto, pelo auxilio nos
   testes do CVMP e pela amizade.
   A Roberto Cesar Marcondes Junior, pelo trabalho em conjunto no projeto
   ynergos e convivencia pessoal.
   A Cristina Algodoal Martins, pelas valiosas sugestoes em botanica e pela
   amizade.
   Ao Prof. Hilton Thadeu Zarate do Couto da ESALQ-USP, pelas indicacoes e
   informacoes referentes aos herbarios.
   A Estacao Ecologica de Moji-Guacu do Instituto Florestal do Estado de S.
   Paulo, pelo fornecimento de amostras de plantas arboreas utilizadas neste
   trabalho. Em especial a Eduardo Amaral Batista, pesquisador chefe da unidade e
   Jose Carlos de Lima, auxiliar de apoio a pesquisa.
   A Wladerez A. G. Caiado, por sua competencia e constante bom humor,
   nos auxiliando ao longo desses anos nas questoes burocraticas.
   Ao pessoal da biblioteca do Instituto de Fisica de Sao Carlos, pela
   competencia e presteza.
   A todos os colegas do Grupo de Pesquisa em Visao Cibernetica pela
   amizade, fraternidade, cooperacao e pelas produtivas discussoes.
PA Aos tecnicos do Grupo, Marcos Roberto Goncalves e Alexandre Rodrigues
   da Silva, pelo auxilio e suporte.
   A todos os professores e pesquisadores com quem pude aprender e
   debater nesses anos.
   A todos que, direta ou indiretamente, prestaram seu apoio e/ou sua
   colaboracao na realizacao deste trabalho.
   Ao CNPq pelo suporte financeiro.
   E finalmente quero deixar meus profundos agradecimentos ao Instituto de
   Fisica de Sao Carlos da Universidade de Sao Paulo, pela infra-estrutura e
   excelente ambiente para a pesquisa cientifica, onde tive a honra de estudar,
   pesquisar, trabalhar e conhecer grandes amigos.
   RESUMO
   Nesta tese sao abordados, de maneira integrada, aspectos de paralelismo
   em visao natural e artificial, com discussoes criticas das diversas areas
   relacionadas. O paralelismo e discutido no sistema visual dos primatas, assim como
   suas principais contribuicoes e motivacoes incentivando a incorporacao de
   paralelismo em sistemas de visao artificial. Um dos objetivos principais e fornecer
   as bases de paralelismo para o desenvolvimento do projeto Cyvis-1, uma proposta
   do Grupo de Pesquisa em Visao Cibernetica (IFSC-USP) para visao versatil, com
   forte motivacao biologica e baseada no cortex visual dos primatas. Para tanto, foi
   introduzida e implementada a proposta CVMP (Cybernetic Vision Message
   Passage), um conjunto de ferramentas para o desenvolvimento de aplicacoes
   paralelas em visao, tanto para sistemas distribuidos como para maquinas
   multiprocessadores. Baseada em programacao orientada a objetos, interacao
   homem-maquina, engenharia de software e programacao visual, a proposta prima
   pelo desenvolvimento de forma simples e amigavel. O CVMP e testado, avaliado e
   validado quanto a aspectos de funcionalidade e utilizacao, atraves da
   implementacao paralela de diversos algoritmos de visao computacional e de
   processamento de imagens (operadores locais, transformada de Hough e
   transformada de Fourier, entre outros) os quais, alem de ilustrar a utilizacao da
   ferramenta, sao discutidos em termos de arquitetura e balanceamento de carga.
   Sao apresentadas tres aplicacoes reais de sistemas paralelos de visao
   computacional, implementadas atraves do CVMP, demonstrando a eficiencia da
   ferramenta, na implementacao paralela, na utilizacao e cooperacao de trabalho.
   Duas destas aplicacoes (integracao de atributos visuais no projeto Cyvis-1 e um
   modelo de complexidade com base na percepcao humana), foram desenvolvidas
   em conjunto com outros pesquisadores do Grupo de Pesquisa em Visao
   Cibernetica. A terceira aplicacao apresenta uma proposta do autor para um sistema
   automatico de reconhecimento de plantas arboreas (Botanica).
   i
   ii
   ABSTRACT
   This thesis addresses, in an integrated way, the concept and usage of
   parallelism in natural and artificial vision. It starts by revising the primate visual
   system, and discussing how its principles and solutions can be extended to
   computational systems. One of the main objectives is to supply the parallelism
   backbone for the development of the Cyvis-1 System, which is a proposal of the
   Cybernetic Vision Research Group (IFSC-USP) for versatile vision, presenting a
   strong biological motivation, especially regarding the primate visual cortex. In order
   to achieve these objectives, the CVMP - Cybernetic Vision Message Passage - had
PA to be developed, representing a set of simple and friendly paral el tools for computer
   vision applications in distributed and paral el (multiprocessor) systems, which is
   based on object oriented programming, human-machine interaction, software
   engineering and visual programming. The CVMP is tested, evaluated and validated
   with respect to functionality and utilization through the parallel implementation of
   several algorithms in computer vision and image processing (local operators, Hough
   transform, Fourier transform, etc.) which, in addition to il ustrating the tools, are also
   discussed as far as their architecture and load balancing is concerned. Three
   applications of parallel computer vision systems to real situations are presented and
   implemented by using CVMP, corroborating the effectiveness of the tools in the
   paral el implementation, usage, and researcher integration. Two such applications
   (visual attributes integration in Cyvis-1 and a human complexity model) have been
   developed in collaboration with other researchers at the Cybernetic Vision Research
   Group. The third application presents the author's proposal for an automated
   system for arboreal plants recognition (Botany).
   iii
 
  CAPITULO 1 - INTRODUCAO
   1.1 - O PARALELISMO NATURAL
   Desconhecemos a exata razao da natureza ao evoluir os diversos seres
   vivos, mas sabemos entretanto, que como resultado, eles se tornam mais
   adaptados ao meio e consequentemente mais complexos. Devemos lembrar que a
   adaptacao nao compreende apenas a modelagem do individuo ao meio fisico, mas
   tambem seu relacionamento com outros seres e muitas vezes a competicao entre
   as especies e individuos. Embora varios fatores sejam relevantes na adaptacao de
   um ser ao meio, tais como: locomocao, mecanismos de alimentacao e dispositivos
   de ataque (predadores) e defesa (presa), sem duvida o mais importante e a
   informacao, uma vez que e atraves dela que o individuo vai poder se locomover,
   alimentar, defender ou atacar, enfim realizar sua integracao ao meio.
   No decorrer de bilhoes de anos, inumeros mecanismos foram desenvolvidos
   pela natureza a fim de que os seres vivos pudessem extrair informacoes do meio.
   Esses mecanismos sao denominados sentidos, estando presentes no ser humano
   em cinco diferentes modalidades: audicao, visao, olfato, paladar e tato. O que
   determina a eficacia de um sentido e a quantidade e a qualidade das informacoes
   atraves dele percebidas. Foi atraves da percepcao das ondas eletromagneticas que
   a natureza desenvolveu uma das suas obras mais incriveis, o mecanismo mais
   poderoso e sofisticado para a aquisicao de informacao: a visao.
   Mais do que apenas uma maneira de obter informacoes sobre o meio, a
   visao e um complexo sistema de processamento de sinais, no qual as imagens sao
   convertidas em informacoes compreensiveis para o individuo. E razoavel que um
   sistema de processamento tao intrincado e sofisticado tenha um elevado custo. De
   fato, nos animais que possuem a visao mais evoluida, como e o caso dos primatas,
   cerca de 60% dos neuronios corticais estao envolvidos com este processo.
   Entretanto, num mundo onde a competicao e sinonimo de sobrevivencia, nao basta
   obter informacao abundante e de qualidade sobre o meio, e necessario tambem
   que ela seja adquirida em tempo real, uma vez que essa condicao na maioria das
   vezes pode significar a diferenca entre a vida ou morte para grande parte dos seres
PA vivos.
   3
   CAPITULO 1
   Sem duvida, o principal mecanismo encontrado na natureza para agilizar o
   processamento das informacoes e o paralelismo. A maior prova disso e a natureza
   paralela e distribuida do sistema de visao dos primatas, os animais mais evoluidos.
   Contudo, nao e apenas para a velocidade de resposta que o paralelismo contribui.
   Na verdade, o sistema de visao dos primatas tem no paralelismo sua base de
   estruturacao em todos os seus niveis. Como propoem Zeki e Shipp [Zeki & Shipp,
   1988], o paralelismo permite nao somente a integracao dos atributos visuais, mas
   tambem de cada um dos submodulos que os compoe.
   O paralelismo foi uma escolha realizada pela natureza ao longo da
   evolucao, o qual iniciou com o aparecimento dos seres pluricelulares. Se
   pensarmos em cada celula como um elemento individual de processamento da
   vida, todo ser vivo pluricelular e composto por uma estrutura de processamento
   paralelo. Nesse contexto, o paralelismo vai se intensificando a medida que os seres
   se tornam mais complexos e comecam a surgir os tecidos e orgaos, culminando no
   sistema nervoso central, a maquina de processamento paralelo mais poderosa que
   conhecemos. Em visao, assim como no sistema nervoso, a base estrutural do
   processamento esta fundada no paralelismo.
   Podemos considerar que o paralelismo na visao se inicia nos dois orgaos
   responsaveis pela captacao da luz, os olhos, que possuem autonomia e
   independencia, operando em concorrencia. O paralelismo dos olhos se acentua
   quando consideramos suas retinas. Alem de possuirem hemisferios de percepcao
   autonomos (campo visual direito e esquerdo), as retinas possuem dois conjuntos de
   fotorreceptores (cones e bastonetes) que constituem o inicio de sistemas
   independentes que captam informacoes distintas (caminho parvo celular e magno
   celular). A informacao proveniente da retina e replicada e distribuida para diversas
   regioes do cortex visual, caracterizando um sistema massivamente paralelo com
   arquitetura distribuida constituido por modulos independentes responsaveis pelo
   processamento de informacoes especificas. Cada um dos modulos que constituem
   o sistema visual e ainda subdividido em estruturas hierarquicas que realizam
   processamento paralelo. Deste modo, o paralelismo apresenta-se no sistema visual
   em multiniveis, mostrando-se como uma das bases de sua arquitetura.
   E dentro do fascinante universo da visao que reside o objeto de estudo
   desta tese multidisciplinar: o estudo do paralelismo no sistema de visao dos
   primatas e sua inspiracao para que possamos desenvolver sistemas paralelos de
   visao artificial mais eficientes.
   4
   INTRODUCAO
   1.2 - PARALELISMO EM VISAO ARTIFICIAL
   Embora seja de conhecimento da neurociencia que os sistemas biologicos
   de visao estejam fundamentados em estruturas distribuidas e paralelas de
   processamento, nao encontramos, como era de se esperar, na visao artificial (visao
   computacional) a mesma concepcao. De fato, observando a literatura da area, esse
   assunto, embora de extrema importancia, tem sido pouco explorado. Se tomarmos
   algumas das bases bibliograficas mais importantes, poderemos constatar que o
   paralelismo nao e nem ao menos citado, na sua grande maioria. Como exemplo
   podemos sugerir o famoso livro "Vision" de David Marr, o qual e consagrado por ser
   uma das biblias da area. Marr nao faz nem ao menos uma citacao em sua obra
PA sobre a importancia do paralelismo em visao.
   Ainda que a visao artificial seja uma area cuja inspiracao biologica e
   amplamente incentivada, nao sabemos qual e o motivo da lacuna que incide sobre
   o tema do paralelismo. Podemos supor alguns fatores responsaveis pela exclusao
   do paralelismo nas bases da visao artificial. Uma das possibilidades seria o
   processamento sequencial historicamente utilizado pela ciencia da computacao
   para resolver seus problemas, que pode ter contribuido para que o paralelismo
   tenha sido abandonado em visao artificial.
   Uma diferenca entre os elementos de processamento natural e biologico e a
   velocidade de processamento. Sendo os neuronios lentos, se comparados com a
   frequencia de operacao dos microprocessadores atuais, existe uma necessidade
   intrinseca de paralelismo para realizar processamento em tempo real. Talvez este
   fator tenha levado a uma crenca onde, ao contrario da visao natural, o estudo de
   visao artificial nao tivesse a necessidade de se preocupar com os assuntos de
   paralelismo, uma vez que num futuro proximo, os sistemas computacionais
   poderiam chegar a possuir poder computacional suficiente para efetuar os metodos
   e tecnicas de visao computacional e processamento de imagens em tempo real.
   Entretanto, devemos lembrar que na visao natural o paralelismo nao possui apenas
   esse carater.
   Outra possibilidade seria a dificuldade no desenvolvimento de aplicacoes
   paralelas, devido a impopularidade da computacao paralela levando a uma falta de
   ambientes de desenvolvimento amigaveis, a necessidade de um profundo
   conhecimento em computacao paralela exigida para sua programacao e sistemas
   de computacao complexos e pouco amigaveis entre outras. Esses fatores tem
   5
   CAPITULO 1
   mantido a computacao paralela restrita aos especialistas da area. Sendo visao um
   assunto multidisciplinar envolvendo alem de cientistas da computacao,
   engenheiros, matematicos, fisicos, biologos, neurocientistas e outros, o alto custo
   com o aprendizado e utilizacao das tecnicas de computacao paralela estariam
   assim conduzindo a opcao sequencial.
   Seja qual for a possibilidade, podemos concluir que a principal barreira que
   impoe uma abordagem paralela em visao artificial e a dificuldade de implementacao
   paralela e o direcionamento de suas ferramentas para o restrito grupo dos
   especialista da area. Observando a historia da computacao, vemos a grande
   importancia da interacao usuario/maquina e de sua simplificacao. Deste modo,
   tornar as tecnologias mais faceis de utilizar, alem de auxiliar os usuarios
   inexperientes, tambem beneficia os expertos, uma vez que [Hayes, 1990] [Baber et
   al., 1993]. Bons exemplos desta linha de raciocinio sao: a tecnologia GUI ( Grafical
   User Interface), a programacao visual e a programacao orientada a objetos, cujo
   principal objetivo e simplificar o relacionamento entre o homem e a maquina.
   Deste forma, acreditamos que a principal solucao para a ausencia de
   paralelismo em visao artificial seria eliminar a barreira da dificuldade de utilizacao
   da tecnologia de computacao paralela, atraves de metodologias e ferramentas que
   possibilitassem uma simplificacao da implementacao de aplicativos, permitindo
   assim que toda a gama de pesquisadores relacionados com visao pudessem
   facilmente incorporar paralelismo em seus projetos.
   Assim sendo, o problema do paralelismo em visao artificial se transforma
   numa questao inserida no seio da ciencia da computacao: a adocao do paralelismo
   com uma filosofia de interacao homem-maquina, objetivando o acesso facil e
PA amigavel aos recursos da computacao paralela.
   1.3 - AS DUAS COLUNAS
   O paralelismo e inerente a visao natural, possibilitando alem de grande
   performance (processamento em tempo real), as bases para a integracao entre os
   diferentes atributos visuais e seus respectivos modulos [Zeki & Shipp, 1988]
   [Livingstone & Hubel, 1988] [Zeki, 1993] [Hubel, 1995] [Levine & Shefner, 1991].
   Seguindo as licoes da natureza, o estudo do paralelismo em visao artificial, e vital
   para o desenvolvimento de modelos mais realisticos de visao auxiliando na
   elaboracao de sistemas mais complexos, que permitam a integracao de atributos
   6
   INTRODUCAO
   visuais (cor, estereo, textura, forma, etc.) e diferentes tecnicas de visao, assim
   como sua execucao em tempo real, uma vez que a performance esta condicionada
   a filosofia paralela.
   Alem de melhorias nos sistemas de visao artificial, a adocao de modelos
   mais realisticos do ponto de vista biologico permite uma melhor compreensao dos
   sistemas de visao natural, e consequentemente do funcionamento do cerebro como
   um todo. Essa realimentacao de conhecimento constitui uma das bases da Visao
   Cibernetica, que caracteriza o estudo da visao como um assunto multidisciplinar
   correlacionado.
   Esta tese esta fundada em duas colunas: (i) o estudo do paralelismo em
   visao natural e artificial e (i ) a proposta de uma ferramenta de desenvolvimento
   paralelo, baseada na interacao entre usuario e maquina, que facilite a
   implementacao de algoritmos paralelos de visao.
   Na primeira parte que compoe este trabalho realizamos uma revisao,
   discussao e analise do paralelismo em visao natural e artificial. Sao abordadas as
   bases do paralelismo na visao natural, enfocando o sistema de visao dos primatas.
   Em visao artificial sao tratados os possiveis beneficios do paralelismo, atraves de
   sistemas paralelos de visao, concentrando o assunto sobre o projeto Cyvis-1
   ( Cybernetic Vision 1), sistema de visao versatil em desenvolvimento no nosso
   grupo. O Cyvis-1 e baseado no modelo de especializacao funcional proposto por
   Zeki & Shipp [Zeki & Shipp, 1988], apresentando deste modo, assim como os
   sistemas de visao natural, uma arquitetura que possui paralelismo inerente.
   Conforme discutimos na secao anterior, acreditamos que a principal razao
   que impele a utilizacao de paralelismo em massa em visao computacional e a
   dificuldade de utilizacao, de implementacao e o longo treinamento requerido para a
   implementacao paralela. Na tentativa de solucionar esse problema, sobretudo
   dentro do nosso grupo de pesquisa, a segunda parte desta tese introduz uma nova
   metodologia de implementacao paralela, baseada na simplicidade de utilizacao e
   programacao e na reutilizacao de codigo.
   1.4 - OBJETIVOS DA TESE
   Nesta secao vamos apresentar ao leitor uma sintese dos principais objetivos
   deste trabalho, permitindo uma perspectiva sobre os assuntos discutidos e
   abordados ao longo da tese.
   7
   CAPITULO 1
   Como primeiro passo, este trabalho pretende realizar um levantamento
   critico e abrangente das diversas areas relacionadas ao paralelismo em visao
   natural e artificial. Uma vez que o paralelismo em visao artificial esta vinculado a
   computacao paralela, intencionamos realizar uma substancial revisao a
PA computacao paralela, de modo a fornecer ao leitor as bases para as discussoes do
   assunto sob o ponto de vista da visao. Em visao natural, o objetivo e realizar uma
   revisao sobre o assunto, culminando em uma discussao do paralelismo no sistema
   visual dos primatas. A integracao entre as duas modalidades de visao ocorre
   atraves de uma analise critica de sistemas de visao artificial com motivacao
   biologica.
   Um dos objetivos principais deste trabalho e fornecer as bases de
   paralelismo e integracao entre pesquisadores para o desenvolvimento do projeto
   Cyvis-1, uma proposta de visao versatil, que vem sendo desenvolvida pelo nosso
   grupo. Com forte motivacao biologica, o Cyvis-1, e baseado na especializacao
   funcional do cortex visual dos primatas proposta por Zeki & Shipp [Zeki & Shipp,
   1988], possuindo como principais caracteristicas a integracao dos atributos visuais,
   o paralelismo em visao e o trabalho cooperativo entre os diversos pesquisadores
   envolvidos no projeto.
   De forma a viabilizar o item anterior e na tentativa de preencher a lacuna do
   paralelismo em visao artificial, pretendemos desenvolver um conjunto de
   ferramentas para o desenvolvimento, de forma simples e amigavel, de aplicacoes
   paralelas em visao que, auxilie tanto os programadores sem conhecimentos em
   paralelismo como os expertos. Deste modo, permitira a qualquer pesquisador de
   visao com o minimo conhecimento de programacao, a utilizacao de recursos de
   paralelismo em seus projetos, e aos especialistas, o desenvolvimento mais agil.
   Denominado CVMP ( Cybernetic Vision Message Passage), o conjunto de
   ferramentas em questao e voltado para a plataforma Windows NT/9X e para o
   ambiente de desenvolvimento Delphi, que constituem uma das bases de
   desenvolvimento computacional do nosso grupo.
   Uma vez implementado, e necessario realizar a avaliacao e validacao do
   CVMP, tanto nos aspectos de funcionalidade quanto em utilizacao. Assim, um dos
   objetivos do trabalho foi a implementacao de versoes paralelas de diversos
   algoritmos de visao computacional e de processamento de imagens. Dentre os
   algoritmos, serao abordados casos classicos em visao e processamento de
   imagens, tais como os operados locais, transformada de Hough [Hough, 1959] e
   8
   INTRODUCAO
   transformada de Fourier [Brigham, 1988], amplamente discutidos na literatura,
   algumas vezes ate mesmo sob o ponto de vista do paralelismo, alem de uma
   tecnica de segmentacao inedita baseada em campos aleatorios de Markov [Bruno &
   Costa, 2000]. Os algoritmos foram analisados atraves dos modulos de estatistica do
   CVMP, o qual permitiu um estudo sobre seu comportamento, eficiencia e
   performance.
   Outro objetivo e o desenvolvimento de situacoes reais em visao artificial que
   utilizem os recursos da computacao paralela, atraves do CVMP. Para tanto serao
   apresentadas 3 aplicacoes ineditas desenvolvidas nesse trabalho: (i) estruturas de
   paralelismo da integracao dos atributos cor e estereo do projeto Cyvis-1, (ii) um
   experimento para um modelo de complexidade baseado na percepcao humana
   (projeto ynergos) e (i i) uma proposta para um herbario digital e automatico
   (proposta TreeVis). As duas primeiras aplicacoes fazem parte de projetos em
   desenvolvimento no nosso grupo (Grupo de Pesquisa em Visao Cibernetica), nos
   quais alem do autor participam outros integrantes do grupo, possibilitando a
   validacao do CVMP tanto na simplicidade de utilizacao (manuseio amigavel), como
   na reutilizacao de codigo e integracao entre pesquisadores. A outra aplicacao
PA apresenta um prototipo de uma proposta do autor para um sistema de
   reconhecimento automatico de plantas arboreas, com o intuito de fornecer aos
   botanicos uma ferramenta complementar aos tradicionais herbarios.
   1.5 - ORGANIZACAO DA TESE
   Esta tese prossegue com uma revisao dos conceitos basicos de
   computacao paralela, permitindo ao leitor familiarizar-se com o assunto. No
   Capitulo 2 sao apresentados alguns aspectos teoricos de arquiteturas paralelas e,
   no Capitulo 3, o tema continua com uma abordagem em software.
   No Capitulo 4 e realizada uma revisao de visao natural, com enfoque no
   sistema de visao dos primatas. O capitulo e complementado por uma discussao do
   assunto sob o prisma do paralelismo. No Capitulo 5 sao apresentados os sistemas
   de visao artificial Cyvis-1 e ynergos, em desenvolvimento no Grupo de Visao
   Cibernetica deste instituto. Dentre eles devemos destacar o Cyvis-1, sistema
   fortemente motivado pela inspiracao biologica, que possui como coluna dorsal o
   paralelismo, sendo uma das bases de estudo deste trabalho. Ainda nesse capitulo
   sera realizada uma analise comparativa entre o sistema Cyvis-1 e outros sistemas
   9
   CAPITULO 1
   artificiais encontrados na literatura.
   Esta tese introduz um conjunto de ferramentas visuais, que simplificam a
   implementacao de aplicacoes paralelas, denominado CVMP. Embora o CVMP
   tenha sido idealizado para a visao computacional, sua utilizacao e generica,
   permitindo virtualmente que qualquer programador Delphi desenvolva uma
   aplicacao paralela, bastando para isto um conhecimento rudimentar de paralelismo.
   O conjunto de ferramentas CVMP e apresentado e discutido no Capitulo 6.
   O Capitulo 7 apresenta diversas tecnicas e metodos paralelos de visao
   computacional e processamento de imagens, desenvolvidos atraves de CVMP.
   Cada caso e discutido, abordando as questoes teoricas do assunto, assim como os
   resultados da implementacao paralela e ainda sua comparacao com as versoes
   sequenciais. Dentre as tecnicas apresentadas salientamos a implementacao
   paralela do algoritmo de segmentacao de imagens, baseado em campos aleatorios
   de Markov, cuja metodologia foi desenvolvida neste trabalho.
   No Capitulo 8 sao apresentadas tres ineditas aplicacoes paralelas em visao
   artificial, implementadas atraves de CVMP. A primeira delas e um prototipo do
   sistema de visao Cyvis-1, na qual e realizada a integracao dos atributos de cor e
   estereo, a partir do paralelismo. Na seguinte, e discutido um experimento de
   psicofisica realizado a partir do projeto ynergos, visando a obtencao de um
   modelo de medida de complexidade, baseado na percepcao humana. Na ultima
   aplicacao temos um sistema paralelo de visao para auxiliar no levantamento e
   estudo das plantas arboreas de florestas tropicais, que funciona como um herbario
   digital, cuja proposta e implementacao foi introduzida nesta tese.
   Finalmente esta tese e concluida no Capitulo 9, onde sao discutidas as
   contribuicoes deste trabalho e as possiveis pesquisas cientificas que podem ser
   realizadas na sua continuacao.
   10
   CAPITULO
   2
   COMPUTACAO PARALELA -
   HARDWARE
   ... toda ciencia e melhor conhecida a partir de sua historia, do mesmo modo que as
PA maiores edificacoes apresentam as bases mais solidas ...
   11
   CAPITULO 2
   12
   COMPUTACAO PARALELA - HARDWARE
   CAPITULO 2 - COMPUTACAO PARALELA -
   HARDWARE
   2.1 - INTRODUCAO
   Partindo da premissa de que toda ciencia e melhor conhecida a partir de sua
   historia, do mesmo modo que as maiores edificacoes apresentam as bases mais
   solidas, iniciamos esse capitulo com uma breve revisao da historia da computacao
   paralela, a fim de que possamos, a partir da base, tracar as perspectivas para os
   avancos de uma das areas mais importantes da Ciencia da Computacao. Seguindo
   esse principio, discorreremos sobre a evolucao da computacao sequencial e a
   seguir apresentaremos a evolucao da computacao paralela abordando alguns
   elementos classicos, de modo a gerar as bases para sua melhor compreensao.
   Como podemos deduzir atraves do titulo desse capitulo, estaremos
   discutindo a computacao paralela sob o ponto de vista do hardware. Apos a
   abordagem historica da computacao paralela, apresentada na Secao 2.2, na
   seguinte, iremos tratar da evolucao da eletronica, e apresentar o perfil tecnologico
   da evolucao do hardware. Continuando, trataremos na Secao 2.4 da evolucao da
   computacao sequencial, demonstrando as tendencias de paralelismo nos
   computadores sequenciais. Na Secao 2.5 apresentaremos a evolucao da
   computacao paralela atraves de uma jornada evolutiva sobre as principais
   arquiteturas nao convencionais, e finalmente concluimos o capitulo apresentando
   alguns metodos para a taxionomia de computadores.
   2.2 - PRINCIPIOS HISTORICOS DA COMPUTACAO
   PARALELA
   A historia da computacao paralela e tao antiga quanto a historia do
   computador moderno. O proprio John von Neumann, criador da arquitetura von
   Neumann, arquitetura fundamental para a maioria dos computadores desenvolvidos
   13
   CAPITULO 2
   ate hoje, desenvolveu trabalhos na decada de 40 que discutiam a possibilidade de
   algoritmos paralelos para a solucao de equacoes diferenciais [Breton, 1991]. Com
   isso podemos concluir que a historia da computacao paralela vem transcorrendo
   em paralelo com a propria historia da computacao moderna, e como poderemos
   observar, aparenta ser uma evolucao natural a computacao.
   Sem desmerecer as contribuicoes de importantes nomes da historia da
   computacao, como Blaise Pascal [Goldstine, 1993], Gottfried Wilhelm von Leibniz
   [Breton, 1991], Charles Babbage [Spufford & Uglow, 1997] e Al an Turing [Hodges,
   1992], assim como toda a era pre-moderna da historia da computacao, podemos
   dizer que a computacao moderna, teve seu inicio com o projeto ENIAC (Electronic
   Numerical Integrator and Computer) [Goldstine, 1993] [Breton, 1991], iniciado na
   decada de 40. O projeto ENIAC iniciou-se na era das grandes calculadoras.
   Embora seus coordenadores Eckert e Mauchly estivessem dispostos a inovar, em
   seu projeto inicial, o ENIAC nao passava de uma calculadora, e a teoria utilizada
   ainda era muito semelhante a maquina de Babbage e mesmo a Pascalina. Em
   agosto de 1944, com a incorporacao de John von Neumann no projeto do ENIAC, o
   rumo da historia mudaria. Infelizmente o ENIAC ja estava em fase bem adiantada e
PA nao apresentaria muitas das propostas revolucionarias de von Neumann, mas ainda
   assim o ENIAC seria o primeiro computador eletronico de uso geral. Mesmo sendo
   um precursor dos computadores modernos, o ENIAC ja possuia carater paralelo,
   uma vez que era disposto em varios modulos independentes, descentralizados e
   que poderiam realizar operacoes simultaneamente.
   John von Neumann propos uma nova forma de organizar os sistemas de
   computacao, que deu origem a arquitetura von Neumann e marcou o inicio da
   computacao moderna. Um dos principais conceitos apresentados por von Neumann
   foi a memoria e a ideia de programa armazenado. A partir da influencia direta das
   ideias de von Neumann nasceram os primeiros cinco computadores modernos
   (sistema de memoria) da historia, que foram o EDVAC (o primeiro projeto de
   computador moderno), a maquina IAS, o BINAC, o EDSAC e o Manchester MARK I
   (o primeiro computador a funcionar na historia). Esses computadores foram de
   carater academico ou militar, porem seus sucessos fizeram com que logo
   comecassem a ser produzidos computadores comerciais.
   Um fato bastante curioso nessa historia, e que nos liga novamente a historia
   da computacao paralela, e que uma das caracteristicas que inviabilizavam o ENIAC
   era o seu aspecto paralelo, onde diversas partes de sua arquitetura funcionavam
   14
   COMPUTACAO PARALELA - HARDWARE
   independentes e em paralelo. Com o paralelismo era necessaria a supervisao
   humana, ja que a maquina nao possuia uma unidade central automata. [Breton,
   1991].
   Com os principios de memoria e programa armazenado, von Neumann
   implementava a maquina de Turing universal, e com isso, o computador assumia
   agora um papel generico, todo e qualquer (salvo limitacoes) problema computavel
   possuia um programa capaz de resolve-lo; porem essa nova organizacao possuia
   um controle centralizado e tarefas sequenciais. A partir da definicao de computador
   moderno, a historia dos computadores pode ser dividida em tres partes, que vao
   caminhando simultaneamente. Primeiramente temos a revolucao tecnologica, a
   medida que a eletronica se desenvolvia, computadores mais poderosos e velozes
   surgiam. Ao mesmo tempo que avancava a eletronica, que esta intimamente ligada
   a historia da computacao, ocorriam tambem progressos na propria computacao, em
   termos de arquitetura, "hardware" e "software". Na computacao ocorreram dois
   caminhos simultaneos: por um lado temos os computadores de uso geral ou
   comerciais, que adotaram a tradicional maquina de von Neumann como arquitetura
   basica, por outro lado temos os denominados supercomputadores.
   A necessidade de velocidade e inerente a computacao, e a solucao natural
   para essa questao e a paralelizacao. Portanto, os supercomputadores sao projetos
   que tentam alternativas a arquitetura sequencial de von Neumann, e buscam
   aumentar a performance da maquina atraves do paralelismo. Em geral essas
   maquinas sao de uso especifico, voltadas a problemas determinados, e de carater
   cientifico.
   2.3 - EVOLUCAO ELETRONICA
   Do ponto de vista da eletronica, a historia pode ser dividida em cinco partes
   ou geracoes. A medida que a tecnologia eletronica evoluia, novos computadores
   mais velozes e poderosos surgiam, baseados na nova tecnologia. Por um lado a
   velocidade de comutacao dos dispositivos aumentava a cada geracao e por outro
   as tecnologias de miniaturizacao e de integracao evoluiam e proporcionavam
   computadores menores em tamanho, porem com um numero cada vez maior de
PA dispositivos de processamento (transistores) e memoria. A Figura 2.1 apresenta um
   diagrama sobre as geracoes e seus respectivos periodos.
   A primeira geracao de computadores (1938-1953), iniciou-se com os primeiros
   15
   CAPITULO 2
   computadores pre-modernos (maquinas de calcular), que utilizavam dispositivos
   eletromecanicos (Reles) e estendeu-se ate que surgiram os primeiros
   computadores eletronicos, sendo essa fase o periodo aureo da primeira geracao: a
   utilizacao de valvulas para o desenvolvimento de computadores eletronicos. Neste
   periodo os computadores possuiam arquitetura bit-by-bit, onde nao existia o
   conceito de palavra (byte) e o processador utilizava um intervalo de relogio para
   processar cada bit.
   Quinta
   Quarta
   Terceira
   Geracoes
   Segunda
   Primeira
   1940
   1950
   1960
   1970
   1980
   1990
   Fig. - 2.1 - Geracoes de Computadores.
   Os transistores foram inventados em 1948, e com eles surge uma nova
   evolucao na eletronica. A confeccao de computadores utilizando transistores marca
   a segunda geracao de computadores (1952-1963). O primeiro computador a utilizar
   essa nova tecnologia foi o TRADIC, construido pela Bel Laboratories em 1954. O
   TRADIC utilizava 800 transistores. Nesse periodo surge o circuito impresso e a
   memoria magnetica.
   Ainda nessa epoca comecam a surgir as primeiras linguagens de alto-nivel,
   como o Fortran (do ingles, formula translation) em 1956, o Algol (do ingles,
   algorithmic language) em 1960 e o COBOL (do ingles COmmon Business Oriented
   Language) em 1959, e comecam tambem a aparecer processadores especificos
   para processamento de entrada e saida de dados.
   A terceira geracao de computadores (1962-1975) surge com o aparecimento
   dos circuitos integrados SSI (pequena escala) e MSI (media escala). Nessa epoca
   surge a memoria de estado solido. Nesse periodo as linguagens de alto-nivel sao
   16
   COMPUTACAO PARALELA - HARDWARE
   favorecidas com compiladores inteligentes. Comecam a ser empregadas as
   tecnologias de multiprogramacao e memoria virtual.
   Nessa geracao surge o microprocessador, atraves de um projeto de
   calculadora, Ted Hoff da Intel, projeta um circuito integrado para uso geral em
   calculadoras e entao nasce o microprocessador. O microprocessador e uma
   unidade central de processamento construida em um unico circuito integrado. Esse
   foi um importante passo na historia, surge entao o microcomputador e somente a
   partir daqui os computadores podem ser difundidos e construidos em larga escala.
   Inicia-se a popularizacao da informatica.
PA A partir de 1972, utilizando a nova tecnologia de circuitos integrados LSI,
   surge a quarta geracao de computadores (1972 a 1985). Nessa fase os
   computadores utilizam os novos circuitos integrados em secoes de processamento
   e memoria. Surgem os supercomputadores escalar e vetoriais, assim como as
   extensoes de linguagens tradicionais como o Fortran para utilizarem seus novos
   recursos de paralelismo. A maioria dos sistemas operacionais desta geracao
   utilizam compartilhamento de tempo ("time-sharing") e memoria virtual. No final
   desta geracao surge uma corrida por paralelismo, concentrando esforcos tanto das
   porcoes academicas quanto comerciais.
   A atual geracao de computadores (quinta geracao - 1985 ate hoje) iniciou-
   se com o aparecimento da tecnologia de integracao VLSI. Esta epoca marca a
   continuidade da corrida por paralelismo. Surgem sistemas de computacao
   massivamente paralelos com mais de 64000 unidades de processamento. Este
   periodo marca tambem a fase aurea do Transputer, um microprocessador
   desenvolvido especificamente para projetos em computacao paralela.
   Surgem tambem as estacoes de trabalho, e com elas a tecnologia RISC e a
   adocao de paralelismo nos computadores tradicionalmente sequenciais.
   Atualmente, a maioria dos microprocessadores convencionais tradicionais incorpora
   alguns mecanismos de paralelismo. Populariza-se o conceito de rede de
   computadores e com ele surge um novo sistema de paralelizacao - computacao
   distribuida, que e o enfoque deste trabalho.
   2.4 - EVOLUCAO DA COMPUTACAO SEQUENCIAL
   Entre os anos 50 ate meados dos anos 60, a computacao passa por uma
   fase confusa, onde os padroes ainda nao estao estabelecidos, e os fabricantes e
   17
   CAPITULO 2
   pesquisadores iniciam diversos projetos distintos, em geral o computador fica uma
   maquina de uso muito especifico, destinado a poucos problemas [Bruno, 1995]. A
   partir dos anos 60, os computadores comecam a proliferar e a generalizar o seu
   uso. A partir desse ponto, a historia da computacao pode ser dividida em duas
   partes: por um lado temos os computadores comerciais (na maioria) de uso geral e
   por outro lado temos os denominados supercomputadores, que eram destinados
   normalmente a problemas especificos e voltados mais a area cientifica ou militar,
   esses em usualmente tinham como requerimento basico a velocidade.
   Quanto aos computadores sequenciais (de uso geral), um consenso adotou
   a arquitetura de von Neumann como padrao, e isso nao se alterou. Ate meados da
   decada de sessenta, a arquitetura dos processadores nao foi muito alterada. Um
   dos primeiros passos rumo ao paralelismo foi o conceito de palavra (byte).
   Anteriormente o processador possuia uma arquitetura bit-by-bit, onde deveria
   processar um bit por vez (a cada passo do relogio). Com o conceito de palavra,
   uma unica instrucao possibilitava ao processador carregar uma palavra de oito bits
   a um unico passo (clock).
   Juntamente com os avancos de arquitetura, o software tambem evoluia. Um
   dos primeiros passos foi o aparecimento das linguagens de alto nivel, tornando a
   programacao mais simples, deste modo aumentando mais a quantidade de
   programas e do mesmo modo as aplicacoes e o uso.
   A partir da terceira geracao, observou-se que a unidade de processamento
   ficava ociosa com o acesso a dispositivos de entrada e saida de dados, e pouco a
   pouco foram sendo acrescentadas novas unidades de processamento nos
   dispositivos de entrada e saida de dados. O aumento de desempenho
PA proporcionado por essa abordagem aumentou a motivacao para essa estrategia e
   cada vez mais dispositivos do sistema (excluindo UCP - Unidade Central de
   Processamento) foram ganhando unidades de processamento independentes,
   automatas e capazes de trabalhar simultaneamente a UCP. Essa abordagem deu
   origem ao conceito de interrupcao e se difundiu, chegando aos sistemas de
   computacao atuais, que mesmo sendo sequenciais apresentam varias unidades de
   processamento (microcontroladores). Podemos citar como exemplos atuais desta
   abordagem os controladores de Video, interfaces de controle de disco e demais
   dispositivos de armazenamento de dados, portas seriais (mouse) e paralelas
   (impressora), controlador DMA (acesso direto a memoria), assim como uma serie
   de outros dispositivos incorporados nos atuais sistemas de computacao.
   18
   COMPUTACAO PARALELA - HARDWARE
   Ainda na segunda e terceira geracoes, muitas melhorias beneficiaram o
   desempenho dos computadores. Enquanto a eletronica inovou com circuitos mais
   rapidos e potentes, a computacao desenvolve sistemas e melhorias na arquitetura,
   a fim de deixar o computador mais poderoso e veloz. Surgem entao, entre outras
   melhorias, a memoria cache (disco e RAM), a multitarefa, a multiprogramacao e a
   memoria virtual.
   A partir da terceira e quarta geracoes de computadores utiliza-se o circuito
   integrado. Como resultado, a reducao do custo faz com que o microcomputador
   popularize-se e comece a proliferar. Ate o final da decada de 70 o microcomputador
   estaria consolidado como bem de consumo. Na decada de 80, o microcomputador
   atinge o apice. Com o lancamento do microcomputador da IBM PC, o
   microcomputador comeca sua escalada, e rapidamente ocorre o chamado
   "downsizing", fenomeno onde o microcomputador ocupa os lugares dos
   computadores de grande porte, e faz com que estes tornem-se obsoletos.
   No inicio da informatica, os computadores eram programados atraves da
   conexao de cabos. Um contato mais intimo entre o homem e a maquina tornaria
   sem duvida o computador mais facil de ser utilizado pelo homem. Muitas
   descobertas e invencoes contribuiram para a evolucao das interfaces. O primeiro
   passo seria os cartoes perfurados, logo a seguir teriamos as "teletypewrites"
   (dispositivos que se assemelhavam a maquinas de escrever). A primeira grande
   inovacao nesse contexto viria no final da decada de 60, com o uso do terminal de
   video, que adotava a interface CLI (do ingles command line interface); bons
   exemplos sao o UNIX, o VAX-VMS, o AppleDOS e o proprio MS-DOS [Hayes,
   1990].
   Durante toda a decada de 70, um importante consorcio coordenou os rumos
   da computacao para a proxima decada. Nao poderiamos narrar a historia da
   computacao atual sem considerar as importantes contribuicoes da XEROX e de seu
   centro de pesquisas PARC (Palo Alto Research Center). Desde o inicio da decada
   de 70 o PARC iniciou pesquisas para tornar o relacionamento entre o homem e a
   maquina mais intimo. Durante uma decada de pesquisas, o PARC chegou a um
   sistema muito proximo ao que denominamos atualmente de GUI (do ingles
   graphical user interface) [Peddie, 1992]. Atraves dessa pesquisa foi descoberto o
   mouse (dispositivo apontador), o paradoxo de orientacao a mensagens e a eventos
   e adotado o conceito de orientacao a objeto, que viria a marcar definitivamente os
   rumos da computacao no final da decada de 80 e na decada de 90 [Bruno, 1995].
   19
   CAPITULO 2
PA A partir da utilizacao das interfaces graficas (GUI) e suas novas tecnologias,
   surgem as estacoes de trabalho, e com elas se popularizam as redes de
   computadores. Embora as redes de computadores tenham tambem uma longa
   historia, foi apenas nos anos 80 atraves das estacoes de trabalho que ocorreu sua
   popularizacao na computacao.
   A nivel de hardware, as estacoes de trabalho trouxeram o paralelismo para
   os microprocessadores sequenciais. Isto ocorreu inicialmente com o conceito de
   arquitetura RISC (do Ingles Reduce Instruction Set Computer). A nova geracao de
   microprocessadores RISC incorporava a arquitetura pipeline [Gimarc & Milutinovic,
   1987]. A Figura 2.2 apresenta um exemplo de pipeline de instrucoes em
   microprocessadores RISC. [Gimarc & Milutinovic, 1987] [Ryan, 1992]
   Tempo
   Busca
   Decodificacao
   Execucao
   Escrita
   Instrucao 1
   Ciclo 0
   Instrucao 2
   Instrucao 1
   Ciclo 1
   Instrucao 3
   Instrucao 2
   Instrucao 1
   Ciclo 2
   Instrucao 4
   Instrucao 3
   Instrucao 2
   Instrucao 1
   Ciclo 3
   Instrucao 4
   Instrucao 3
   Instrucao 2
   Ciclo 4
   Instrucao 4
   Instrucao 3
   Ciclo 5
   Instrucao 4
   Ciclo 6
   Fluxo das instrucoes
   Fig. 2.2 - Tipica pipeline de instrucoes de arquitetura RISC.
   A velocidade e o poder de processamento alcancados por esse novo
   conceito proporcionaram uma corrida dos desenvolvedores de microprocessadores
   para o mundo do paralelismo (a nivel de instrucao). Atualmente vivemos uma forte
   tendencia onde as pesquisas de arquiteturas paralelas estao sendo aproveitadas
   para o desenvolvimento dos novos microprocessadores "sequenciais", que se
   tornam mais paralelos a cada geracao. Um bom exemplo dessa perspectiva e o
   microprocessador Intel Pentium, que como podemos observar pela Figura 2.3
   superou a expectativa tecnologica de desempenho gracas a utilizacao de conceitos
   de computacao paralela. Atualmente a grande maioria dos microprocessadores
PA comerciais incorporam pipeline e outros mecanismos de paralelismo em seus
   microprocessadores convencionais [Ryan, 1992].
   20
   COMPUTACAO PARALELA - HARDWARE
   Desnsidade / MIPS
   100M/1000
   P5 - Desempenho
   Beneficio do
   10M/100
   paralelismo
   Desempenho
   1M/10
   esperado
   P5 - Densidade
   100K/1
   10K/0,1
   1K/0,01
   1971 73 75 77 79 81 83 85 87 89 91 93
   Desempenho/ MIPS
   Densidade - Numero de transistores
   Milhoes de Instrucoes por segundo
   Fig. 2.3 - Beneficio proporcionado pelo paralelismo na arquitetura do
   Pentium.
   2.5 - EVOLUCAO DO PARALELISMO
   Ate a decada de 60, os computadores eram projetados para resolver
   problemas especificos, isto porem apresentava um obstaculo para a evolucao da
   computacao. A medida que a computacao evoluia e o universo de aplicacoes que
   poderiam utilizar computadores crescia, os computadores comecaram a ser uteis
   para uma gama cada vez maior de problemas. Tornava-se bem claro o rumo dos
   fabricantes de computadores: desenvolver computadores de uso generico, que
   possam ser utilizados nas mais diversas formas de aplicacoes [Bruno, 1995]. Para
   esse fim ficou consagrada a arquitetura de von Neumann e com ela os
   computadores sequenciais.
   A demanda por velocidade e inerente a computacao. Assim, nem todos os
   usuarios ficaram satisfeitos com a generalizacao. Muitos problemas, a grande
   maioria de carater cientifico ou cientifico-militar, exigiam um desempenho
   computacional maior que o fornecido pelas maquinas de uso generico. A resposta
   21
   CAPITULO 2
   para aumentar o desempenho dos computadores estava muito clara: paralelismo. O
   paralelismo porem acarretaria um custo muito maior em diversos aspectos, tais
   como: desenvolvimento de hardware especifico, multiplicacao de recursos
   (multiplicacao de custos consequentemente), desenvolvimento de software
   especifico, desenvolvimento personalizado (sem utilizar as vantagens da producao
   em massa). Mesmo sendo o paralelismo o resultado de projetos onerosos, existia
   um nicho disposto a pagar seu preco. Deste modo surge a computacao paralela ou
   supercomputacao [Hockney & Jesshope, 1988].
   Embora presente desde o ENIAC na historia da computacao moderna,
   somente a partir da decada de sessenta a computacao paralela assume o seu
   papel. Devido ao desempenho e aplicacoes das maquinas paralelas, a computacao
PA paralela passa a ser denominada de supercomputacao. A partir dessa demanda
   surgiram diversos projetos de arquiteturas paralelas, apresentando cada vez mais
   alternativas de paralelizacao.
   2.5.1 - ARQUITETURA ESCALAR
   Uma das primeiras arquiteturas paralelas que surgiram foi a arquitetura
   escalar, que deu origem aos denominados computadores escalares rapidos. A
   longa historia do desenvolvimento dos computadores escalares inicia-se na decada
   de 60 e seu desenvolvimento prolonga-se por toda a decada de 70. A evolucao dos
   computadores escalares e basicamente semelhante a propria historia da
   computacao paralela, onde o paralelismo vem surgindo e evoluindo pouco a pouco,
   baseado em maquinas convencionais.
   Os computadores escalares, tambem denominados de computadores
   pipeline [Hwang et al., 1984] sao maquinas que apresentam elementos de
   processamento duplicados. A grande diferenca em termos de instrucao entre os
   computadores escalares e os computadores vetoriais (que trataremos mais tarde) e
   o tratamento dos dados. As instrucoes dos computadores escalares trabalham com
   dados individuais, enquanto que os computadores vetoriais trabalham com grande
   quantidade de dados ordenados (vetores) por instrucao. Um dos primeiros
   computadores escalares que surgiram foi o IBM 7090.
   Um computador que influenciou a historia tanto em arquitetura quanto em
   software foi o ATLAS. Embora seu projeto tenha-se iniciado na Universidade de
   Manchester por volta de 1956, a primeira producao dessa maquina ocorreu apenas
   22
   COMPUTACAO PARALELA - HARDWARE
   em 1963, pela Ferranti. Em termos de software, o ATLAS foi o pioneiro na utilizacao
   de sistema operacional multiprogramado. Com aproximadamente 80000
   transistores, o ATLAS dispunha de varios dispositivos de I/O com processamento
   independente, que solicitava o processador apenas quando necessario. Alem do
   pioneirismo em termos de organizacao, o ATLAS incorporava paralelismo para
   aumentar seu desempenho computacional.
   O ATLAS utilizava quatro bancos independentes de memoria, que permitiam
   acesso simultaneo (em um unico clock). Utilizando esses blocos, o ATLAS possuia
   uma arquitetura funcional com duas unidades aritmeticas, de modo que em
   combinacao com seu arranjo de memoria, ele poderia (em casos muito favoraveis)
   executar duas instrucoes aritmeticas em um unico clock. Alem da arquitetura
   funcional, o ATLAS tambem possuia um arranjo pipeline entre as seguintes fases
   da execucao de instrucoes: busca de instrucao, calculo de enderecamento, busca
   de operando e execucao aritmetica.
   Para fazer melhor uso de suas caracteristicas paralelas (multiplas unidades
   aritmeticas, registradores e memoria) e de seus recursos computacionais, seria
   necessario um sistema que previsse as futuras instrucoes e determinasse quais
   instrucoes poderiam ser executadas concorrentemente sem alterar a logica do
   programa. Embora o ATLAS nao possuisse nenhum mecanismo de previsao, dois
   aspectos foram considerados posteriormente por Kel er (1976) e Kuck (1978) e
   incluidos nos computadores escalares CDC6600 e IBM 360/91.
   A introducao gradual do paralelismo funcional e pipeline nos computadores
   seriais pode ser bem observada atraves dos computadores da Control Data
   (empresa sob influencia direta de Seymour Cray). O seu computador CDC 6600,
   lancado em 1964, foi o primeiro computador escalar a utilizar o paralelismo
   funcional como sua caracteristica mais importante de projeto. O modelo seguinte da
PA Control Data, que tomaria o lugar do CDC 6600, viria a ser o CDC 7600, lancado
   posteriormente em 69. Estas duas maquinas estao entre os supercomputadores de
   maior sucesso da historia, possuindo um parque em sua epoca com mais de 70
   maquinas instaladas. O sucesso comercial bem como o computacional foram tao
   grandes, que a IBM nao conseguia superar sua concorrente. A IBM lancou sua
   corrida aos supercomputadores atraves do projeto STRETCH, do laboratorio de
   computacao cientifica de Los Alamos, que pretendia projetar um computador 100
   vezes mais rapido que o IBM 704. A versao comercial do STRETCH sairia mais
   tarde atraves do IBM 7030, porem nao obteve sucesso comercial. Os
   23
   CAPITULO 2
   supercomputadores da serie CDC eram imbativeis. Em 1964 a IBM anuncia a serie
   de supercomputadores IBM 360, que segundo a IBM teria performance comparavel
   ao CDC 6600.
   A IBM perdia a cada dia o parque de computacao cientifica para sua rival.
   Em resposta a essa situacao, em 1967 a IBM lancou o IBM 360/91, que possuia
   uma performance cerca de duas vezes maior que o CDC 6600. Essa maquina
   possuia unidades de execucao separadas para operacoes com numeros reais e
   calculo de enderecamento de memoria (inteiro), as instrucoes eram executadas em
   paralelo atraves de arquitetura pipeline.
   A corrida continuaria e em 1969 a Control Data lancava a serie CDC 7600,
   com um desempenho cerca de duas vezes maior que o IBM 360/91. A disputa
   comercial trouxe muitos beneficios para a arquitetura de computadores. Em 1970 a
   IBM utilizaria o conceito de memoria cache [Zuffo, 1978] [Tabak, 1990], que ja teria
   sido utilizado desde o vagaroso ATLAS, e lanca o IBM 360/195, superando mais
   uma vez a Control Data.
   Ainda nas arquiteturas escalares, nao poderiamos deixar de citar as
   maquinas da Amdahl corporation. Essa companhia foi fundada por Gene Amdahl,
   chefe da equipe de arquitetura da seria IBM 360. Amdahl desenvolveu
   computadores baseados na arquitetura IBM 360. Com isso, suas maquinas alem de
   serem compativeis com os perifericos IBM, tambem poderiam utilizar software e
   sistema operacional desenvolvidos para as maquinas IBM. Isso foi muito
   importante, pois nesse periodo os fabricantes tomavam as interfaces com
   dispositivos de entrada e saida como segredos industriais. Empresas como a
   Amdahl, quebraram esses segredos e contribuiram muito com a historia da
   portabilidade [Bruno, 1995]. Um outro fator muito importante foi a utilizacao da nova
   tecnologia de integracao LSI. Com isso a maquina AMDAHL 470V/6 era cerca de
   um terco do tamanho de sua equivalente a IBM 360/168.
   2.5.2 - ARQUITETURA PIPELINE VETORIAL
   Em 1972, Seymour Cray deixou a Control Data com o proposito de fundar
   sua propria empresa, a Cray Research. A principal meta dessa empresa era
   desenvolver o supercomputador mais rapido do mundo. Em apenas quatro anos a
   Cray estaria nao apenas lancando o computador mais rapido do mundo, o CRAY-1
   (1976), como tambem revolucionando a arquitetura dos supercomputadores e
   24
   COMPUTACAO PARALELA - HARDWARE
   virando uma nova pagina na historia da computacao paralela. O CRAY-1 marcava
   um estagio evolucionario aos projetos CDC 6600 e CDC 7600 e atraves dele surgia
   um novo conceito em arquitetura, a arquitetura vetorial.
   Em geral, os problemas cientificos mais frequentes, com grande demanda
PA computacional, realizam de algum modo operacoes com matrizes ou vetores. A
   estrategia de paralelismo da arquitetura vetorial parte exatamente desse principio.
   Na arquitetura vetorial, diversos elementos de processamento sao replicados e
   arranjados de modo a favorecer o processamento de estruturas de dados vetoriais.
   Esses elementos sao controlados por uma unica unidade de controle, e muitas
   vezes com uma unica instrucao podem ser feitas operacoes em vetores inteiros.
   A Figura 2.4 apresenta um esquema generico de uma arquitetura vetorial.
   Neste modelo, e apresentada uma arquitetura vetorial real, onde os elementos sao
   realmente replicados. Na pratica, a ideia da arquitetura vetorial verdadeira e
   transposta para pipeline. Com o pipeline os elementos nao sao replicados
   realmente, ocorrendo entao paralelismo temporal ao inves de espacial [Almasi &
   Gottlieb, 1994].
   UCP
   ULA
   ULA
   ULA
   M
   M
   M
   UCP - Unidade Central de Processamento e de Controle
   M - Memoria
   ULA - Unidade de Logica e Aritmetica
   Fig. - 2.4 - Arquitetura Vetorial.
   Em relacao ao software, o programador pode perceber diretamente o
   potencial da arquitetura vetorial atraves das instrucoes. A arquitetura vetorial
   permite que ocorram instrucoes voltadas para vetores, que possam operar
   diretamente atraves desses sem a necessidade de indexadores.
   A Figura 2.5 apresenta uma comparacao entre dois codigos para
   multiplicacao de matrizes com 100 elementos, escritos em Fortran. No codigo para
   maquinas seriais, podemos observar a multiplicacao realizada a partir de uma
   25
   CAPITULO 2
   estrutura de laco (loop), que incrementa o indexador dos vetores. Atraves de uma
   maquina vetorial, em uma unica instrucao pode ser realizada essa operacao, como
   podemos observar no codigo paralelo, escrito em Fortran 90 [Almasi & Gottlieb,
   1994].
   Codigo em Fortran sequencial
   Codigo em Fortran 90, otimizado
   para maquinas vetoriais
   DO 10 I=1,100
   A(1:100)=B(1:100) * C(1:100)
   10 A( I ) = B( I ) * C( I )
   Fig. - 2.5 - Comparacao entre codigos Fortran.
   Embora o CRAY-1 tenha marcado a era das maquinas vetoriais, existiram
   outras duas maquinas anteriores ao CRAY-1, o CDC STAR 100 e o TIASC (Texas
   Instruments Advanced Scientific Computer).
   O projeto da STAR 100 iniciou-se em 1967, porem apenas em 1973, apos
   um processo de gestacao de seis anos, foi desenvolvida uma STAR 100
   operacional. Embora utilizasse uma arrojada arquitetura pipeline voltada para
   calculos vetoriais, a STAR 100 foi implementada utilizando memoria de nucleo
PA magnetico, uma tecnologia anterior as memorias de semicondutores. Devido ao
   atraso tecnologico, o acesso a memoria era demasiadamente lento comparado com
   as memorias semicondutoras, o que fazia com que o seu desempenho se
   equiparasse ao das maquinas sequenciais de uso geral contemporaneas. Apenas
   em vetores muito longos, da ordem de centenas a milhares de elementos, e com o
   codigo muito bem elaborado, o STAR era mais rapido que seus contemporaneos de
   uso geral. Com isso, seu projeto foi um completo fracasso, nao ocorrendo nenhuma
   venda comercial da maquina (apenas foram vendidas quatro maquinas que haviam
   previamente sido encomendadas pelo governo americano).
   Fato semelhante aconteceu com o TIASC. Seu projeto iniciou-se em 1966,
   porem apenas em 1973 estava operacional. Por ter sido projetado com uma
   tecnologia obsoleta, nao possuia um bom desempenho e tornou-se um fracasso
   comercial. A Texas Instruments nao deu continuidade ao projeto de maquinas
   vetoriais e deste modo nao houve prosseguimento ao TIASC.
   No entanto, o projeto STAR foi completamente reconstruido em tecnologia
   LSI e entrou em 1979 novamente no mercado com o nome de CYBER203E, que
   apos pequenas alteracoes ficou conhecido como CYBER205 (Figura 2.6). Essa
   26
   COMPUTACAO PARALELA - HARDWARE
   maquina tornou-se competitiva com o CRAY-1, embora tenha sido lancada tres
   anos apos o lancamento daquele.
   Embora o CYBER205 seja uma maquina vetorial, sua arquitetura possui
   uma estrategia para adaptacao de recursos de maquina generica. Enquanto o
   CRAY-1 possuia registradores vetoriais e tambem uma arquitetura totalmente
   otimizada para o calculo vetorial, o CYBER 205 processava os vetores diretamente
   da memoria, e sua estrutura pipeline podia ter caracteristicas de uso geral.
   Tanto o CRAY-1 quanto o CYBER 205 deram continuidade a sua
   revolucionaria arquitetura vetorial, e seguiram caminhos semelhantes de evolucao,
   atraves da replicacao de processadores. O CYBER 205 foi base para o
   supercomputador ETA-10, lancado em 1986. O ETA-10 foi a maquina mais rapida
   de sua epoca, possuia uma performance de pico de 10 Gflop/s (flop/s - operacoes
   com ponto flutuante por segundo).
   Buffer de
   Comunicacao
   IOP 0
   CPU 0
   add
   add
   add
   add
   IOP 1
   mult
   mult
   mult
   mult
   CPU 1
   div
   div
   div
   div
PA sqrt
   sqrt
   sqrt
   sqrt
   oria
   tilhada
   IOP 2
   CPU 2
   m
   par
   Me
   m
   Co
   IOP 3
   CPU 3
   Unidade Vetorial
   CPU 4
   IOP 16
   CPU 5
   Memoria Central
   IOP 17
   CPU 6
   CPU 7
   Unidade de
   Servico
   ETA-10 - Com sua configuracao maxima:
   CYBER 205 - quatro unidades
   8 CPUs - Unidades de Processamento
   pipeline de ponto flutuante de
   18 IOP - Portos de Entrada e Saida de dados
   uso geral identicas.
   Fig. - 2.6 - Diagramas das arquiteturas dos computadores Cyber205 e ETA-10.
   A Figura 2.6 apresenta um diagrama da arquitetura do ETA-10. O ETA-10
   podia possuir 2, 4, 6 ou 8 unidades de processamento, onde cada um desses
   processadores possuia a mesma arquitetura do Cyber-205, cuja arquitetura
   tambem e apresentada na Figura 2.6. O ETA-10 podia possuir tambem de 2 a 18
   portos de entrada e saida, atraves dos quais era possivel a comunicacao com
   27
   CAPITULO 2
   perifericos padrao, como discos, tapes e rede, e uma memoria compartilhada de 64,
   128, 192 ou 256 Mwords (64-bits).
   Fig. - 2.7 - Diagrama de arquitetura do computador CRAY - 1.
   O CRAY-1 foi a base para a evolucao da familia de computadores CRAY. A
   Figura 2.7 apresenta um diagrama da arquitetura do CRAY - 1, onde podemos
   observar os registradores especificos para vetores, e as pipelines assim como toda
   sua estrutura vetorial. Os primeiros modelos baseados no CRAY-1 foram o CRAY
   X-MP e o CRAY-2. Ambos, do mesmo modo que o ETA-10, seguiram o passo de
   28
   COMPUTACAO PARALELA - HARDWARE
   multiprocessamento, e multiplicaram seu poder replicando os processadores. O
PA CRAY X-MP foi lancado com dois processadores em 1982 e a versao com quatro
   processadores em 1984.
   A Figura 2.8 apresenta o arranjo esquematico de um CRAY X-MP, com sua
   versao de 2 processadores. Como podemos observar, o CRAY X-MP nada mais e
   do que a duplicacao de recursos computacionais do CRAY-1, uma vez que esse
   possui dois processadores CRAY-1. E importante observar que os computadores
   Cray X-MP, Cray 2 e Eta-10 sao exemplos de arquitetura MIMD, e foram aqui
   apresentados apenas para elucidar a evolucao de sua familia. Porem os nucleos
   desses permanecem como bons exemplos de arquitetura SIMD (arquitetura
   vetorial).
   UCP-1
   Intercom
   UCP-2
   Unidade de
   Controle
   Clock
   sincronizador
   Buffer de
   Instrucao
   Memoria
   word
   64bits
   -1
   dor
   -1
   dor
   Y
   Y
   A
   cessa
   A
   2Mword
   cessa
   CR
   ou
   CR
   Pro
   Pro
   4Mword
   E/S
   SSD
   Discos,
   2 a 4
   64Mbyte
   Tapes,
   Portos
   128Mbyte
   1 a 3
   ou
   entradas
PA 256Mbyte
   Fig. - 2.8 - Diagrama de arquitetura do computador CRAY X-MP/2.
   O CRAY-2 tambem seguiu a mesma linha evolutiva do CRAY X-MP, porem
   foi seu carater tecnologico que recebeu maior destaque em seu projeto (em
   comparacao ao CRAY X-MP). A compactacao e a utilizacao de processadores com
   alta frequencia foram suas principais caracteristicas. Devido a esses fatores, o
   CRAY-2 gerava 195 kW, que era aproximadamente a mesma quantia gerada pelo
   CRAY X-MP, porem sua dimensao reduzida restringia a dissipacao de toda essa
   energia. Para solucionar esse problema, um sofisticado sistema de refrigeracao foi
   adotado, onde todos os circuitos dos processadores, memoria e fontes ficavam
   imersos num liquido inerte e dieletrico de fluorcarbono. A Figura 2.9 apresenta o
   29
   CAPITULO 2
   computador CRAY-2. Seu extravagante sistema de refrigeracao proporcionava um
   aspecto inedito ao computador. Seus circuitos podiam ser observados imersos em
   liquido borbulhante atraves do vidro, dando um ar ficticio ao computador.
   Fig. - 2.9 - CRAY 2.
   Atualmente a CRAY Research faz parte da Silicon Graphics, dando uma
   enfase maior a visualizacao cientifica e computacao grafica na utilizacao das
   maquinas cientificas CRAY.
   2.5.3 - ARQUITETURA MATRICIAL
   Diferentemente da arquitetura vetorial, que apresentava apenas uma
   evolucao logica dos computadores sequenciais voltada para o calculo vetorial, a
   arquitetura matricial marcou uma mudanca radical na concepcao da computacao
   paralela. A arquitetura matricial nasceu basicamente a partir de um unico artigo de
   1962 [Hockney & Jesshope, 1988], intitulado "The SOLOMON Computer", cujo
   nome SOLOMON e um acronimo derivado de "Simultaneous Operation Linked
   Ordinal Modular Network". O trabalho descreve uma matriz bidimensional de 32 x
   32 elementos de processamento, onde cada um desses elementos contem uma
   memoria de 128 posicoes de 32 bits e uma unidade aritmetica. Toda essa estrutura
   esta sob o controle de uma unica unidade de controle e fluxo de instrucao. Embora
   SOLOMON tenha sido a origem das arquiteturas matriciais, houve ainda um artigo
   anterior no qual foi inspirado, o computador espacial, publicado por Unger em 1958
   30
   COMPUTACAO PARALELA - HARDWARE
   [Unger, 1958].
   [80-100]
   [104]
   ILLIAC IV
   Phoenix
   (1972)
   (?)
   [100]
   [50]
   [103]
   PEPE
   BSP
   NASF
   (1973)
   (1979)
PA (?)
   [200-600]
   Unger
   SOLOMON
   Staran
   MPP
   (1958)
   (1962)
   (1970)
   (1983)
   Clip
   (1976)
   [10-30]
   DAP
   (1978)
   Fig. - 2.10 - Familia dos computadores de arquitetura matricial. Os numeros
   em conchetes sao as performances maximas estimadas em mflops.
   Embora o conceito SOLOMON tenha sido uma revolucao em arquitetura de
   computadores, seu projeto nunca foi construido exatamente como descrito no artigo
   de 1962. Porem deu origem aos classicos computadores ILLIAC IV, Burroughs
   PEPE, Goodyear Aerospace STARAN e ICL DAP entre outros (ver Figura 2.10).
   Em 1966, a Universidade de Illinois, contratada pelo departamento de
   defesa americano (ARPA), iniciou o projeto de um computador baseado no
   SOLOMON. Nascia entao o classico ILLIAC IV (Figura 2.11 e 2.12), que possuia
   quatro quadrantes com uma unidade de controle e interpretacao de instrucoes para
   os 64 elementos de processamento de ponto flutuante. Cada um dos elementos de
   processamento tinha uma memoria com 2000 posicoes de 64 bits. Cada elemento
   de processamento e memoria, em cada quadrante, eram conectados por uma
   matriz de 8 x 8, e os quadrantes eram conectados por um barramento paralelo, o
   qual era tambem responsavel pela interface de uma unidade de disco, que era a
   unidade secundaria do sistema. Embora o projeto inicial possuisse quatro
   quadrantes, o ILLIAC IV foi construido utilizando apenas um, pela Burroughs
   Corporation 1969-73, conforme apresenta a Figura 2.11.
   31
   CAPITULO 2
   Entrada/Saida
   Barramento de dados
   Dados e Intrucoes
   MUC
   UC
   Barramento de controle
   EP0
   EP1
   EP63
   MEP0
   MEP1
   MEP63
   Rede de interconexao
   UC
   Unidade de Controle
PA MUC
   Memoria da Unidade de Controle
   EP
   Elemento de Processamento
   MEP
   Memoria do Elemento de Processamento
   Fig. - 2.11 - Diagrama de arquitetura do computador ILLIAC IV.
   EP56
   EP57
   EP58
   EP63
   EP63
   0
   1
   2
   7
   EP8
   EP7
   8
   9
   10
   15
   EP16
   EP15
   16
   17
   18
   23
   EP24
   EP55
   56
   57
   58
   63
   EP0
   EP0
   EP1
   EP2
   EP7
   Fig. - 2.12 - Configuracao da rede de elementos de processamento (EP).
   Pela primeira vez despontava a problematica do software paralelo. Um
   amplo investimento em software fez com que o ILLIAC IV possuisse seu proprio
   sistema operacional, assim como quatro linguagens de programacao especificas (
   TRANQUIL e GLYPNIR - derivadas do ALGOL, ACTUS - derivada do PASCAL e
   CFD FORTRAN).
   O projeto ILLIAC IV foi seguido pelo PEPE, computador encomendado a
   Burroughs com finalidades militares, e ao computador cientifico comercial BSP, e
   ainda ao Phoenix, projeto da NASA para substituir o ILLIAC IV. Classificado como
   multiplo-SIMD, o Phoenix possuia basicamente 16 maquinas ILLIAC IV, onde cada
   uma executava seu proprio fluxo de instrucoes, sob o controle de uma unica
PA 32
   COMPUTACAO PARALELA - HARDWARE
   unidade de controle.
   A arquitetura matricial marcou era na computacao paralela, tornando
   possivel a incorporacao de muitas unidades de processamento em maquinas
   (milhares). Contribuiu tambem para a pesquisa em software paralelo, que talvez
   venha a ser o maior desafio da computacao paralela.
   2.5.4 - ARQUITETURA MIMD
   O termo MIMD, derivado do ingles "Multiple Instructions Multiple Data", e
   proveniente do classico artigo de taxonomia de computadores, proposto por Flynn
   [Flynn, 1966]. Nas arquiteturas anteriores a MIMD, somente algumas partes da
   UCP sao replicadas, ou ainda, sao replicados pseudo-processadores, (ex:
   elementos de processamento da arquitetura matricial), onde existe um controle
   unico externo, que em geral e ainda responsavel pelo fluxo de instrucoes. Na
   arquitetura MIMD no entanto, UCPs (unidade central de processamento) sao
   inteiramente replicadas, e em certos casos computadores inteiros. Deste modo a
   arquitetura MIMD e verdadeiramente uma colecao de computadores formando uma
   unica maquina paralela.
   A arquitetura MIMD despontou no inicio da decada de 80, devido a queda de
   preco dos microprocessadores, assim como ao aumento da performance desses a
   partir da tecnologia VLSI. A arquitetura MIMD demonstrou ser a tecnologia
   integradora e evolutiva das arquiteturas SIMD. A maioria do prosseguimento de
   projeto das tecnologias vetoriais e matriciais acabaram por se tornar arquiteturas
   MIMD replicadoras de SIMD. Como exemplos, temos as arquiteturas Phoenix, Cray
   2, Cray X-MP e Eta 10, descritas anteriormente como SIMD (modo didaticamente
   evolutivo), mas que na verdade sao maquinas MIMD paralelizando SIMD. A
   arquitetura MIMD amadureceu, chegando ate os dias de hoje, onde e a mais
   utilizada tanto em pesquisa quanto comercialmente.
   O maior desafio para os projetos de arquiteturas MIMD esta exatamente na
   comunicacao entre os computadores. Na maior parte dos casos, os processadores
   utilizados sao comerciais de larga difusao e de uso generico, porem a consolidacao
   da tendencia MIMD fez com que surgissem processadores especificos para
   projetos de maquinas MIMD. Entre eles podemos citar a linha Transputer da Inmos
   e os processadores de processamento de sinais da Texas Instruments.
   A partir da comunicacao ou integracao dos processadores, podemos
   33
   CAPITULO 2
   classificar a arquitetura MIMD basicamente em memoria compartilhada e memoria
   distribuida, conforme apresenta a Figura 2.13. A diferenca basica entre os dois
   modelos e que enquanto os sistemas de memoria compartilhada utilizam uma unica
   memoria acessivel a todos os processadores, e a utilizam para trocar informacoes,
   nos sistemas de memoria distribuida, por outro lado, cada um dos processadores
   possui sua propria memoria, inacessivel para os demais, e utilizam troca de
   mensagens via rede ou barramento para efetuar a comunicacao.
   rede ou barramento
   P
   P
   P
   P
   P
PA P
   Memoria
   M
   M
   M
   Memoria compartilhada
   Memoria distribuida
   Fig. - 2.13 - Memoria compartilhada versus memoria distribuida.
   UCP 0
   Secao 0
   Porto A
   Registradores
   a
   da UCP
   Sub-secoes
   Porto B
   a de
   16 bancos
   rot
   mori
   lecionador
   Registr. de
   de
   Me
   Porto D
   Se
   Instrucao
   da
   ida
   rtilha
   Sa
   pa
   e
   om
   cao de
   da
   Se
   UCP 7
   tra
   ia C
   En
   or
   em
   Porto A
   Registradores
   M
   a
   da UCP
   Porto B
   a de
PA rot
   mori
   Secao 7
   lecionador
   Registr. de
   de
   Me
   Porto D
   Se
   Instrucao
   Sub-secoes
   16 bancos
   Fig. - 2.14 - Organizacao da memoria do Cray - J90.
   Entre as maquinas MIMD de memoria compartilhada atuais podemos citar:
   as series J90 e T90 da Cray, a AlphaServer da Digital, a serie Hitachi S3800, o
   NEC SX-4, a Starfire E10000 da Sun, Connection Machine CM-5, etc. A Figura 2.14
   34
   COMPUTACAO PARALELA - HARDWARE
   apresenta um diagrama da arquitetura da maquina Cray - J90 uma tipica MIMD de
   memoria compartilhada.
   Unidade de Ponto Flutuante
   VCC
   GND
   CapPlus
   CapM inus
   Processador
   Reset
   Analyse
   Servicos do
   32 bit
   ErrorIn
   Sistema
   Error
   BootFromROM
   ClockIn
   Servicos de
   LinkSpecial
   ProcSpeed
   Link0Special
   Select0-2
   Link
   Link123Special
   LINK 0 Entrada
   Timers
   Interface - Link
   LINK 0 S aida
   LINK 1 Entrada
   Interface - Link
   RAM
   LINK 1 S aida
PA 4 Kbytes
   Interface - Link
   LINK 2 Entrada
   LINK 2 S aida
   ProcClockOut
   LINK 3 Entrada
   NotMemS0-4
   Interface - Link
   LINK 3 S aida
   NotM emWrB0-3
   Interface
   NotMemRd
   NotMemRf
   Memoria
   MemWait
   Externa
   MemConfig
   Memoria
   MemReq
   MemGranted
   Fig. - 2.15 - Diagrama em blocos do processador Transputer IMS T800.
   As maquinas MIMD de memoria distribuida, obtiveram uma atencao maior a
   partir da metade da decada de 80. A arquitetura MIMD de memoria distribuida,
   praticamente comecou com um projeto Cosmic Cube da Caltech. Esse projeto
   introduziu toda a pesquisa em torno de redes de conexao de processadores
   (hipercubos) [Almasi & Gottlieb, 1994]. O Cosmic Cube foi uma maquina baseada
   no processador 8086 e seu coprocessador de ponto flutuante 8087 (famosos devido
   aos microcomputadores pessoais), que integrava 64 pares de processadores (8086
   e 8087), conectados com arquitetura de hipercubo [Hockney & Jesshope, 1988]. A
   partir de 1985, com o lancamento do Transputer (Inmos), um processador
   destinado ao desenvolvimento de arquiteturas paralelas, houve uma grande difusao
   da pesquisa e utilizacao de arquitetura MIMD. Devido ao fato de ser
   especificamente voltado ao desenvolvimento de sistemas paralelos, o Transputer
   tornava os projetos paralelos simples e com custos competitivos. Alem de contar
   com uma serie de ferramentas e linguagens que realizavam o suporte de
   programacao. A Figura 2.15 apresenta o diagrama do processador Transputer
   35
   CAPITULO 2
   [Inmos, 1988].
   Dentre o universo das maquinas MIMD distribuidas podemos citar:
   Intel iPSC, Intel Paragon, Cray T3E, Avalon A12, nCUBE 2S, As maquinas
   baseadas em Transputer (ex: IBM - Victor), IBM 9076 SP2, etc.
   2.5.5 - COMPUTACAO DISTRIBUIDA
   No final da decada de 80, devido ao desenvolvimento e proliferacao da
   tecnologia de redes de computadores e do mesmo modo a diminuicao do custo dos
   microcomputadores, surgiu uma nova arquitetura paralela denominada de
   Computacao Distribuida. Ao inves de desenvolver hardware especifico, o conceito
   de Computacao Distribuida utiliza computadores padrao (ou nao) conectados por
   rede de computadores (ethernet ou outra), ficando todo o mecanismo de
   paralelizacao sob a responsabilidade das camadas de software [Tanenbaum, 1990],
PA sendo essa em nivel de sistema operacional, atraves de sistemas operacionais
   distribuidos [Tanenbaum, 1995], ou ainda atraves de ferramentas de troca de
   mensagens tais como PVM [Geist et al., 1996], MPI [Pacheco, 1997] ou ainda
   CVMP apresentada nesta tese.
   Embora a velocidade de comunicacao das redes de computadores seja
   muito mais lenta do que atraves dos mecanismos desenvolvidos em hardware, a
   simplicidade e baixo custo fizeram com que os Sistemas Distribuidos viessem a se
   tornar a mais difundida utilizacao de arquiteturas paralelas, somando a utilizacao
   comercial e cientifica [Almasi & Gottlieb, 1994].
   Segundo a classificacao de Flynn [Flynn. 1972], a Computacao Distribuida e
   considerada MIMD de memoria distribuida [Almasi & Gottlieb, 1994], seguindo a
   mesma heuristica de arquitetura e software. Assim como ocorrem em algumas
   maquinas de arquitetura MIMD, que podem ser compostas por elementos de
   processamento com arquiteturas paralelas diferentes, como por exemplo o CRAY -
   J90 (MIMD com processadores SIMD), os sistemas distribuidos podem integrar um
   unico sistema e possuir diversas arquiteturas paralelas diferentes, trabalhando
   juntas. Alem de possuir tal caracteristica heterogenea, os Sistemas Distribuidos
   ainda podem possuir um numero de unidades de processamento variaveis,
   caracterizando sua utilizacao em sistemas tolerantes a falha. Para caracterizar um
   aglomerado de estacoes como Sistema Distribuido (Computacao Distribuida), basta
   que exista um mecanismo de integracao das maquinas e que atraves desse
   36
   COMPUTACAO PARALELA - HARDWARE
   mecanismo de troca de mensagens sejam capazes de realizar uma mesma tarefa
   (ou diferentes partes de uma mesma tarefa). O numero de maquinas (elementos de
   processamento) de um Sistema Distribuido varia muito, indo desde 2 a mesmo
   milhares de maquinas. A Figura 2.16 apresenta um diagrama de um Sistema
   Distribuido heterogeneo, onde juntos podem operar estacoes de trabalho de
   diversas plataformas diferentes (PCs, estacoes de trabalho RISC) assim como
   supercomputadores MIMD e ou SIMD, conectados por rede.
   Fig. - 2.16 - Sistema Distribuido Heterogeneo.
   2.6 - TAXONOMIA DE COMPUTADORES
   Anteriormente, descrevemos uma serie de tecnologias apresentadas com
   sua evolucao no tempo. Obviamente, nao abordamos todo o universo das
   arquiteturas paralelas, apenas tracamos um breve perfil da evolucao da
   computacao paralela, com o intuito de formar bases para as nocoes de arquitetura
   de computadores requeridas nesta tese.
   As inumeras possibilidades de organizacao dos computadores, assim como
   a diversidade de processadores, geram a necessidade da classificacao dos
   computadores, a fim de encontrarmos familias as quais podem ser agrupadas,
   melhor estudadas e comparadas. Existem inumeras propostas encontradas na
   literatura para classificar as diferentes arquiteturas e organizacao dos
   37
   CAPITULO 2
   computadores, podemos citar entre elas: Flynn [Flynn, 1966], Feng [Hwang et al.,
   1984], Handler [Hwang et al., 1984], Gajski [Amorin et al.,1988], Shore [Hockney &
   Jesshope, 1988], Estrutural [Hockney & Jesshope, 1988], Kuck [Almasi & Gottlieb,
   1994], Treleaven [Almasi & Gottlieb, 1994], Duncan [Duncan, 1990], etc. Nesta
   secao vamos apresentar tres delas: classificacao de Flynn, taxonomia estrutural de
   Hockney e classificacao de Duncam.
PA A classificacao de Flynn e a mais divulgada pela literatura, embora seja
   bastante antiga, originaria a partir de um artigo de 1966. A tradicao e a
   popularizacao tornaram-na a mais importante taxonomia de computadores,
   permanecendo a mais utilizada atualmente, mesmo com suas falhas e duvidas
   [Bogni & Marrone, 1991]. Devido a sua importancia, trataremos esta classificacao
   com maiores detalhes que as demais.
   Na tentativa de realizar uma classificacao bastante abrangente, foi proposta
   a taxonomia estrutural de Hockney. Esta classifica tanto os computadores
   (historicos) sequenciais, quanto os paralelos (ate os atuais). A maior caracteristica
   da taxonomia estrutural e a sua diversidade de classes. Embora seja bastante
   abrangente, essa classificacao e pouco conhecida e utilizada. Apresentaremos
   sucintamente a taxonomia estrutural na Secao 2.6.2.
   Com o surgimento de novas tecnologias e com o decorrer de decadas de
   pesquisa houve uma diversificacao das arquiteturas de computadores paralelos,
   muitas das quais nao poderiam ser classificadas atraves da taxonomia classica.
   Tendo em vista esse problema, Duncan propos uma classificacao extensiva a
   classificacao de Flynn, atraves do artigo "A Survey of Parallel Computer
   Architectures" [Duncan, 1990]. Finalizaremos a secao Taxonomia de Computadores
   apresentando sucintamente a proposta de Duncan, na Secao 2.6.3.
   2.6.1 - CLASSIFICACAO DE FLYNN
   O primeiro metodo de classificacao de computadores foi inicialmente
   proposto por Flynn, em seu celebre artigo de 1966, intitulado "Very High Speed
   Computing Systems" [Flynn, 1966], mais tarde apresentado com maior formalidade,
   em 1972 [Flynn, 1972]. O metodo consiste nas possibilidades de combinacao entre
   uma ou mais sequencias de instrucoes atuando sobre uma ou mais sequencias de
   dados.
   O principio basico do funcionamento de um processador e a busca de
   38
   COMPUTACAO PARALELA - HARDWARE
   operandos na memoria principal, seguindo da execucao das instrucoes compostas
   por esses operandos e finalmente no armazenamento dos resultados obtidos na
   memoria. Assim sendo, as etapas distintas associadas ao processamento de uma
   instrucao constituem o ciclo de instrucoes. Deste modo um ciclo de instrucao e
   composto por:
   Encontrar o endereco da instrucao
   Buscar a instrucao
   Decodificar a instrucao
   Gerar os enderecos referentes aos operandos
   Executar a instrucao
   Armazenar os resultados
   A visualizacao da sequencia da execucao das instrucoes pode ser
   comparada a um fluxo ou corrente. O fluxo de instrucoes dirigi-se da memoria para
   o processador. A partir da execucao das instrucoes, sao solicitados dados,
   armazenados na memoria, cuja visualizacao pode igualmente ser comparada a um
   fluxo ou corrente (fluxo de dados). O fluxo de dados por sua vez, possui uma dupla
   corrente, indo e vindo da memoria para o processador e do processador para a
   memoria.
   Numero de Fluxo de Dados
   Simples
   Multiplos
PA Numero de
   Simples
   SISD
   SIMD
   Fluxo de
   Instrucoes
   Multiplos
   MISD
   MIMD
   Fig. - 2.17 - Classificacao de Flynn.
   Baseado no fluxo de instrucoes e no fluxo de dados, Michael J. Flynn
   realizou uma classificacao de computadores, sugerindo combinacoes de classes de
   fluxos de dados versus fluxo de instrucoes. A partir dessas combinacoes, Flynn
   sugeriu quatro classes de computadores: Um fluxo de instrucao e um fluxo de
   dados - SISD (do ingles "Single Instruction stream Single Data stream"), um fluxo
   39
   CAPITULO 2
   de instrucao e multiplos fluxos de dados - SIMD (do ingles "Single Instruction
   stream Multiple Data stream"), multiplos fluxos de instrucao e um fluxo de dados -
   MISD (do ingles "Multiple Instruction stream Single Data stream") e multiplos fluxos
   de instrucao e multiplos fluxos de dados - SISD (do ingles "Multiple Instruction
   stream Multiple Data stream"). (ver Figura 2.17).
   Apresentaremos cada um dos casos a seguir, e um diagrama
   correspondente a arquitetura classificada. Em cada um dos diagramas mostrados
   serao apresentadas apenas tres especies de componentes de sistema: Unidade de
   Controle (UC), Unidade de Processamento (UP) e Memoria (M) (Figuras 2.18, 2.19,
   2.20 e 2.21).
   Unidade de Controle (UC) - Responsavel pela decodificacao das instrucoes
   e pelo envio das instrucoes decodificadas ao processador.
   Unidade de Processamento (UP) - Executa as instrucoes e armazena os
   resultados na memoria.
   Memoria (M) - Armazena os dados.
   Alem dos componentes do sistema tambem serao apresentados os fluxos
   de dados (FD) e os fluxos de instrucoes (FI). Observando as Figuras 2.18, 2.19,
   2.20 e 2.21, devemos notar que cada fluxo de instrucoes e gerado por uma unidade
   de controle independente.
   2.6.1.1 - SISD - UM FLUXO DE INSTRUCAO E UM FLUXO DE
   DADOS
   A classe SISD classifica as arquiteturas convencionais, ou de von
   Neumman, ou seja os computadores sequenciais, que compoem a maioria do
   nosso parque atualmente. Embora a maioria dos microprocessadores atuais SISD
   possuam mais do que uma unidade funcional e pipeline de instrucao [Gimarc &
   Milutinovic, 1987], todas as suas unidades funcionais estao sob a supervisao de
   uma unica unidade de controle, classificando-os deste modo como SISD (Figura
   2.18).
   40
   COMPUTACAO PARALELA - HARDWARE
   FI
   UC
   FI
PA UP
   FD
   M
   Fig. - 2.18 - Diagrama da arquitetura SISD.
   2.6.1.2 - MISD - MULTIPLOS FLUXOS DE INSTRUCAO E UM
   FLUXO DE DADOS
   A Figura 2.19 apresenta um diagrama conceptual da arquitetura
   MISD. Nao existe nenhuma implementacao real desse tipo de arquitetura,
   ocorrendo entao uma falha de classificacao do modelo de Flynn [Almasi & Gottlieb,
   1994] [Duncan, 1990].
   FD
   UC
   FI1
   1
   UP1
   FI2
   UC1
   UP2
   M1
   M2
   Mn
   FIn
   UC1
   UPn
   FI1
   FD
   FIn
   FI2
   Fig. - 2.19 - Diagrama da arqui t etura MISD.
   41
   CAPITULO 2
   2.6.1.3 - SIMD - UM FLUXO DE INSTRUCAO E MULTIPLOS
   FLUXOS DE DADOS
   UP
   FD
   1
   1
   M1
   UP
   FD2
   M
   UC
   2
   FI
   2
   UP
   FDn
   n
   Mn
   FI
PA Fig. - 2.20 - Diagrama da arquitetura SIMD.
   A classe SIMD corresponde aos computadores matriciais e vetoriais.
   Conforme podemos observar na Figura 2.20, existem muitos elementos de
   processamento sendo supervisionados por uma unica unidade de controle. Todos
   os elementos de processamento recebem a mesma instrucao, transmitida pela
   unidade de controle, porem operam as instrucoes sobre distintos fluxos de dados.
   Na pratica, a classificacao SIMD levanta algumas duvidas e polemicas. Na
   literatura podemos encontrar alguns autores que classificam maquinas vetoriais
   pipeline (ex: Cray-1, Cyber-205) como SIMD [Almasi & Gottlieb, 1994] [Hockney &
   Jesshope, 1988], enquanto outros autores as classificam como SISD [Hwang et al.,
   1984] [Bogni & Marrone, 1991].
   42
   COMPUTACAO PARALELA - HARDWARE
   2.6.1.4 - MIMD - MULTIPLOS FLUXOS DE INSTRUCAO E
   MULTIPLOS FLUXOS DE DADOS
   FI1
   FD1
   UC1
   UP1
   M1
   FI1
   FI1
   FI
   FI
   2
   FD2
   UC
   2
   1
   UP2
   M2
   FI2
   FIn
   FIn
   FDn
   UC1
   UPn
   Mn
   FIn
   Fig. - 2.21 - Diagrama da arquitetura MIMD.
   A Figura 2.21 apresenta um diagrama conceptual da arquitetura MIMD. A
   maioria dos sistemas paralelos atuais podem ser classificados nessa categoria,
   gerando deste modo uma sobrecarga a esta classe, que abrange tanto as
   maquinas multiprocessadores (memoria compartilhada) quanto os sistemas
   multicomputadores (memoria distribuida). Deste modo, segundo a organizacao da
   memoria, a classe MIMD e diretamente dividida em MIMD memoria compartilhada e
   MIMD memoria distribuida (Figura 2.13).
   43
   CAPITULO 2
   2.6.2 - TAXONOMIA ESTRUTURAL
PA Computadores
   Unico fluxo de Instrucao
   Multiplo fluxo de Instrucao
   Unica unidade
   de execucao
   Aritmetica de
   Aritmetica de
   MIMD
   inteiro
   ponto flutuante
   (figura 2.24)
   serial 1-bit
   Paralelo n-bit
   Computadores
   Computadores
   Computadores
   sequenciais de
   sequenciais de
   sequenciais de
   bit serial
   bit paralelo
   ponto flutuante
   EDSAC1
   IBM 701
   IBM 7090
   Multiplas unidades
   UNIVAC1
   de execucao
   Pipelined
   Sem pipeline
   Computadores
   matriciais
   (figura 2.23)
   Somente instrucoes
   Instrucoes
   escalares
   vetoriais
   Computadores
   com multiplas
   unidades
   escalares
   Controle
   Issue-When-
   Pipeline
   Pipeline
   Horizontal
   ready
   Uso especifico
   Uso Geral
   CDC 6600
PA Computadores
   Computadores
   Computadores
   Computadores
   com pipeline
   com pipeline
   com pipeline
   com pipeline
   escalar
   escalar
   escalar
   escalar
   horizontal
   horizontal
   CDC 7600
   CYBER 205
   FPS AP-120B
   CRAY - 1
   Fig. - 2.22 - Diagrama da classificacao estrutural.
   A taxonomia estrutural proposta por [Hockney & Jesshope, 1988] e uma
   classificacao bastante abrangente tanto para os computadores sequenciais quanto
   para os paralelos. As Figuras 2.22, 2.23 e 2.24 apresentam o diagrama da
   classificacao, que correspondem respectivamente a classificacao geral, maquinas
   matriciais e MIMD.
   A primeira estrategia utilizada para a classificacao e a divisao dos
   computadores em dois grandes grupos: computadores com um unico fluxo de
   instrucao e computadores com diversos fluxos de instrucao. Atraves dessa primeira
   etapa, e separado o universo dos computadores MIMD (diversos fluxos de
   instrucao) dos demais (unico fluxo de instrucao - seriais e SIMD). A classe dos
   44
   COMPUTACAO PARALELA - HARDWARE
   computadores com unico fluxo de instrucoes e entao dividida em: unica unidade de
   execucao e multiplas unidades de execucao. A primeira classe agrupa os
   computadores sequenciais classicos. A classe de computadores com multiplas
   unidades de execucao e dividida em pipeline, maquinas matriciais e multiplas
   unidades de execucao sem pipeline. A partir dessa divisao podemos notar a grande
   abrangencia da taxonomia estrutural, observando a classificacao da classe pipeline
   e matricial. O diagrama da classificacao das maquinas matriciais e apresentado na
   Figura 2.23.
   As maquinas matriciais sao divididas em duas classes: maquinas com
   unidades de execucao de ponto flutuante e maquinas com unidades de execucao
   com poucos bits (computadores ortogonais e associativos).
   Processador
   matricial
   Unidade de
   Unidade de
   execucao de
   execucao com
   ponto flutuante
   poucos bits
PA Desconectado
   Conectado
   Conectado X
   Desconectado
   Conectado
   Memoria ortogonal
   Conjunto de
   Matriz de
   Matriz de proc.
   Computador
   Matriz de
   Co mputador
   Processadores
   processadores
   de p. flutuante
   Associativo
   processadores
   ortogonal de
   de ponto
   de ponto
   conectados em
   de poucos bits
   poucos bits
   flutuante
   flutuante
   X
   STARAN
   ICL DA P
   OMEN
   PEPE
   ILLIAC IV
   BSP
   Fig. - 2.23 - Arquiteturas matriciais.
   Como comentamos anteriormente, a primeira divisao da taxonomia
   estrutural separa os computadores MIMD dos demais. As classes de computadores
   MIMD sao apresentadas no diagrama 2.24, que e uma continuacao da Figura 2.22.
   Diferentemente da divisao: memoria distribuida e memoria compartilhada;
   denotacao essa largamente utilizada na literatura, a taxonomia estrutural de
   Hockney divide as maquinas MIMD primeiramente entre maquinas com
   comutadores e maquinas com redes. As maquinas MIMD de memoria
   compartilhada tornam-se entao uma subclasse das maquinas com comutadores.
   45
   CAPITULO 2
   Devemos observar novamente a divergencia da classificacao, onde temos grupos
   para cada topologia, no caso de redes, assim como diferentes classes para as
   diferentes estruturas de comutadores, para as classes de maquinas com
   comutadores.
   MIMD
   Macro pipeline
   Comutado
PA Rede
   CHiP
   CRAY X-MP
   CRAY 2 e 3
   Crossbar
   Midas
   Reconfiguravel
   ETA10
   Memoria
   Multi-estagio
   ULTRA
   compartilhada
   Anel
   barramento
   C
   C
   C
   malha
   MINERVA
   Multidimensional
   ELXSI
   FPS5000
   M
   M
   M
   FLEX/32
   Cosmic
   Intel iPSC
   hipercubo
   N-CUBE
   Cubo
   Crossbar
   EMPRESS
   Conectado
   Memoria
   Multi-estagio
   ciclicamente
   PASM
   distribuida
   barramento
   PRINGLE
   NC-TREE
   Arvore
   Hierarquica
   C
   C
   C
   X-TREE
   M
   M
PA M
   EGPA
   Piramide
   M
   Memoria
   Aglomerado
   C
   Computador
   Fig. - 2.24 - Classificacao estrutural para MIMD.
   2.6.3 - CLASSIFICACAO DE DUNCAN
   Segundo Duncan [Duncan, 1990], a decada de 1980 foi marcante para a
   computacao paralela devido a sua proliferacao e popularizacao. As recentes
   descobertas e a proliferacao da tecnologia de processamento paralelo introduziram
   novas arquiteturas ao contexto da computacao paralela. Deste modo tornou-se
   dificil a compreensao e a classificacao das arquiteturas paralelas baseadas na
   taxonomia classica (Flynn).
   Tentando resolver o problema da classificacao de maquinas paralelas
   46
   COMPUTACAO PARALELA - HARDWARE
   Duncan, propos sua taxinomia baseado no seguinte conjunto de imperativos:
   Excluir as arquiteturas que utilizem somente mecanismos de paralelismo de baixo-
   nivel (comuns nos microcomputadores atuais: Pentium, RISC, etc...).
   Continuar adotando os elementos baseados em fluxo de dado e instrucoes da
   classificacao de Flynn.
   Incluir processadores vetoriais (pipeline), e outras arquiteturas que intuitivamente
   deveriam receber o merito de pertencer as classes de computadores paralelos.
   Conforme vimos anteriomente na classificacao de Flynn, essas arquiteturas sao
   classificadas como SISD e nao como SIMD por alguns autores.
   A Figura 2.25 apresenta um diagrama da classificacao sugerida por Duncan.
   As arquiteturas sao divididas em tres classes: Sincronas, Assincronas ou MIMD e
   nao convencionais. A classe Sincrona contem uma extensao da classe SIMD de
   Flynn. A esta classe, alem de pertencer as arquiteturas SIMD, foram formalmente
   inseridas as arquiteturas vetoriais assim como arquiteturas sistolicas [Duncan,
   1990], devido a sua caracteristica sincrona. A subclasse SIMD foi ainda dividida em
   processadores matriciais e memoria associativa.
   Nao
   Sincronas
   Convencionais
   MIMD
   Vetorial
   SIMD
   Sistolica
   Memoria
   Memoria
   Compartilhada
   Distribuida
   Processadores
   Memoria
   Matriciais
   Associativa
PA MIMD/SIMD
   Dataflow
   Reducao
   Frente de Onda
   Fig. - 2.25 - Classificacao de Duncan.
   A classe de arquitetura MIMD (assincrona) permaneceu com as mesmas
   47
   CAPITULO 2
   subdivisoes classicas: Memoria Compartilhada e Distribuida. Duncan porem
   apresenta uma nova classe, para atender as arquiteturas mais modernas. A classe
   de arquiteturas nao convencionais classifica os novos paradigmas introduzidos a
   arquitetura paralela. Embora sejam todas derivadas da arquitetura MIMD, as
   arquiteturas hibridas MIMD/SIMD (exemplo: DADO e o Non-von [Almasi & Gottlieb,
   1994]), maquinas de reducao (Newcastle Reduction Machine, Utah Applicative
   Multiprocessing System [Duncan, 1990]), matrizes de frente de onda
   (implementacoes assincronas de arranjos sistolicos [Kung et al., 1987]) e fluxo de
   dados (MDM - Manchester Dataflow Machine [Almasi & Gottlieb, 1994] e MIT
   Tagged Token Dataflow [Duncan, 1990]) sao dificeis de enquadrar em uma
   classificacao convencional.
   48
   CAPITULO
   3
   COMPUTACAO PARALELA -
   SOFTWARE
   A medida que paralelizamos nossos algoritmos, multiplicamos nossos problemas.
   (pensamento do autor)
   49
   CAPITULO 3
   50
   A COMPUTACAO PARALELA - SOFTWARE
   CAPITULO 3 - COMPUTACAO PARALELA -
   SOFTWARE
   3.1 - INTRODUCAO
   No capitulo anterior abordamos a computacao paralela e os sistemas
   distribuidos sob o prisma do hardware. Iremos agora discorrer sobre o mesmo
   assunto atraves do ponto de vista do software. O software e um importante conceito
   abstrato, responsavel por toda a base da ciencia da computacao. Somente a partir
   do conceito de programa armazenado (software), proposto por John von Neumann
   em meados de 1950, o computador moderno passou a existir, fechando
   definitivamente o capitulo das super calculadoras da historia da ciencia da
   computacao.
   O conceito abstrato de software ou programa permitiu o aparecimento dos
   computadores de uso generico. As primeiras maquinas parecidas com o que hoje
   denominamos "computador", eram construidas para fins especificos. A partir da
   teoria da computabilidade [Penrose, 1989], surgiu o conceito de programa. Assim,
   os computadores passaram a resolver todo e qualquer problema, desde que fosse
   ele computavel, bastando para isso apenas alterar o conteudo de sua memoria de
   programa. Embora pareca trivial, esse conceito solidificou as bases da computacao
   moderna, construindo toda a sua historia.
   Na computacao paralela, um dos maiores desafios e o desenvolvimento de
PA software paralelo. Atualmente, grande parte da pesquisa da computacao paralela
   encontra-se destinada a esse aspecto. Embora em muitos casos o paralelismo seja
   realizado unicamente pelo hardware, ficando transparente as camadas de software
   (ex: pipeline), em outros, como por exemplo os sistemas distribuidos, toda a
   abstracao das maquinas virtuais, assim como seus mecanismos de paralelismo,
   sao inteiramente realizados pelo software.
   Trataremos neste capitulo do conceito de software em linhas gerais, em
   todos os niveis da maquina (Figura 3.1), enfocando principalmente a exploracao do
   paralelismo em cada um desses niveis.
   Iniciaremos a discussao com o conceito de software e logo depois
   51
   CAPITULO 3
   apresentaremos o modelo em camadas do computador moderno. Para cada uma
   dessas camadas discutiremos a atuacao do software, assim como a exploracao de
   paralelismo atraves deste. Finalmente, concluiremos o capitulo apresentando
   alguns conceitos e ferramentas voltados para o desenvolvimento e utilizacao de
   software.
   3.2 - SOFTWARE
   Aproveitando a caracteristica multidisciplinar desta tese, vamos apresentar
   uma parabola para ilustrar melhor a distincao entre software e hardware nos
   computadores, comparando-os com os sistemas nervosos biologicos, mais
   especificamente com o cerebro humano. Atraves desse paralelo entre homem e
   maquina, podemos denominar de hardware, todas as caracteristicas fisico-quimicas
   dos neuronios, que sao as celulas nervosas que compoem o sistema nervoso;
   seguindo a mesma linha de raciocinio, o software, seria todo o sistema de
   aprendizado. Como sabemos, o aprendizado e vital para o funcionamento do
   cerebro, ele e responsavel pela definicao da forma e modo de processamento
   realizado por cada uma das diferentes regioes cerebrais (hardware). Deste modo,
   podemos dizer que e o software que determina a forma e o modo de manipulacao
   do hardware, e ainda podemos concluir que sem o aprendizado (software) a parte
   fisica do cerebro (hardware) seria apenas um aglomerado de celulas, e voce caro
   leitor, jamais estaria lendo esta tese.
   Vamos continuar essa discussao no proximo capitulo, entretanto, a
   finalidade dessa simples comparacao foi ilustrar a importancia do software. Embora
   extremamente dependente das bases do hardware, a sofisticacao evolutiva
   (instinto, decisao, razao, sentimento, etc.) fica sob a responsabilidade do software.
   O mesmo ocorre nos computadores. Embora necessite de um meio fisico
   (hardware) para concretizar-se, o software e o elemento responsavel pelo
   comportamento da maquina. E atraves dele que os computadores modernos sao
   capazes de executar suas funcoes.
   Agora que ja observamos sua importancia, vamos a sua definicao: Software
   pode ser definido como uma abstracao compreendida por algoritmos, instrucoes,
   dados e informacoes responsaveis pelo controle, supervisao e manipulacao do
   hardware.
   Como podemos observar atraves do modelo de camadas apresentado na
   52
   A COMPUTACAO PARALELA - SOFTWARE
   Figura 3.1, muitas vezes o limiar entre software e hardware e bastante sutil, de
   modo que a sua diferenciacao sob determinados niveis de maquina e bastante
   complexa. No entanto, em termos gerais, podemos definir o hardware como a parte
PA fisica do computador e o software como a abstracao responsavel por sua
   manipulacao.
   3.3 - MODELO DE CAMADAS
   Um importante conceito que devemos levar em conta na organizacao dos
   computadores e a vinculacao das camadas de software ao hardware. A partir do
   modelo de camadas [Tanenbaum, 1990], os computadores sao definidos como
   composicoes de hardware e software. Levando em conta o hardware e o software
   ao definirmos os computadores, estamos acrescentando o conceito de plataforma.
   Deste modo, uma mesma maquina pode, em funcao das camadas de software
   (principalmente Sistema Operacional), pertencer a diferentes plataformas. Um bom
   exemplo dessa abordagem sao os computadores pessoais PC. Embora o hardware
   seja o mesmo, a maquina pode pertencer a diferentes plataformas, e deste modo
   modificar seu comportamento, bastando para isso alterar seu sistema operacional
   (ex: UNIX, Windows, Windows NT, DOS e OS/2). A partir desse conceito o software
   passa a constituir parte da arquitetura dos computadores.
   Linguagem de Alto Nivel
   Traducao (compilador)
   Linguagem Assembly
   Traducao (assembler)
   re
   wa
   Sistema Operacional
   ft
   Interpretacao Parcial
   So
   (Sistema Operacional)
   Convencional
   Interpretacao (Microprograma)
   are
   Microprogramacao
   dw
   Execucao dos microprogramas
   Har
   diretamente no hardware
   Hardware
   Fig. - 3.1- Organizacao generica em camadas dos computadores.
   53
   CAPITULO 3
   A Figura 3.1 ilustra a classica divisao em camadas na organizacao dos
   computadores proposta por Tanenbaum [Tanenbaum, 1990]. Esse modelo pode
   variar muito de computador para computador, tanto em numero de camadas quanto
   em sua diferenca. Nesta figura, representa-se um tipico computador CISC (do
   ingles Complex Instruction Set Computer) [Gimarc & Milutinovic, 1987]. Devemos
   observar tambem que o desempenho de cada camada e afetado diretamente pelas
   camadas inferiores.
   A primeira camada do modelo apresentado pela Figura 3.1 representa
   hardware. Nesta secao nao abordaremos o paralelismo contido nessa camada,
   uma vez que ja foi bastante discutido no capitulo anterior. A segunda camada e
   constituida pela micromaquina ou microprogramacao. Em computadores CISC,
   compete a micromaquina controlar os recursos do hardware. Deste modo, cada
PA instrucao do nivel convencional, ao ser processada, e interpretada e dividida pela
   unidade de controle em microinstrucoes. A micromaquina apresenta uma memoria
   especial denominada de memoria de controle (tabela de controle), onde sao
   armazenados os sinais de controle. As microinstrucoes sao convertidas em sinais,
   atraves dessa tabela, que controlam diretamente o hardware. Embora essa camada
   possua o conceito de programa, geralmente nao a classificamos como software,
   uma vez que e transparente ao programador. Discutiremos sucintamente na Secao
   3.4 algumas abordagens paralelas utilizadas nessa camada.
   A terceira camada e composta pelo nivel convencional, tambem conhecida
   por linguagem de maquina. No nivel convencional e realizada a primeira interface
   entre o software e o hardware. Esta camada e constituida pelo conjunto de
   instrucoes do processador, registradores, dispositivos funcionais (ALUs,
   deslocadores, etc.), do espaco de enderecamento e de outros recursos de
   hardware "visiveis" ao programador. Atraves da interpretacao das instrucoes e sua
   execucao (microprogramacao), e realizado o processamento da memoria,
   interrupcoes e os processos de entrada e saida para perifericos. Apresentaremos o
   paralelismo a nivel convencional na Secao 3.5.
   As camadas seguintes: sistema operacional, linguagem assembly e
   linguagens de alto nivel constituem as camadas de software "puro". Iremos tratar
   desses assuntos nas Secoes 3.6 e 3.7.
   Finalizaremos a discussao do modelo de camadas com as bibliotecas de
   troca de mensagens, assunto da Secao 3.8 onde apresentaremos algumas das
   principais ferramentas disponiveis atualmente e tambem introduziremos a
   54
   A COMPUTACAO PARALELA - SOFTWARE
   ferramenta CVMP, no decorrer desta tese.
   3.4 - PARALELISMO DE MICRO-MAQUINA
   Compete a micromaquina controlar os recursos do hardware atraves dos
   sinais que sao enviados aos pontos de controle. Para isso, a micromaquina
   interpreta cada instrucao executada pelo nivel convencional e as transforma em
   microinstrucoes. A micromaquina apresenta uma memoria especial denominada de
   memoria de controle, onde sao armazenados os sinais de controle, para isso, as
   microinstrucoes sao organizadas em campos de um ou mais bits, chamados de
   microordens, onde cada uma destas especifica o sinal a ser produzido a fim de
   executar o hardware.
   Mesmo apresentando o conceito de programa, nao podemos caracterizar a
   micromaquina como uma camada de software, pois sua programacao nao pode ser
   alterada (hardware) e ela e completamente transparente ao usuario. Deste modo, a
   programacao da micromaquina e realizada pelo fabricante do hardware. Como
   estamos tratando de paralelismo de software, nesta secao nao entraremos em
   detalhes sobre a implementacao paralelas da microprogramacao.
   1
   2
   Micro-ordens
   1 A:=5
   3
   2 B:=12
   3 C:=A*B
   4 A:=1
   4
PA 5
   5 C:=2
   6 D:=13+C
   6
   (a) trecho de micro-ordens
   (b) Grafo de dependencia de dados
   Fig. - 3.2 - Grafo de Dependencia de Dados.
   As maquinas com microinstrucoes verticais [Hwang et al., 1984] [Amorin et
   al.,1988] sao capazes de executar diversas microinstrucoes simultaneamente. A
   55
   CAPITULO 3
   heuristica da exploracao de seu paralelismo consiste basicamente na verificacao da
   dependencia de dados. Desta forma, seu algoritmo devera percorrer as
   microinstrucoes e verificar quais poderao ser executadas em paralelo, gerando um
   grafo de execucao. A Figura 3.2 apresenta um exemplo mostrando um grupo de
   microinstrucoes e seu respectivo grafo. Observa-se que, devido a dependencia de
   dados, a microinstrucao 3 foi executada sequencialmente.
   3.5 - PARALELISMO NO NIVEL CONVENCIONAL
   A camada de nivel convencional tambem conhecida por linguagem de
   maquina (embora essa denominacao seja incorreta [Tanenbaum, 1990]) e a
   camada onde se realiza a primeira interface entre o software e o hardware. Ela e
   caracterizada pelo conjunto de instrucoes do processador, registradores,
   dispositivos funcionais (ALUs, deslocadores, etc.), do espaco de enderecamento e
   de outros recursos de hardware "visiveis" ao programador.
   Embora possamos discutir o paralelismo no nivel convencional sob o ponto
   de vista dos registradores, dispositivos funcionais, espaco de enderecamento e etc.,
   vamos enfocar a discussao no conjunto de instrucoes que compoe a linguagem de
   maquina.
   A exploracao do paralelismo das camadas inferiores ao nivel convencional
   ocorre completamente transparente ao programador. Um bom exemplo disso sao
   as maquinas com pipeline de instrucao. Do ponto de vista do programador, as
   instrucoes de linguagem de maquina sao executadas sequencialmente, porem a
   unidade de controle realiza o paralelismo do hardware atraves do pipeline, fazendo
   com que diversas instrucoes possam estar sendo executadas simultaneamente,
   independentemente do conhecimento ou controle do programador.
   Existe ainda um determinado tipo de maquina onde essa forma de
   paralelismo nao e transparente ao programador do nivel convencional. E o caso
   das maquinas com multiplas unidade funcionais (como por exemplo as maquinas
   escalares CDC 6600, CDC 7600 e IBM 360 [Hwang et al., 1984]). Nesse caso, o
   paralelismo de hardware somente pode ser explorado quando nao ocorre
   dependencia de dados entre as instrucoes (ver Figura 3.2), ficando sob a
   responsabilidade do programador (ou mesmo do compilador) a tarefa de gerar o
   codigo de linguagem de maquina otimizado.
   A principal estrategia de paralelismo dentro do nivel convencional e
   56
   A COMPUTACAO PARALELA - SOFTWARE
   encontrada nas arquiteturas VLIW (do ingles "Very Long Instruction Word") [Amorin
   et al.,1988]. Esse tipo de maquina possui instrucoes com palavras muito longas, e
   exploram o paralelismo de hardware atraves da replicacao dos recursos da UCP
   (unidade central de processamento).
PA As arquiteturas VLIW sao constituidas de uma unica unidade central de
   processamento e foram projetadas para executar as instrucoes sequencialmente,
   do mesmo modo como ocorre na tradicional maquina de von Neumann. O
   paralelismo nessas maquinas, porem, esta contido dentro de cada instrucao, que
   contem informacao suficiente para explorar todo o potencial paralelo de suas
   unidades funcionais replicadas. Devido a sua complexidade, as instrucoes possuem
   a capacidade de especificar as unidades funcionais que irao executar seus
   respectivos operandos.
   3.6 - PARALELISMO A NIVEL DE SISTEMA
   OPERACIONAL
   O sistema operacional e a primeira das camadas que compoem um
   computador, sendo constituido inteiramente por software. E responsavel pela
   interface entre os aplicativos (programas) e o computador. Compete ao sistema
   operacional controlar e supervisionar os dispositivos de entrada e saida de dados,
   organizar e gerenciar a memoria, interpretar parcialmente os programas ao serem
   executados, etc. [Tanenbaum, 1992].
   Em sistemas operacionais o processo e um importante conceito de
   exploracao do paralelismo, sendo constituido por todas as partes necessarias de
   um programa em execucao, ou seja: codigo objeto, o valor das variaveis do
   programa ("stream") e conteudo dos registradores e indicadores. Atraves dele, o
   sistema operacional e capaz de isolar os programas em execucao. Atraves deste
   principio, o sistema operacional e capaz de executar diversas atividades em
   concorrencia, ainda que utilizando um unico processador, tecnica que recebe a
   denominacao multitarefa ("multitasking"). O conceito de processo exige um
   sofisticado gerenciamento de memoria, interrupcoes e de controle total sobre a
   camada convencional.
   57
   CAPITULO 3
   Processo 1
   Processo 2
   Kernel
   Processo 3
   Processo n
   Fig. - 3.3 - Escalonamento de tarefas.
   Multitarefa e um mecanismo do sistema operacional, que, utilizando o
   conceito de processo, alterna os processos (ou tarefas), permitindo a execucao de
   programas simultaneamente (em concorrencia). A Figura 3.3 ilustra o
   escalonamento das tarefas. Neste exemplo, "n" processos estao sendo executados
   de forma alternada no tempo, sob supervisao do kernel (camada do sistema
   operacional responsavel pelo controle da multitarefa). Assim, o kernel habilita a
   execucao do processo A por um breve periodo de tempo, a seguir interrompe a
   execucao e comeca a executar o proximo processo. Ao final da lista de processos,
   o kernel volta a executar o primeiro processo e assim sucessivamente ate que
   todos sejam terminados. Esse procedimento gera a ilusao ao usuario de que
   diversos programas estao sendo executados ao mesmo tempo.
   Essa tecnica auxilia a programacao concorrente, uma vez que permite ao
   programador executar seus programas em concorrencia. Mesmo sendo esse
   contexto adotado em computadores sequenciais, sua nocao de paralelismo permite
   ao programador desenvolver sistemas que emulem paralelismo. Do ponto de vista
   da utilizacao, a multitarefa somente faz sentido efetivo quando e empregada em
PA sistemas operacionais com interface grafica com o usuario (GUI).
   Durante toda a decada de 70, uma serie de pesquisas em ciencia da
   computacao viria a mudar o conceito de sistema operacional, atraves do paradigma
   das interfaces graficas com o usuario - GUI (do ingles "graphical user interface")
   [Bruno, 1995]. Podemos atribuir quase que inteiramente ao Xerox PARC (Palo Alto
   Research Center) todo o desenvolvimento do conceito de GUI. A camada GUI nao
   e apenas uma simples contribuicao ao metodo de realizar a interface entre o
   computador e o usuario, mas sim um novo conceito inserido ao sistema operacional
   [Bruno, 1995], que contribuiu com o desenvolvimento da ciencia da computacao.
   58
   A COMPUTACAO PARALELA - SOFTWARE
   Entre os beneficios acrescidos pelo conceito podemos citar: a programacao
   orientada a objetos [Cox, 1986] e a programacao orientada a eventos [Bruno, 1995].
   A Figura 3.4 apresenta como exemplo um diagrama das camadas entre as
   aplicacoes e o sistema operacional UNIX com e sem GUI. Com a popularizacao e
   proliferacao do conceito GUI, atualmente a maioria dos sistemas operacionais
   disponiveis possuem essa camada embutida.
   Aplicativos
   user shell (sh, ch, ksh)
   UNIX sem GUI
   UNIX
   Desktop
   Aplicativos
   API/toolkit
   Looking Glass, IXI
   GUI
   Motif, Open Look
   UNIX com GUI
   Sistema de Janelas
   X Window System
   Sistema Operacional
   UNIX
   Fig. - 3.4 - Comparacao entre o sistema operacional UNIX com e sem a
   camada GUI.
   Alem da multitarefa, que possibilita a concorrencia de processos, os
   sistemas operacionais genericos atuais (UNIX, Windows NT/9X, Mac OS e etc.)
   apresentam tambem um outro conceito muito util para o desenvolvimento de
   programas concorrentes, denominado Thread. O conceito de Thread e bastante
   parecido com a multitarefa. Porem agora, ao inves de processos, temos parte de
   programas (podendo ser de um mesmo programa ou nao) sendo executados em
   concorrencia.
   Um outro conceito muito importante para a computacao paralela e a adocao
   do sistema de arquivo para redes de computadores [Tanenbaum, 1992]. Essa nova
   camada permite que o sistema de arquivos do sistema operacional seja expandido
   aos dispositivos de armazenamento conectados pela rede. Somente a partir dessa
   camada foi possivel a implementacao de sistemas operacionais distribuidos.
   As estrategias ate aqui comentadas, embora relacionadas ao paralelismo,
   sao diretamente associadas aos computadores sequenciais. Discutiremos a seguir
   59
   CAPITULO 3
PA de forma abreviada, os sistemas operacionais desenvolvidos especificamente para
   computacao paralela.
   O objetivo principal dos sistemas operacionais consiste na interface entre o
   usuario (programador) e a aplicacao (computador). Deste modo, o sistema
   operacional cria uma camada de software que simplifica toda a complexidade do
   hardware da maquina, possibilitando sua operacao e disponibilizando a base para o
   desenvolvimento e execucao das aplicacoes (programas). Seguindo esse principio,
   o sistema operacional funciona como uma maquina virtual [Tanenbaum, 1992],
   simples de utilizar, compreender e programar, tornando todo o complexo conjunto
   de dispositivos que constituem o computador (memoria, relogios, terminais,
   controladores de discos rigidos, controladores de discos flexiveis, interfaces de
   rede, dispositivos de entrada e saida, processador, etc.) transparentes ao usuario.
   Sendo o sistema operacional definido como uma maquina virtual, conforme
   comentamos anteriormente, torna-se bastante natural a transposicao desse
   conceito para as maquinas paralelas. Deste modo, os sistemas operacionais
   paralelos procuram tornar as caracteristicas paralelas igualmente transparentes.
   Assim, foram desenvolvidos os sistemas operacionais distribuidos [Tanenbaum,
   1995].
   Segundo Tanenbaum [Tanenbaum, 1995], um sistema operacional
   distribuido consiste de uma camada de software capaz de fazer com que uma
   colecao de computadores independentes aparentem para o usuario como um unico
   computador. Entretanto, essa definicao e apenas teorica. Embora existam diversos
   sistemas operacionais distribuidos, o atual estado da arte da ciencia da
   computacao ainda nao permite a implementacao efetiva desse conceito. Mais uma
   vez, o software e a grande barreira do paralelismo. Nao sabemos como projetar,
   implementar ou usar software distribuido de modo a desenvolver um sistema
   operacional que com eficacia distribua uma aplicacao em diversas unidades de
   processamento.
   O atual estado da arte em sistemas operacionais distribuidos ainda nao
   permite paralelizar automaticamente os programas e aplicacoes, o que seria de se
   esperar de um sistema operacional distribuido ideal. No entanto, esses sistemas
   sao capazes de deixar transparente e automatica a exploracao dos recursos
   paralelos, atraves da distribuicao de processos e threads pelos processadores
   espalhados na rede. O usuario, ao utilizar um sistema operacional distribuido (ex:
   Amoeba [Tanenbaum, 1995]), tem a ideia de estar utilizando um sistema
   60
   A COMPUTACAO PARALELA - SOFTWARE
   operacional multitarefa convencional ao inves de um conjunto de maquinas
   integradas pelo sistema operacional distribuido. Deste modo, quando o usuario
   executa diversas aplicacoes, o sistema operacional distribui estas para maquinas
   distintas, de modo transparente ao usuario, que tem a impressao de estar utilizando
   um sistema operacional convencional multitarefa com alta performance
   computacional.
   Basicamente existem tres possibilidades de implementar um sistema
   operacional distribuido:
   Desenvolvimento completo - Consiste em desenvolver um sistema operacional
   distribuido especifico, partindo do ponto zero, ou seja sem utilizar nenhum outro
   sistema operacional existente como base de desenvolvimento.
   Modificando um sistema operacional convencional - Resume em utilizar as
   bases de um sistema operacional convencional (normalmente UNIX),
PA alterando-o e incrementando-o ate transforma-lo em um novo sistema
   operacional com caracteristicas de sistema operacional distribuido.
   Utilizando um sistema operacional convencional - Consiste no desenvolvimento
   de uma camada de software adicional sobre um sistema operacional ja
   existente, ficando entre o usuario / aplicacoes e o sistema operacional, de modo
   que a partir dessa nova camada o conjunto todo se comporte como um novo
   sistema operacional distribuido.
   E importante comentar que, embora o conceito de sistemas operacionais
   distribuidos seja bastante interessante, e que existam mesmo algumas
   implementacoes, esse tipo de abordagem nao se popularizou. A grande maioria das
   implementacoes desses sistemas sao de carater academico e os exemplos que se
   tornaram comerciais sao bastante raros; entre eles podemos citar o Chorus,
   sistema operacional distribuido desenvolvido a partir do UNIX, no INRIA (Instituto
   Frances de Pesquisas) e posteriormente comercializado pela Chorus Sistemes
   [Tanenbaum, 1995].
   A Figura 3.5 apresenta um arranjo da arquitetura do sistema operacional
   distribuido AMOEBA [Mullender et al., 1990] [Tanenbaum, 1995]. Seguindo a
   estrategia de desenvolvimento completo, o Amoeba foi desenvolvido totalmente
   sem utilizar nenhuma base (sistema operacional) previamente implementada.
   Originado na Vrije Universiteit, Amsterda, sua primeira versao ficou operante em
   61
   CAPITULO 3
   1984. O sistema possui dois objetivos basicos: constituir um sistema operacional
   distribuido totalmente transparente ao usuario e fornecer as bases para
   desenvolvimento de programacao paralela e distribuida.
   Quanto ao primeiro objetivo, o Amoeba tem o proposito de fazer com que as
   caracteristicas paralelas sejam transparentes ao usuario. Um interessante conceito
   do sistema esta na opcao de nao existir maquina-mae para processos ou usuarios.
   Deste modo, quando um usuario entra no sistema, esta entrando no sistema como
   um todo e nao em uma determinada maquina que compoe o sistema. Assim,
   quando e apresentado a interface (shel ) para o usuario entrar no sistema, ela e
   executada em um processador arbitrario.
   O outro objetivo, e fazer com que o Amoeba forneca as bases para
   pesquisas em programacao paralela e distribuida. Se operado por um usuario sem
   intencoes de desenvolver aplicacoes paralelas, devido a sua transparencia,
   aparenta ser um sistema operacional multitarefa (multitasking) executado em um
   supercomputador sequencial. Porem, o Amoeba tambem possui ferramentas,
   linguagens e aplicacoes especificas para a exploracao do paralelismo, como a
   linguagem Orca, voltada exclusivamente para o desenvolvimento de aplicacoes
   paralelas [Tanenbaum, 1995].
   Grupo de processadores
   Terminais X
   Servidor de Arquivos
   Servidor de impressao
   Fig. - 3.5 - Arquitetura do sistema operacional distribuido Amoeba.
   Conforme podemos observar atraves da Figura 3.5, o Amoeba e composto
   basicamente por tres partes: grupos de processadores, terminais X-Windows e
   servidores. Os grupos de processadores possuem um substancial numero de
   UCPs, as quais possuem sua propria memoria local e conexoes de rede. O sistema
   62
PA A COMPUTACAO PARALELA - SOFTWARE
   permite tambem processadores utilizando memoria compartilhada. Neste caso, a
   troca de mensagens e otimizada atraves da comunicacao memoria para memoria
   ao inves de trocar mensagens pela rede. As UCPs de um grupo podem pertencer a
   diferentes arquiteturas, como por exemplo uma mistura entre 680x0, familia Intel,
   ou maquinas SPARC. As maquinas pertencentes ao grupo de processadores
   podem ser maquinas completas (com teclado, mouse e monitor) ou simplesmente a
   placa de processamento com a conexao de rede e memoria. As maquinas
   completas no entanto possuem o inconveniente de serem sub-utilizadas, uma vez
   que nao podem ser utilizadas como terminais.
   A outra parte que compoe o sistema Amoeba sao os terminais X-Windows.
   Alem destes, podem ser utilizados computadores pessoais ou estacoes de trabalho
   como terminais, que no entanto serao sub-utilizados, uma vez que nao poderao
   participar do processamento. A terceira parte do sistema consiste dos servidores,
   maquinas que executam tarefas especificas (Ex: servidores de arquivos e de
   impressao).
   Aplicacoes Distribuidas
   Servico de Arquivos
   Servico de seguranca
   Servico de tempo
   Servico de diretorio
   DCE -Chamadas a procedimentos remotos e autentificacoes
   Threads DCE
   Sistema Operacional Convencional
   Hardware
   Fig. - 3.6 - Camadas do sistema DCE.
   Como exemplo da terceira abordagem de implementacao de sistemas
   operacionais distribuidos, podemos citar o DCE (do ingles Distributed Computing
   Environment) [Rosenberry et al., 1992]. Utilizando maquinas com sistemas
   operacionais convencionais e adicionando uma aplicacao, que funciona como uma
   camada de software adicional, o DCE, transforma um conjunto de maquinas em
   sistema operacional distribuido. A Figura 3.6 apresenta o modelo de camadas do
   DCE. Inicialmente desenvolvido para rodar em plataforma UNIX, o DCE foi portado
   para as plataformas VMS, Windows e OS/2. Uma outra caracteristica que chama a
   atencao e seu carater comercial, que constitui a base de seu projeto desde a
   origem.
   63
   CAPITULO 3
   3.7 - PARALELISMO A NIVEL DE LINGUAGENS DE
   PROGRAMACAO
   Antes de discutirmos sobre o paralelismo a nivel de linguagens de
   programacao, e interessante definirmos o que vem a ser uma linguagem de
   programacao. A linguagem de programacao de alto nivel consiste em um metodo
   desenvolvido pela ciencia da computacao para transformar o modo de programar
   deixando-o mais abstrato e menos dependente da maquina. Atraves de um
   compilador ou interpretador, os programas escritos em linguagens de alto nivel sao
   convertidos em linguagem de maquina, e deste modo, transformam-se em novas
   aplicacoes (ver Figura 3.1).
   O conceito de linguagem de programacao de alto nivel auxiliou o
   desenvolvimento da ciencia da computacao em dois niveis: simplicidade no
PA desenvolvimento de programas e portabilidade. A simplicidade de desenvolvimento
   de programas e uma das questoes mais importantes da computacao. A informatica
   somente conseguiu atingir seu estado de popularizacao atraves da crescente
   variedade de aplicacoes. Se os programas fossem desenvolvidos em linguagem de
   maquina, a complexidade e o tempo de trabalho fariam com que o software tivesse
   um custo tao elevado que impossibilitaria a generalizacao do uso do computador. A
   portabilidade e uma questao extremamente importante na historia da computacao
   [Bruno, 1995]. Com o conceito de linguagem de programacao de alto nivel, os
   programas puderam ser portateis. Deste modo, os programadores podem
   desenvolver um programa e transpo-lo para qualquer maquina, sem se preocupar
   com o conjunto de instrucoes ou com a sua linguagem de maquina ou assembly,
   bastando que a nova maquina (com arquitetura diferente) possua um compilador
   para a linguagem em que foi escrito o programa. Em [Bruno, 1995] sao encontrados
   detalhes sobre a historia da computacao sob os aspectos da portabilidade.
   3.7.1 - LINGUAGENS DE PROGRAMACAO DE ALTO
   NIVEL
   Sendo o objetivo das linguagens de alto nivel a abstracao tecnica e a
   representacao dos problemas de modo mais facilitado para os programadores,
   como seria de se esperar, a linguagem de alto nivel e desenvolvida com base na
   64
   A COMPUTACAO PARALELA - SOFTWARE
   classe de problemas que procura atender. Verificando o universo das linguagens de
   programacao de alto nivel, podemos constatar seu carater de orientacao ao
   problema. A seguir vamos apresentar algumas das linguagens mais populares de
   programacao com suas respectivas especificacoes. Apresentamos tambem na
   Figura 3.7 um diagrama da genealogia de algumas dessas linguagens.
   Fortran - ( FORmula TRANslation) Projetada para aplicacoes tecnicas e
   cientificas, mais especificamente para calculos matematicos, pode ser considerada
   como origem de todas as linguagens de programacao de alto nivel. Embora nao
   possua muita abstracao e seja mais voltada para simplificar o trabalho de
   compilacao do que o de programacao, o Fortran e uma das linguagens que mais
   evoluiu, possuindo novas versoes a cada decada. E amplamente utilizado ate os
   dias de hoje, principalmente em super computacao. Existem muitas ferramentas e
   extensoes para exploracao de paralelismo em Fortran.
   Algol - (ALGOrithmic Language) O Algol foi a primeira linguagem de alto
   nivel realmente preocupada com a abstracao (mais voltada ao programador que a
   estrutura da maquina). Designado para uso geral, introduziu, entre outros, os
   conceitos de estrutura de blocos, procedimentos e variaveis locais (declaradas
   dentro dos procedimentos). O Algol influenciou teoricamente a grande maioria das
   linguagens.
   COBOL - (COmercial Business Oriented Language). Primeira linguagem de
   computadores designada especificamente para uso comercial, o Cobol e ainda hoje
   uma das linguagens mais utilizadas em todo o mundo. A principal atividade de suas
   aplicacoes e a manipulacao de arquivos.
   Lisp - (LISt Processing language). Foi a primeira linguagem declarativa.
   Projetada para problemas em inteligencia artificial, assim como em outras areas
   com estruturas de dados irregulares que sao melhor representadas atraves de
   listas, introduziu o conceito de recursividade que nao era permitido pelo Fortran.
   Atualmente, existem algumas extensoes e implementacoes do Lisp para a
   exploracao de paralelismo.
PA BASIC - (Beginner's Al -purpose Symbolic Instruction Code). Linguagem de
   uso geral, utilizada por iniciantes em linguagens de programacao. Popularizou-se a
   partir de meados da decada de 70, por se tornar padrao como linguagem de alto
   nivel para os primeiros microcomputadores. Atualmente o Visual Basic constitui
   uma evolucao da linguagem BASIC, adicionando caracteristicas de programacao
   65
   CAPITULO 3
   visual ao BASIC, tornando-se a linguagem que mais desenvolveu aplicativos para a
   plataforma Windows.
   Pascal - Possui essa denominacao em homenagem ao matematico e
   filosofo Blaise Pascal. Caracterizado como um estagio evolutivo da linguagem
   Algol, foi inicialmente projetado para o ensino de linguagens de programacao em
   nivel superior. Devido a sua modularidade e estruturacao, assim como sua
   simplicidade, popularizou-se o Pascal, que se tornou uma das principais linguagens
   dos computadores de terceira geracao. Tendo sido projetado para uso geral, muitos
   compiladores e sistemas operacionais forma escritos em Pascal. Atualmente o
   Pascal possui diversas extensoes paralelas. A atual ferramenta de desenvolvimento
   Delphi [Calvert, 1999], estimulou a utilizacao do Pascal, adicionando caracteristicas
   de orientacao a objetos [Cox, 1986] e visuais.
   C - E uma linguagem de alto nivel de uso geral, cuja principal caracteristica
   e a habilidade de acessar o hardware, comportando-se como linguagem de baixo
   nivel. Embora possua tais caracteristicas, os programas escritos em C possuem
   alta portabilidade podendo ser recompilados em diversas plataformas. Essas
   condicoes fazem com que a linguagem C seja voltada ao desenvolvimento de
   sistemas operacionais (UNIX e escrito em C). Com a popularidade do UNIX em
   sistemas paralelos, consequentemente a linguagem C ganhou diversas extensoes
   paralelas.
   Smalltalk - O Smal talk e uma linguagem de programacao visual, que
   inspirou tanto a programacao visual quanto o emprego da tecnologia de orientacao
   a objetos. Desenvolvida para suportar os paradigmas dos projetos PARC [Bruno,
   1995], motivou diversas outras linguagens por seus conceitos inovadores.
   Modula 2 - A linguagem Modula 2, tambem foi inspirada pelas novas
   concepcoes do projeto PARC da Xerox [Bruno, 1995]. baseada em Pascal, foi
   designada para ser a linguagem de alto nivel base para as novas estacoes de
   trabalho.
   C++ - Devido a popularizacao do conceito de programacao orientada a
   objetos, foi desenvolvido o C++, que e uma extensao da linguagem C. O C++
   acrescenta o conceito de orientacao a objetos ao C. As caracteristicas OO
   (orientacao a objetos) trouxeram a estrutura de classes ao C++ e todas as suas
   vantagens de reutilizacao de codigo e facilidades para projetos extensos.
   Prolog - ( PROgramming LOGic). O Prolog e uma linguagem de alto nivel
   de abstracao. Projetado para ser utilizado em inteligencia artificial e sistemas
   66
   A COMPUTACAO PARALELA - SOFTWARE
   inteligentes, e uma linguagem declarativa, baseada em predicados logicos.
   Ada - Denominacao para homenagear a primeira programadora de
   computadores Augusta Ada Lovelace, aluna de Charles Babbage [Spufford &
   Uglow, 1997]. A linguagem de programacao ADA e uma linguagem de alto nivel,
   muito parecida com o Pascal, foi encomendada pelo departamento de defesa
   americano e desenvolvida para computacao numerica, programacao de sistemas,
PA aplicacoes em tempo real e programacao concorrente. ADA e uma linguagem
   robusta com bibliotecas nativas para diferentes especificacoes, incluindo a
   exploracao de paralelismo.
   JAVA - Criada pela Sun Microsystens, a linguagem Java foi criada para
   atender as necessidades da Internet, possuindo carateristicas que facilitam a
   utilizacao de suas aplicacoes em diversas plataformas de computacao diferentes
   assim como sua integracao com as metodologias de navegacao da Internet. E uma
   linguagem de uso geral com estruturas muito parecidas ao C++.
   Linguagens Visuais - O conceito de linguagem visual foi introduzido
   primeiramente pelo Smalltalk. Na plataforma Windows, esse conceito foi introduzido
   pela linguagem Visual Basic, que consiste num ambiente de programacao que,
   atraves de ferramentas CASE [Bruno, 1995], e capaz de gerar codigo atraves de
   interacao visual entre o programador e o sistema, facilitando o desenvolvimento e
   diminuindo o tempo de programacao. O Visual Basic popularizou-se rapidamente,
   tornando-se a linguagem mais utilizada e que possui o maior numero de aplicacoes
   para plataforma Windows. Atualmente, existe uma forte tendencia na utilizacao do
   conceito de linguagem visual, gerando inumeras extensoes visuais das linguagens
   tradicionais, como por exemplo: Delphi (Pascal), C++Builder e Visual C++ (C++),
   Jbuilder e Visual J++ (Java), Visual Fortran (Fortran) e etc.
   67
   CAPITULO 3
   1955
   1965
   1975
   1985
   1995
   COBOL
   Java
   PROLOG
   FORTRAN
   PL/1
   SMALLTALK
   HTML
   Java Visual
   Eiffel
   SIMULA
   C++
   C++ Builder
   ALGOL
   C
   MODULA 2
   Oberon
   Visual C++
   PASCAL
   Delphi
   ADA
   SMALLTALK
   LISP
   BASIC
   Visual Basic
PA Fig. - 3.7 - Genealogia das Linguagens de Programacao.
   Podemos dividir as linguagens de programacao em duas classes principais:
   DECLARATIVAS e IMPERATIVAS [Hudak, 1989] [Gregory, 1987]. A semantica
   para programas imperativos consiste em uma serie de comandos obedecidos de
   forma sequencial, que embora possuam abstracao, ainda sao baseados na
   estrutura dos computadores. Alguns exemplos sao o BASIC, o Pascal, Algol,
   COBOL, C, C++, ADA, Fortran, etc. As linguagens imperativas possuem natureza
   inerente ao modelo de computacao de von Neumann e uma historia de evolucao e
   desenvolvimento de 40 anos. Nao e de estranhar que essa classe seja a mais
   difundida e utilizada pela grande maioria dos programadores de todos os niveis. O
   advento da computacao paralela trouxe uma serie de extensoes paralelas para as
   linguagens imperativas, a fim de que estas pudessem explorar o paralelismo, e
   compiladores paralelos, que tentam extrair o paralelismo das linguagens
   imperativas sequenciais.
   As linguagens declarativas constituem-se de uma serie de funcoes ou
   predicados logicos. Como exemplos podemos citar o Prolog, o Lisp, Sisal e etc.
   Embora considerada por alguns autores [Hockney & Jesshope, 1988] como menos
   eficiente que o estilo imperativo de programacao, por nao ser fundada na estrutura
   von Neumann, e tambem considerada de natureza mais paralela, e
   consequentemente apresenta solucoes paralelas mais naturais [Almasi & Gottlieb,
   1994]. Uma outra caracteristica que deve ser atribuida as linguagens declarativas e
   o seu rigoroso formalismo matematico, que pode auxiliar na tematica da
   complexidade dos programas atuais.
   A discussao sobre as vantagens e desvantagens das duas classes ou
   estilos de linguagem de programacao atinge patamares filosoficos, e nao podemos
   68
   A COMPUTACAO PARALELA - SOFTWARE
   com certeza designar uma ou outra como a melhor solucao para programas
   complexos ou nao, lineares ou paralelos. Embora as linguagens declarativas
   clamem sua superioridade pelo seu formalismo, elas encontram uma barreira
   constituida por 40 anos de evolucao.
   3.7.2 - ALTERNATIVAS DE PARALELISMO
   Discutiremos a seguir algumas abordagens para explorar o paralelismo
   atraves das linguagens de programacao (ver Figura 3.1).
   Quando um programador tenciona desenvolver um aplicativo paralelo, ele
   possui quatro possibilidades basicas: paralelismo automatico, extensoes paralelas
   para linguagens imperativas, bibliotecas de paralelismo e linguagens nao
   imperativas paralelas.
   O paralelismo automatico consiste no desenvolvimento de compiladores
   capazes de analisar o codigo sequencial de um programa e paraleliza-lo. Esse tipo
   de compilador e tipicamente voltado aos programas escritos em Fortran [Almasi &
   Gottlieb, 1994]. Embora essa abordagem seja a mais comoda para o usuario, que
   nao precisa alterar seu codigo fonte, aprender ferramentas e extensoes de
   linguagens ou ainda aprender linguagens diferentes ou tecnicas e estrategias de
   desenvolvimento de programas paralelos, a performance obtida pelos
   compiladores, na maioria dos casos, nao e satisfatoria. A semantica de
   paralelizacao demonstra nao ser trivial, uma vez que a natureza dos algoritmos
   para a exploracao de paralelismo possui logica, estrutura e estrategias muito
   complexas e depende das condicoes de paralelismo das camadas inferiores.
   Assim, encontrar um compilador capaz de transformar um programa sequencial em
PA paralelo com eficiencia e um desafio que se algum dia for atingido, exigira a
   dedicacao de muitas mentes brilhantes. Sem duvida, essa linha de pesquisa e a
   mais cobicada pelos pesquisadores e pela sociedade da computacao paralela como
   um todo, vindo a ser a pedra filosofal do paralelismo.
   Uma outra estrategia utilizada para o desenvolvimento de programas
   paralelos consiste na utilizacao de extensoes paralelas em linguagens imperativas
   convencionais. Embora essa abordagem requeira maior esforco do programador,
   que devera aprender sobre computacao paralela e sobre o funcionamento das
   ferramentas adicionais, por outro lado nao sera necessario aprender outra
   linguagem, podendo reutilizar muitas de suas bibliotecas e programas. Deste modo,
   69
   CAPITULO 3
   o programador pode utilizar a linguagem com a qual esta familiarizado e atraves do
   acrescimo de comandos e estruturas especificas para funcoes paralelas sera capaz
   de explorar o paralelismo. Ainda que esta estrategia seja muito criticada, por manter
   vinculos com a programacao von Neumann, e a mais utilizada atualmente. Atraves
   desse tipo de abordagem, pode-se conseguir excelentes performances,
   dependendo da estrategia de paralelismo adotada pelo programador, que devera
   conhecer muito bem a semantica de paralelismo, assim como a estrutura da
   plataforma paralela utilizada.
   Ainda uma alternativa e a utilizacao de bibliotecas de funcoes e
   procedimentos voltadas ao desenvolvimento paralelo. Neste caso, as bibliotecas
   sao utilizadas em linguagens de programacao sequencial permitindo o
   desenvolvimento de aplicacoes paralelas.
   A ultima opcao que apresentamos e a utilizacao de uma linguagem nao
   imperativa, com nenhum ou quase nenhum vestigio da estrutura von Neumann.
   Embora muitos acreditem ser essa a resposta mais prodiga, e tambem a mais
   custosa para o programador, que devera aprender uma nova linguagem, com uma
   heuristica diferente da qual ele esta familiarizado, e ainda reescrever todo o seu
   codigo para essa nova linguagem.
   Podemos considerar dois tipos de linguagens que nao apresentam vestigios
   da arquitetura von Neumann: as linguagens baseadas em predicados logicos como
   o Prolog e as linguagens funcionais como o Sisal e outras linguagens voltadas para
   arquiteturas DataFlow [Duncan, 1990]. Embora existam situacoes em que a
   performance do Sisal sobressai ao Fortran, na maioria das vezes a melhor
   performance obtida e atraves da utilizacao de extensoes paralelas em linguagens
   imperativas, entretanto esta e uma area com uma crescente forca de pesquisa
   [Almasi & Gottlieb, 1994].
   Existem linguagens desenvolvidas exclusivamente para a exploracao de
   paralelismo, mas que apresentam estruturas e comandos baseados em linguagens
   imperativas (Occam [Inmos, 1988]). Este tipo de linguagem e classificada como
   extensao de linguagens imperativas.
   70
   A COMPUTACAO PARALELA - SOFTWARE
   3.7.3 - MECANISMOS DE EXPLORACAO DE
   PARALELISMO
   Dentre as quatro estrategias de paralelismo que apresentamos na secao
   anterior, estaremos preocupados principalmente em apresentar tecnicas voltadas
   as extensoes paralelas das linguagens convencionais e as bibliotecas de
   paralelismo.
PA Antes de comecarmos a discutir as tecnicas basicas de paralelismo,
   devemos discutir a definicao de maquina paralela. Segundo a definicao de Almasi e
   Gottlieb [Almasi & Gottlieb, 1994], uma maquina paralela e um conjunto de
   elementos de processamento, capaz de comunicar e cooperar para resolver
   problemas mais rapidamente. Utilizando-se dessa definicao e observando o modelo
   de camadas do computador moderno apresentado na Figura 3.1, devemos nos
   lembrar da grande complexidade envolvida na exploracao do paralelismo. Abaixo
   da camada de linguagem de alto nivel existem diversas outras camadas que
   podem, cada uma ao seu modo, executar a exploracao do paralelismo. Desse
   modo, devemos concluir que nao existe uma regra ou modelo unico capaz de
   descrever as bases da exploracao de paralelismo. Para cada uma das possiveis
   combinacoes de exploracao de paralelismo, em cada uma das camadas, existem
   tecnicas e estrategias de programacao mais adequadas que outras. Desse modo, o
   conjunto das tecnicas de programacao e tao vasto quanto o conjunto das
   combinacoes de paralelismo das camadas inferiores a sua. Assim, estaremos
   limitando a discussao deste item as maquinas MIMD genericas. Devemos lembrar
   que o universo das maquinas MIMD e bastante abrangente, ocorrendo diversas
   situacoes (ex: maquinas MIMD formadas a partir de SIMD - Cray J-90 [Hockney &
   Jesshope, 1988]) em que as bases de exploracao de paralelismo sao um pouco
   adversas.
   Segundo Pratt [Pratt, 1984], em sua forma mais simples, um programa para
   computador von Neumann e composto por um conjunto de linhas contendo cada
   uma um unico comando, sendo executadas uma apos a outra. Existe, no entanto,
   uma serie de procedimentos que nos auxiliam a eliminar essa visao estritamente
   sequencial e construir programas mais interessantes. Esses conceitos estao
   presentes na grande maioria das linguagens atuais de programacao e sao
   conhecidas como estruturas de programacao. As estruturas de programacao
   permitem que as linhas de programacao sejam integradas em estruturas. Dentre
   71
   CAPITULO 3
   elas, podemos citar as estruturas de condicionamento (ex: if then else; case), as
   estruturas de repeticoes (ex: for; while; repeat), assim como o agrupamento de
   estruturas ou linhas em blocos ou sub-programas (ex: procedimentos e funcoes). A
   diferenca entre os comandos e as estruturas de programacao sao responsaveis
   pela caracterizacao das linguagens de programacao.
   Embora os conceitos de programacao estruturada e a aglomeracao de
   linhas em blocos e sub-rotinas sejam bastante conhecidos e importantes na
   computacao sequencial, sao eles tambem que constituem as bases para a
   elaboracao de programas paralelos. Sem tais conceitos, praticamente seria
   impossivel o desenvolvimento de aplicacoes paralelas, pois nao haveria como
   realizar a caracterizacao formal das tarefas a paralelizar.
   Os algoritmos correspondentes a um problema geralmente sao
   implementados atraves das estruturas de programacao de forma sequencial,
   testados e somente entao sao paralelizados. Isso ocorre devido a dificuldade de
   implementacao e depuracao de programas paralelos. Em termos gerais, as bases
   para a paralelizacao de um algoritmo sequencial obedecem as seguintes tarefas:
   Definir quais conjuntos de sub-tarefas podem ser executados em paralelo
   (dependencia de dados).
   Quando e como iniciar e finalizar sua execucao.
   Coordenar e especificar sua interacao enquanto estao executando.
PA A dependencia de dados ocorre quando um comando ou operacao depende
   do resultado de outro. Em geral, a sua a analise gera um grafo no estilo do
   apresentado pela Figura 3.2. Apos verificar a dependencia de dados, deve-se entao
   decidir quando e como iniciar e finalizar as tarefas paralelas. Existem algumas
   primitivas basicas comuns, tanto em bibliotecas de extensao paralelas como em
   linguagens de programacao paralelas. Sao elas: fork/join, parbegin/parend e doall.
   A Figura 3.8 apresenta um exemplo de comparacao entre a estrategia
   parbegin/parend e fork/join.
   Tanto o fork/join quanto o parbegin/parend, possuem o mesmo objetivo:
   controlar a execucao paralela. Na Figura 3.8 podemos observar a diferenca entre
   as duas abordagens. Se por um lado a alternativa parbegin/parend oferece um
   codigo mais elegante e simples, sua exploracao de paralelismo nao e tao flexivel
   quanto fork/join. Outra primitiva bastante comum, que apresenta uma estrategia um
   72
   A COMPUTACAO PARALELA - SOFTWARE
   pouco diferenciada, e a primitiva doall e similares ( foral , pardo, etc.), que sao
   voltadas as repeticoes com exploracao de paralelismo. Por serem principalmente
   empregadas no calculo de vetores e matrizes, sao comuns em linguagens
   cientificas como algumas extensoes paralelas do FORTRAN. Embora a abordagem
   doall seja bastante util e poderosa, existe um grande numero de problemas
   envolvendo operacoes com matrizes e vetores, nos quais ocorrem dependencia de
   dados, inviabilizando, deste modo, sua paralelizacao atraves desta abordagem.
   parbegin/parend
   fork/join
   A
   m=2
   A
   fork C
   parbegin
   B
   C
   n=3
   A
   A
   begin
   fork E
   B
   B
   B
   fork F
   D
   C
   D
   E
   F
   parbegin
   C
   D
   E
   F
PA join m,g; quit
   D
   g:G
   G
   E
   G
   join n,h; quit
   F
   h:H
   H
   parend
   H
   quit
   end
   c:C
   parend
   join m,g; quit
   H
   e:E
   join n,h; quit
   f:F
   join n,h; quit
   Fig. - 3.8 - Comparacao entre parbegin/parend e fork/join, duas alternativas
   diferentes para controlar a execucao paralela [Almasi & Gottlieb, 1994].
   Um conceito igualmente poderoso, que alem de ser utilizado em linguagens
   paralelas ou com extensoes paralelas pode ser utilizado em linguagens
   convencionais, com mecanismos de troca de mensagens (como no caso do CVMP
   apresentado nesse trabalho), e o conceito de sub-programas paralelos ou sub-
   rotinas paralelas. Nesse caso, um programa e capaz de ativar um ou mais sub-
   programas de modo a gerar execucao paralela ou concorrente. Em geral, esses
   mecanismos utilizam o conceito de processos e "threads" providos pelo sistema
   operacional, comentados na Secao 3.6. A Figura 3.9 apresenta uma arvore de
   execucao paralela, ilustrando este conceito. Nela podemos observar os processos
   representados por retangulos. O processo principal executa diversos outros sub-
   73
   CAPITULO 3
   processos. Este exemplo foi implementado utilizando a concepcao de chamada de
   processos da linguagem PL/1. PL/1 foi uma das primeiras linguagens que
   possibilitou a execucao de processos concorrentes, porem ela nao viabilizava
   nenhuma especie de controle, sincronismo ou coordenacao dos processos, o que
   inviabilizava o desenvolvimento de aplicacoes paralelas. Atualmente a linguagem
   PL/1 nao e mais utilizada, apresentando apenas interesse historico e didatico.
   Principal
   call A, task
   A
   call B, task
   call A1, task
   A1
   B
   call B1, task
PA call A11, task
   B1
   A11
   call A2, task
   call C, task
   A2
   C
   Fig. - 3.9 - Arvore de Execucao Paralela. Exemplo de disparos de processos
   realizados a partir da linguagem PL/1.
   A necessidade de sincronismo ou coordenacao dos processos paralelos
   surge devido a necessidade de uma melhor exploracao do paralelismo e
   principalmente pela dependencia de dados entre os processos. Alem da
   coordenacao dos processos, um outro fator muito importante na exploracao do
   paralelismo e a comunicacao entre processos, permitindo a estes trocar
   informacoes referentes a dependencia dos dados durante sua execucao.
   Existem diversas estrategias de coordenacao de processos e tarefas.
   Discutiremos sucintamente algumas estrategias utilizadas para a comunicacao e
   sincronismo em maquinas MIMD com memoria distribuida e MIMD com memoria
   compartilhada. Caso o leitor deseje entrar em detalhes, encontrara uma ampla
   abordagem em: [Almasi & Gottlieb, 1994] [Amorin et al.,1988] [Brawer, 1989]
   [Codenoti & Leoncini, 1994] [Foster, 1995] [Krishnamurthy, 1989] [Quinn, 1987].
   As tecnicas utilizadas para comunicacao sao, na grande maioria das vezes,
   74
   A COMPUTACAO PARALELA - SOFTWARE
   utilizadas para o sincronismo, variando de acordo com as camadas de hardware.
   Em maquinas de memoria compartilhada, o meio mais usual de comunicacao
   consiste nas variaveis compartilhadas. As variaveis compartilhadas sao variaveis de
   processos diferentes, declaradas no mesmo endereco de memoria, que permitem,
   aos diferentes processos ou tarefas (em diferentes processadores ou nao) trocar
   informacoes. Devido a sua arquitetura, os processadores das maquinas de
   memoria compartilhada podem ter acesso aos mesmos enderecos de memoria, e
   gracas a esta possibilidade e viabilizado o mecanismo de comunicacao via variavel
   compartilhada.
   As maquinas que possuem memoria distribuida, devido a sua arquitetura,
   nao permitem que diferentes processadores acessem o mesmo endereco de
   memoria, e portanto nao permitem variaveis compartilhadas. Entretanto, a
   comunicacao nas maquinas de memoria distribuida e realizada atraves de uma
   tecnica denominada de passagem de mensagens. A passagem de mensagens
   consiste na transferencia de informacoes atraves da rede (ou memoria, no casos de
   sua utilizacao em sistemas de memoria compartilhada) que faz a conexao entre os
   processadores (ou computadores). Os processos sao capazes de efetuar a
   comunicacao via passagem de mensagens na rede atraves das primitivas SEND e
   RECEIVE. E importante observar que algumas linguagens possuem suporte para
   uma unica abordagem (ex: Occam [Inmos, 1988b]) ou ainda para as duas
   abordagens, como e o caso da tecnica Rendezvous da linguagem Ada [Naiditch,
   1995].
   Atraves dos mecanismos de comunicacao sao realizados o sincronismo e a
   coordenacao dos processos paralelos. Em termos gerais, a coordenacao de
   processos e realizada atraves da sincronizacao. Segundo Andrews e Schneider
   [Andrews & Schneider, 1983], o sincronismo entre processos concorrentes pode ser
PA visto como um paradigma de acao e reacao. Em outras palavras, o sincronismo
   ocorre quando um processo envia uma mensagem (memoria distribuida) ou atribui
   determinado valor a uma variavel compartilhada (memoria compartilhada) e um
   outro processo executa uma determinada acao mediante a deteccao dessa ordem
   (alteracao do valor de uma variavel ou mensagem). Atraves dessa concepcao
   podemos conceber os mecanismos de sincronizacao de processos como um
   mecanismo de espera na execucao dos processos, que sao disparados mediante
   eventos.
   Existem uma serie de estrategias de sincronismo de processos, entre elas:
   75
   CAPITULO 3
   testa e continua, semaforos, barreiras, RPC, monitores e etc. Nao iremos aborda-
   las aqui, porem essas estrategias podem ser melhor estudas em [Almasi & Gottlieb,
   1994] [Amorin et al.,1988] [Brawer, 1989] [Codenoti & Leoncini, 1994] [Foster, 1995]
   [Krishnamurthy, 1989] [Quinn, 1987]. O principio basico dessas estrategias e a
   atualizacao e a verificacao de variaveis, que indicam a condicao ou ordem de outro
   ou outros processos, sendo possivel implementa-las utilizando tecnicas de
   passagem de mensagem ou memoria compartilhada.
   A Figura 3.10 apresenta um exemplo generico de aplicacao paralela que
   utiliza o conceito de processos paralelos coordenados. Neste exemplo temos uma
   maquina composta por tres processadores. Os processos sao representados pelas
   caixas cinzas, e a comunicacao e sincronismo entre os processos pelas setas. E
   importante observar a dependencia de dados entre os processos.
   Processador 1
   Processador 2
   Processador 3
   LER DADOS
   CALCULA
   B
   CALCULA
   C
   CALCULA
   A
   CALCULA
   CALCULA
   D = funcao(C)
   E = B * C
   CALCULA
   F = A + E + D
   IMPRIME F
   Fig. - 3.10 - Exemplo generico de uma aplicacao paralela com coordenacao de
   processos e dependencia de dados.
   3.8 - FERRAMENTAS DE PASSAGEM DE MENSAGEM
   EM SISTEMAS DISTRIBUIDOS
   Conforme comentamos na Secao 2.5.5, sistemas distribuidos sao conjuntos
   de computadores conectados por rede, que podem executar um trabalho
   cooperativo explorando o paralelismo. Para implementar uma aplicacao distribuida,
   76
   A COMPUTACAO PARALELA - SOFTWARE
   ou seja, uma aplicacao que aproveitara o recurso computacional do sistema
PA distribuido, e necessario utilizar ferramentas que realizem a comunicacao atraves
   da rede. Denominadas ferramentas de passagem de mensagem, sao de modo
   geral, extensoes ou bibliotecas, que permitem ao programador utilizar linguagens
   de programacao convencionais e efetuar a troca de mensagens entre as maquinas.
   Existem diversas ferramentas de troca de mensagens, dentre as quais podemos
   citar: P4, PVM, MPI, Express, e PARMACS [Geist et al., 1996] [Foster, 1995]
   [Pacheco, 1997] [Almasi & Gottlieb, 1994], alem do CVMP, introduzido nesta tese.
   Vamos discutir sucintamente as ferramentas mais populares: PVM e MPI. Depois
   faremos uma pequena introducao ao CVMP.
   3.8.1 - O PACOTE PVM
   O PVM, cujo nome provem do ingles "Paral el Virtual Machine", foi
   inicialmente desenvolvido em 1989 no Oak Ridge National Laboratory (ORNL).
   Trata-se de um pacote de software que permite utilizar uma colecao heterogenea
   de computadores conectados em rede como se fossem uma unica maquina
   paralela (sistema distribuido) [Geist et al., 1996]. Uma das principais propostas de
   sistema heterogeneo formulada pelo PVM e a integracao de maquinas sequenciais,
   paralelas e vetoriais formando uma unica enorme maquina de memoria distribuida.
   O pacote PVM e dividido em duas partes: um controlador de processos
   denominado de daemon (ou simplesmente pvmd) e uma biblioteca de rotinas. O
   pvmd e uma aplicacao que deve rodar em todas as maquinas, a fim de implementar
   a integracao destas. Funciona basicamente como um servidor de recursos
   residente em cada uma das maquinas, e e atraves dele que as rotinas PVM sao
   capazes de se comunicar. Deste modo, a principal funcao do modulo pvmd e
   implementar o conceito de maquina virtual paralela. A biblioteca de rotinas PVM
   consiste de um conjunto de primitivas para a comunicacao, coordenacao de
   processos e conversao de dados. Ela funciona como uma biblioteca de extensao
   para uma linguagem de programacao convencional, de modo que as chamadas
   para rotinas PVM sao usadas em conjunto com o codigo fonte original. A biblioteca
   PVM possui dezenas de funcoes, constituindo um complexo de comunicacao de
   processos.
   Embora o pacote PVM tenha sido originalmente desenvolvido para rodar em
   maquinas com sistema operacional UNIX, atualmente existem pacotes para o
   77
   CAPITULO 3
   sistema operacional Windows NT/9X, alem de encontrar-se em desenvolvimento
   uma versao baseada em Java [PVM]. Em relacao a sua biblioteca de rotinas, o
   PVM nao pode ser utilizado por qualquer linguagem de programacao, possuindo
   atualmente versoes para as linguagens C, C++ e Fortran.
   O modelo computacional do PVM e baseado na nocao de que uma
   aplicacao consiste em muitas tarefas e cada tarefa e responsavel por uma parte do
   trabalho computacional da aplicacao. O paralelismo ocorre na execucao em
   concorrencia dessas tarefas, atraves de diferentes processos sendo executados em
   diferentes maquinas num ambiente de troca de mensagens. Deste modo, o PVM foi
   projetado para promover um ambiente de troca de mensagens, onde diversos
   processos podem se comunicar (granularidade preferivelmente grande). Uma
   caracteristica das aplicacoes PVM e a sua preferencia pelo modelo SPMD (do
   ingles "Single Program Multiple Data"). Dentro dessa abordagem, em cada
   processador o mesmo programa e executado, porem processando dados
   diferentes.
   3.8.2 - A BIBLIOTECA MPI
PA O MPI [Pacheco, 1997] [Foster, 1995], cujo nome e derivado do ingles
   "Message Passing Interface", e o resultado de uma tentativa de implantar um
   padrao nas interfaces de passagem de mensagem. O MPI foi criado a partir de um
   consorcio envolvendo cerca de quarenta organizacoes da comunidade de
   processamento paralelo mundial (sendo a grande maioria dos Estados Unidos e da
   Europa), contando com representantes de diversas areas: industria, comercio e
   universidade. Em 1992 iniciou-se o desenvolvimento do MPI, surgindo sua primeira
   versao funcional em 1994. O MPI e similar ao PVM, trata-se de uma ferramenta
   voltada a comunicar maquinas heterogeneas em plataforma UNIX conectadas via
   rede, gerando um ambiente de troca de mensagens. A principal diferenciacao entre
   as duas ferramentas e que o MPI e composto apenas por uma biblioteca de rotinas,
   nao possuindo nenhum outro componente.
   A biblioteca MPI e um conjunto complexo de 129 funcoes, das quais muitas
   apresentam numerosos parametros e variantes, que caracterizam seu poder e sua
   complexidade. Do mesmo modo que o PVM, o MPI possui variantes para apenas
   tres linguagens de programacao, sendo elas a linguagem C, C++ e Fortran.
   No modelo de programacao MPI, a computacao compreende em um ou
   78
   A COMPUTACAO PARALELA - SOFTWARE
   mais processos que se comunicam atraves de chamadas a biblioteca de rotinas
   (MPI). Essas rotinas sao utilizadas para enviar e receber mensagens para outros
   processos. Na maioria da implementacoes MPI, um numero fixo de processos e
   criado no inicio do programa, onde cada processo pertence a um determinado
   processador ou maquina.
   Os sistemas MPI apresentam um numero fixo de processos. Existem
   diferentes abordagens para a comunicacao entre os processos, podendo haver
   comunicacao individual e coletiva. Na comunicacao individual, ou ponto a ponto, os
   processos enviam mensagens para outros determinados processos atraves da
   comunicacao individual. Na comunicacao coletiva, um unico processo ou um grupo
   de processos enviam mensagem para um grupo de processos. Alem dessas
   caracteristicas de comunicacao, uma interessante abordagem adotada pelo MPI e o
   conceito de modularidade. Esse conceito e bastante importante, principalmente sob
   o ponto de vista da engenharia de software. Um mecanismo denominado de
   comunicador permite que o programador MPI possa definir modulos que
   incorporem estruturas internas de comunicacao.
   3.8.3 - O PACOTE CVMP
   Nesta secao vamos fazer uma breve apresentacao do pacote CVMP, que
   sera abordado ao longo desta tese.
   O nome CVMP e derivado do ingles "Cybernetic Vision Message Passage",
   tratando-se de um pacote de exploracao de paralelismo similar ao MPI e ao PVM,
   onde sao fornecidas ferramentas de programacao para auxiliar o desenvolvimento
   de aplicacoes paralelas. O CVMP foi desenvolvido ao longo de nosso trabalho no
   Grupo de Pesquisa em Visao Cibernetica do IFSC/USP com o intuito de auxiliar no
   desenvolvimento dos projetos que necessitem da exploracao de paralelismo. No
   decorrer da pesquisa de nosso grupo, observou-se a necessidade de
   desenvolvimento de sistemas e aplicacoes paralelas, devido a grande demanda de
   poder computacional exigida pelos experimentos nas areas de Visao
   Computacional e Processamento de Imagens. Embora existam diversos pacotes de
   exploracao de paralelismo, nossa pesquisa constatou a necessidade da elaboracao
   de um pacote de simples utilizacao, adequado ao parque de computadores
PA pessoais e a plataforma Windows, e que fosse nativo a uma linguagem de
   programacao visual, para facilitar ao maximo a sua programacao, alem de conter
   79
   CAPITULO 3
   ferramentas especificas para a pesquisa em Visao Computacional e
   Processamento de Imagens.
   Procurando atender a essas premissas, as quais nao foram encontradas
   integralmente em nenhum pacote de exploracao de paralelismo atual, decidimos
   implementar o CVMP. Deste modo, o CVMP e um pacote de exploracao de
   paralelismo baseado em troca de mensagens, de simples utilizacao, capaz de
   efetivar a comunicacao, controle e sincronismo em: (i) ambientes distribuidos
   constituidos por computadores pessoais em plataforma Windows 95/NT conectados
   via rede e (i ) maquinas multiprocessadas. A proposta CVMP busca a simplicidade
   de desenvolvimento de aplicacoes paralelas, sendo os principais objetivos do
   projeto:
   Simples utilizacao - prover a possibilidade de implementacao paralela a
   programadores sem experiencia ou especialidade em computacao paralela
   e sistemas distribuidos, mas que necessitem desenvolver aplicacoes
   paralelas (caracteristica da maioria dos pesquisadores em visao e
   processamento de sinais);
   Ser nativo para a plataforma Windows NT/9X - Utilizada pela grande maioria
   dos usuarios;
   Operacionalidade em ambientes de programacao visual - Os ambientes de
   programacao visual (Delphi, Visual Basic e etc.) proporcionam ferramentas
   para facilitar o desenvolvimento de aplicacoes, facilitando o processo de
   programacao. Deste modo possuem a importante caracteristica de
   proporcionar uma boa ferramenta de programacao para todo o universo de
   programadores (inexperiente / experiente );
   Prover mecanismos para facilitar o desenvolvimento de algoritmos de Visao
   Computacional e processamento de sinais em paralelo.
   Com base nesses objetivos e nas necessidades dos projetos do grupo,
   desenvolvemos o pacote CVMP, atraves do qual, o usuario e capaz de implementar
   uma aplicacao paralela, realizar analise de performance e localizar gargalos.
   A comunicacao dos processos atraves do CVMP esta baseada no conceito
   de Canal Virtual. O Canal Virtual, e um conceito de canal de comunicacao,
   inspirado nos processadores Transputer [Inmos, 1988] [Inmos, 1989]. Atraves dos
   Canais Virtuais, os objetos CVMP podem trocar mensagens e deste modo
   80
   A COMPUTACAO PARALELA - SOFTWARE
   possibilitar a comunicacao entre os processos. Os Canais Virtuais sao
   estabelecidos a partir de um par de objetos CVMP, onde um componente e mestre
   e o outro e escravo. Uma vez estabelecido, o Canal Virtual nao podera mais ser
   alterado. Essa caracteristica simplifica bastante o controle e a programacao do
   ponto de vista do usuario [Bruno & Costa, 2000] [Bruno & Costa, 1996] [Bruno &
   Costa, 1997].
   Os componentes ou objetos CVMP sao VCLs (Visual Component Library)
   [Konopka, 1997] compativeis com os ambientes de programacao Borland Delphi
   [Calvert, 1999] e C++ Builder [Calvert, 1997]. Possuem caracteristicas de
   programacao orientada a objetos, podendo ser programados visualmente e deste
   modo ser simples de usar. Funcionam em computadores com plataforma Windows
PA NT/9X, conectados via rede (ethernet, fast-ethernet ou ATM) atraves dos protocolos
   de rede TCP/IP [Bennett, 1997] e IPX/SX [Chappell, 1998], assim como em
   maquinas multiprocessadas, atraves de variaveis compartilhadas.
   Diferentemente do PVM e MPI, o CVMP possui carater homogeneo. Do
   ponto de vista da plataforma, todos os micros deverao estar executando Windows
   9X/NT. A sua principal caracteristica e a simples utilizacao do pacote, permitindo a
   pesquisadores e programadores de diversas areas a exploracao de paralelismo em
   seus algoritmos. Essa caracteristica se acentua para algoritmos voltados para
   Visao Computacional e Processamento de Sinais.
   3.9 - DESENVOLVIMENTO DE SOFTWARE
   Nesta secao iremos abordar brevemente algumas tecnicas, conceitos e
   ferramentas, que auxiliam no desenvolvimento de software. De um modo geral, os
   conceitos genericos de desenvolvimento de software paralelo sao similares aos de
   software sequencial. Iniciaremos a discussao atraves de uma breve apresentacao
   da engenharia de software, que constitui de uma serie de ferramentas, metodos e
   procedimentos para formalizar o desenvolvimento de software. Em seguida
   comentaremos um pouco sobre a avaliacao e teste de software, apresentando o
   revolucionario conceito de programacao orientada a objetos, e passando para
   interfaces graficas com o usuario e programacao visual. Finalmente terminaremos
   esta secao discutindo tecnicas de analise de desempenho de programas paralelos
   e a engenharia da utilizacao.
   81
   CAPITULO 3
   3.9.1 - ENGENHARIA DE SOFTWARE
   As primeiras decadas da historia da computacao marcaram o dominio do
   hardware, quando este era considerado o maior desafio da Ciencia da
   Computacao, deixando o software em segundo plano. O conjunto de normas,
   organizacao, ferramentas e metodologias utilizadas no desenvolvimento de
   hardware foi denominado de Engenharia de Hardware, que na realidade tratava-se
   de mais uma especializacao da Engenharia Eletrica. Atraves da Engenharia de
   Hardware, o custo e o tempo de desenvolvimento de um novo sistema podia ser
   objetivamente calculado e estimado.
   De um modo geral, nao havia a comercializacao e industrializacao do
   software, como consequencia, este era desenvolvido dentro das empresas, pelas
   mesmas pessoas que iriam utiliza-los e em caso de erros corrigi-los. Esse tipo de
   abordagem permitia que o desenvolvimento de software fosse realizado sem
   qualquer tipo de formalismo, metodos, normas e documentacao. Dentro desse
   ambiente, o mundo do software estava completamente indisciplinado, acarretando
   na crise do software (final da decada de 1970), responsavel pela improdutividade,
   alto custo, insatisfacao dos consumidores, longo periodo de desenvolvimento, baixa
   qualidade, dificil manutencao, etc. [Pressman, 1988]
   Na tentativa de ordenar a criacao, implementacao e manutencao de
   software, surgiu a Engenharia de Software, que compreende uma serie de
   metodologias, criterios, conceitos, ferramentas, que possibilitaram a formalizacao
   do software.
   Segundo Pressman [Pressman, 1988], o software pode ser definido como:
   Instrucoes (programas de computadores) que quando executadas fazem com que o
   hardware proceda de acordo com a sua programacao.
   Estrutura de dados que permitem aos programas manipular adequadamente
   informacoes.
PA A documentacao que descreve a operacao e a utilizacao dos programas.
   Dentro da filosofia da engenharia de software, os projetos sao desenvolvidos
   em ciclos. Esta abordagem e denominada de Paradigma de Engenharia de
   Software [Pressman, 1988]. Cada projeto possui um paradigma apropriado, sendo
   escolhido de acordo com sua natureza e de sua aplicacao. Embora existam
   82
   A COMPUTACAO PARALELA - SOFTWARE
   diversos paradigmas diferentes, apresentamos na Figura 3.11 um modelo classico
   de ciclo de vida de um software.
   Engenharia de
   Sistema
   Analise
   Projeto
   Codigo
   Testes
   Manutencao
   Fig. - 3.11 - Ciclo de vida classico de um software.
   O projeto de software e dividido em tres fases: definicao, desenvolvimento e
   manutencao. Cada uma destas fases possuem diversas metodologias,
   procedimentos, analises e ferramentas. Segundo a Engenharia de Software tem
   demonstrado, a forte formalizacao dos processos de criacao, producao e
   manutencao do software, faz com que o projeto de software apresente uma
   previsao de tempo, custo e qualidade previamente determinados, assim como nas
   demais areas da engenharia.
   A engenharia de software tem tambem como objetivo o desenvolvimento de
   ferramentas de auxilio a modelagem e desenvolvimento de software. Dentre estas,
   devemos comentar o CASE (do ingles "Computer Aided Software Engineering").
   Atraves de ferramentas CASE, algumas tarefas repetitivas de programacao podem
   ser substituidas pela geracao automatica de codigo. Dentre as ferramentas CASE,
   destacam-se as voltadas ao desenvolvimento de software que utilizam base de
   dados e tambem as ferramentas de geracao automatica de interfaces para
   aplicacoes direcionadas para ambientes GUI [Bruno, 1995]. As ferramentas CASE
   voltadas para base de dados possibilitam a geracao de codigo a partir da
   diagramacao de metodologias de analise de dados (DFD) [Pressman, 1988].
   As ferramentas CASE voltadas a interfaces, embora possuam versoes
   voltadas a ambientes CLI [Hayes, 1990] sao especialmente uteis em ambientes GUI
   (veja Secao 9.4). Conforme e apresentado por [Bruno, 1995], as aplicacoes
   83
   CAPITULO 3
   voltadas para ambientes GUI por mais simples que sejam envolvem uma complexa
   programacao de sua interface, uma vez que se preocupam muito mais com o
   usuario. A complexidade do tratamento da interface faz com que muitas linhas de
   codigo sejam necessarias para implementar uma simples aplicacao GUI, tornando
   as ferramentas CASE vitais, uma vez que geram o codigo da camada de interface
   automaticamente, poupando o programador dessa tarefa macante e muitas vezes
   repetitiva.
   Atraves de ferramentas CASE para GUI originou-se o conceito de
   programacao visual, que e tratado na Secao 3.9.5.
   3.9.2 - AVALIACAO E TESTES
   A avaliacao e testes de um software e uma das etapas que mais tomam
PA tempo no projeto (cerca de 40% do tempo total [Pressman, 1988]). Em alguns
   casos extremos, como controle de voo ou reatores nucleares, a fase de teste pode
   custar tres a quatro vezes mais que todas as outras etapas juntas. Os principais
   objetivos para a realizacao dos testes nos projetos de software e a qualidade e o
   funcionamento correto do software
   Conforme podemos observar na Figura 3.11, a etapa de avaliacao e testes
   de um software e uma das ultimas a ser realizada num projeto de engenharia de
   software. Na fase de testes sao localizados os erros cometidos nas fases anteriores
   do projeto. Uma vez localizados, deve-se voltar a fase onde estes ocorreram,
   altera-los e repetir os testes novamente, fazendo com que a depuracao desenvolva
   um ciclo.
   Existem duas alternativas para a realizacao da fase de testes: manual e
   automatica. Enquanto na manual o software e analisado por usuarios, a automatica
   consiste de um outro software, capaz de efetuar a analise de forma automatica.
   Devido a complexidade de implementacao do software de analise, tambem
   conhecido como CASE de teste ou depuracao, a grande maioria dos testes e
   realizado manualmente.
   Quando um erro e detectado indicando alguma falha de programacao, pode
   ser facilmente localizado ou nao atraves do codigo fonte. Quando os erros nao sao
   facilmente detectados a partir da analise do codigo, o programador utiliza algumas
   ferramentas de auxilio a programacao, tais como o "debbuger" e o "trace",
   disponiveis na grande maioria dos ambientes de programacao.
   84
   A COMPUTACAO PARALELA - SOFTWARE
   Em computacao paralela, o teste do software e uma tarefa ainda mais
   trabalhosa, uma vez que as situacoes de analise nao estao mais dispostas de modo
   sequencial. Cada codigo distribuido entre os processadores do sistema deve ser
   analisado em conjunto, e em algumas situacoes as falhas nao sao claramente
   detectadas independentemente. Atualmente, a maioria dos sistemas de
   computacao paralela, especialmente os de computacao distribuida, nao possuem
   ferramentas especificas para a depuracao de erros, utilizando versoes como as dos
   sistemas sequenciais, tornando a analise e teste de software paralelo bastante
   complexa.
   3.9.3 - PROGRAMACAO ORIENTADA A OBJETOS
   A programacao orientada a objetos ou OOP (abreviacao do ingles "Object-
   Oriented Programming"), embora tenha sido iniciada com o Simula, despontou
   juntamente com os projetos do PARC (Palo Alto Research Center) da Xerox. O
   PARC percorreu toda a decada de 70 pesquisando e obteve em meados da decada
   de 80 um novo conceito de interface entre homem-maquina, a interface grafica com
   o usuario, tambem denominada de GUI (abreviacao do ingles "Graphical User
   Interface"). Embora intimamente ligada, ao conceito de GUI, a programacao
   orientada a objeto nao depende necessariamente desse conceito, uma vez que e
   um paradigma ligado ao modo de programacao.
   O principio basico da OOP e abstrair o software e modela-lo a partir do
   conceito de objetos, existente no mundo real [Cox, 1986] [Pressman, 1988]. A
   Figura 3.12 apresenta o paradigma OOP segundo o Smalltalk [Hurson et al., 1993].
   Vamos a seguir apresentar alguns conceitos basicos sobre OOP. Um objeto e,
   basicamente, um pacote de informacoes (dados) e as descricoes de suas formas
   de manipulacao (metodos). Uma das principais caracteristicas dos objetos e a
   encapsulacao, ou seja, os dados de um objeto sao protegidos do mundo exterior,
PA sendo inacessiveis. O unico meio de obter acesso a esses dados e atraves do
   envio de mensagens aos seus metodos, onde a mensagem e definida como uma
   especificacao para um metodo do objeto. O metodo e uma entidade (como um
   procedimento) que descreve uma sequencia de acoes a serem realizadas. Algumas
   mensagens possuem a caracteristica de requerer um retorno, nesses casos, apos a
   execucao do metodo, a informacao solicitada e retornada. Os objetos sao definidos
   e agrupados atraves de classes [Bruno, 1995], as quais sao constituidas por
   85
   CAPITULO 3
   declaracoes formais.
   Fig. - 3.12 - Concepcao de Objeto.
   A OOP possui diversas caracteristicas tais como: organizacao hierarquica,
   heranca, polimorfismo, facilidade de agrupamento ordenado, abstracao de dados,
   reutilizacao de codigo, encapsulacao, entre outras.
   A OOP possibilita um grande auxilio a engenharia de software, atraves da
   abstracao de dados, encapsulacao e reutilizacao de codigo. Essas caracteristicas
   tornam o paradigma OOP muito vantajoso para grandes projetos, facilitando a
   independencia entre os programadores e a integracao de trabalho no
   desenvolvimento do software e proporcionando tambem a reabilitacao e reciclagem
   de software.
   Uma outra caracteristica muito relevante da OOP, especialmente para o
   assunto deste capitulo, e sua abordagem paralela. Devido a arquitetura
   encapsulada e orientada as mensagens, o paradigma OOP e caracterizado por
   apresentar uma abordagem natural ao paralelismo. Se observarmos os modelos de
   arquitetura MIMD distribuidos (ver Secao 2.5.5) poderemos constatar que sao muito
   semelhantes ao modelo OOP, especialmente no que se refere ao encapsulamento
   dos dados e a comunicacao entre objetos por troca de mensagens.
   Outra caracteristica do paradigma que beneficia a implementacao de
   aplicacoes paralelas, e a facilidade e a versatilidade para modelar situacoes
   complexas, uma vez que as aplicacoes paralelas envolvem algoritmos complexos.
   Este fato deve ser bastante considerado, ja que um dos maiores obstaculos para o
   86
   A COMPUTACAO PARALELA - SOFTWARE
   desenvolvimento de programas paralelos esta exatamente na sua complexidade e
   dificuldade de implementacao.
   3.9.4 - INTERFACE GRAFICA COM O USUARIO (GUI)
   Nesta secao vamos abordar a revolucionaria interface grafica com o usuario
   (GUI). Durante toda a decada de 70 e inicio da decada de 80 este novo conceito de
   interface entre homem-maquina foi pesquisado pelo PARC (Palo Alto Research
   Center) da Xerox. Atualmente utilizado em larga escala na maioria das plataformas
   dos computadores, a GUI tem a sua principal caracteristica no conceito de
   utilizacao do dispositivo de exibicao de forma virtual, possibilitando que o usuario
   interaja virtualmente com a maquina arrastando icones, clicando botoes e
   manipulando dispositivos de controle diretamente na tela.
   3.9.4.1 - DEFINICAO DE GUI
   O primeiro dispositivo que forneceu uma interface interativa homem -
   maquina, largamente utilizado nos primordios da computacao (decadas de 50 e 60),
   foram as "teletypewriters" (TTYs), terminais baseados em caracteres, onde cada
   caracter digitado era impresso em papel. Com o aprimoramento tecnologico,
   tornaram-se disponiveis os terminais de video (baseados em caracteres). Pela
PA incontestavel superioridade de interacao sobre os TTYs, os terminais de video
   rapidamente tornaram-se uma norma na computacao [Hayes, 1990]. Nestes
   sistemas baseados em caracteres, a interface com o usuario adotada era a
   interface de linhas de comando (CLI do ingles "command-line interface"), que vem
   sendo utilizada ate os dias de hoje.
   Os sistemas operacionais com interface CLI, como o DOS ou o UNIX, vem
   sendo criticados ao longo do tempo pela complexidade de suas interfaces com o
   usuario. Desenvolvido para ser utilizado em minicomputadores, o UNIX foi criado
   como um conjunto de aplicacoes compartilhaveis, que dispunham de uma interface
   orientada a linha (CLI). Esta interface foi revolucionaria em seu tempo, por sua
   simplicidade e poder. O UNIX introduziu o conceito de "shel ", um interpretador de
   comandos, que le e executa as linhas de comando provenientes do teclado [Peddie,
   1992]. O DOS foi implementado mediante este conceito muitos anos depois.
   Os pesquisadores do Xerox PARC, contudo, estavam trabalhando com uma
   ideia diferente. Pesquisavam uma interface que substituisse as linhas de comando
   87
   CAPITULO 3
   e as telas de caracteres, por telas graficas com grandes mapas de bits, atraves das
   quais os comandos seriam exibidos graficamente (na forma iconica). Assim a
   interface com o computador seria de forma "visual" [Peddie, 1992] [Petzold & Yao,
   1996].
   Para isso, os pesquisadores do PARC precisaram revolucionar o conceito
   de monitor de video. Antigamente, o monitor de video, era utilizado somente para
   reproduzir o texto que o usuario digitava no teclado. Com a nova concepcao o
   monitor, atraves de um apontador (no caso o "mouse", tambem criado na Xerox
   PARC), transformava-se numa verdadeira fonte de entrada de dados [Petzold &
   Yao, 1996]. A tela do monitor de video passa agora a exibir objetos graficos na
   forma de icones e janelas com dispositivos que sao verdadeiros comandos
   "virtuais", como botoes, barras de rolagem, menus, etc. Esses sao manipulados
   virtualmente pelo usuario, atraves do apontador e tambem do teclado. A Figura 3.13
   apresenta o aspecto visual de uma interface grafica com o usuario (GUI).
   Os graficos fazem uma utilizacao melhor da tela, transmitindo informacoes
   de maneira visual mais rica. E a combinacao da exibicao rica com a manipulacao
   virtual dos graficos fez das GUIs uma nova etapa evolutiva da interface homem-
   maquina. Deste modo com evolucao de CLIs para GUIs, trabalhamos com um
   computador menos abstrato e mais "real" [Peddie, 1992] [Petzold & Yao, 1996].
   Durante decadas, pesquisas tem sido realizadas com o intuito de
   desenvolver arquiteturas que aproveitem melhor o "software". Nestas pesquisas
   apareceram questoes em relacao a prioridades; as interfaces devem ser projetadas
   a fim de que os usuarios experientes tirem, ao maximo, o proveito das maquinas,
   ou a fim de otimizar a curva de aprendizado dos iniciantes ? [Hayes, 1990].
   As interfaces graficas com o usuario demostraram ser uma resposta efetiva
   para as questoes de prioridade, na interface homem - maquina [Hayes, 1990]. Com
   esta nova tecnologia, a utilizacao da maquina satisfaz todos os niveis de usuarios:
   [Peddie, 1992]
   usuario iniciante, atraves da simplicidade de utilizacao, interacao e conceitos
   intuitivos, imediatamente torna-se habil para utilizar alguns recursos da maquina.
   O treinamento torna-se entao rapido e eficaz, nao necessitando de leitura de
   manuais extensos, e o aprendiz rapidamente esta habil a ser "mestre".
   usuario casual, que executa varias diferentes aplicacoes diariamente, encontra a
PA consistencia do padrao entre as diferentes aplicacoes.
   E o usuario experiente ("power user"), tambem e beneficiado por executar suas
   88
   A COMPUTACAO PARALELA - SOFTWARE
   tarefas com maior interacao. Ele se beneficia do maior numero de recursos
   providos com o novo sistema (ex: multitarefa).
   Fig. - 3.13 - Aspecto visual de uma GUI.
   3.9.4.3- MODELO DE CAMADAS
   Atualmente existe uma grande variedade de GUIs, diferindo em varias
   caracteristicas. Alem das diferencas em relacao a interface, podem variar tambem
   quanto ao seu nivel de integracao com o sistema operacional. Certas GUIs sao
   fortemente agregadas ao sistema operacional (Macintosh), enquanto que outras
   sao visivelmente colocadas sobre o sistema operacional (Windows, e das GUIs
   para o UNIX).
   A definicao do que faz parte ou nao de uma GUI varia de um fabricante para
   outro. Apresentaremos um modelo generico das camadas de uma GUI que tem
   como objetivo mostrar seus componentes (Figura 3.14). O modelo apresentado
   nesta figura ilustra uma GUI que e colocada sobre o sistema operacional, entretanto
   existem casos em que o sistema operacional e parte integrante da GUI [Peddie,
   1992].
   O modelo de GUI da Figura 3.14 e composto por cinco camadas, as quais
   serao comentadas a seguir:
   89
   CAPITULO 3
   Modelo de objetos: O caminho pelo qual as aplicacoes reagem entre si
   frequentemente, envolve o uso de um modelo de objetos. O modelo "Object Link &
   Embedding (OLE)" e um exemplo desta camada. Existem algumas GUI que nao
   possuem um modelo de objetos.
   API: A Abreviacao e oriunda do ingles "Application Program Interface". Esta
   camada e um conjunto de funcoes que sao utilizadas pelos programas para se
   comunicarem com a GUI. O programador precisa especificar quais funcoes (ex:
   janelas, menus, barras de rolagem, icones e etc.) sao utilizadas e quando.
   GUI: Como mencionado outrora, o que faz parte ou nao de uma GUI varia
   de fabricante para fabricante. A camada GUI e onde as acoes e elementos da tela
   residem.
   Sistema de janelas: Esta camada e tao dificil de definir quanto a camada
   GUI. Por exemplo, o X-Window e apenas um sistema de janelas, ao passo que o
   Windows e um sistema de janelas e uma GUI construidos juntamente.
   Modelo de imagem: Enquanto o sistema X-Window nao tem um modelo de
   imagem, algumas GUI suportam mais de um modelo de imagem. E o caso do
   NeWS da Sun Microsystem, que suporta um modelo similar ao modelo de imagem
   Display PostScript (DPS); porem, diferente do DPS, ele pode tambem trabalhar com
   um modelamento complexo como o PHIGS ou GKS para controle de programas de
   CAD ("Computer Aided Design").
   Fig. - 3.14 - Modelo em Camadas de uma GUI.
   E bastante dificil obter um modelo generico de representacao para todas as
   GUIs, que diferem muito. Na Figura 3.14 foi apresentado um modelo que tenta ser o
   mais generico possivel.
   Na Figura 3.15 sao apresentadas algumas GUIs diferentes, possibilitando a
   comparacao de uma para outra. Nao obstante, nem todas as GUIs possuem as
PA 90
   A COMPUTACAO PARALELA - SOFTWARE
   camadas descritas no modelo generico. Existem algumas que apresentam
   camadas externas, como o caso do NeXTstep, que nao e fundamentado numa
   plataforma orientada ao objeto. Neste caso, o modelo de objeto, quando usado
   nesse sistema, e externo.
   Fig. - 3.15 - Diagrama comparativo de camadas de GUI.
   3.9.4.4- FUNDAMENTOS DE PROGRAMACAO EM GUI
   Com o conceito GUI, varias novas tecnologias de programacao foram
   91
   CAPITULO 3
   adotadas ou criadas para dar consistencia a nova interface homem-maquina.
   Ao contrario da filosofia CLI, a plataforma GUI e voltada para o usuario, e
   nao para o programador. Com isto, a tarefa de programar (utilizando um compilador
   tradicional) para um ambiente GUI, nao e tao simples como num ambiente CLI, cuja
   filosofia facilita ao programador. Nos primordios do ambiente GUI, a programacao
   de aplicativos era uma tarefa extremamente dificil e trabalhosa, pois embora o
   sistema gerenciasse as janelas e facilitasse sua criacao, uma boa parte do trabalho
   era destinado ao programador. Atualmente, essa tarefa e realizada
   automaticamente atraves de CASE ou da programacao visual, liberando o tempo e
   esforco do programador para outras atividades importantes [Bruno,1995].
   3.9.5 - PROGRAMACAO VISUAL
   A ideia de programacao visual surgiu com o famoso projeto Vivarium, no
   qual criancas utilizavam o Smal talk para desenvolver um ambiente e entao o
   povoavam com animais virtuais. Se criancas podem gerar um "mundo"
   simplesmente movimentando objetos, nao poderiamos utilizar a mesma abordagem
   para desenvolver aplicativos ? [Bonner, 1995].
   A ideia basica da programacao visual seria desenvolver uma ferramenta na
   qual fosse possivel gerar um aplicativo sem escrever nenhuma linha de codigo.
   Porem, o que ocorre e que na programacao visual os elementos da interface com o
   usuario, suas caracteristicas e controle sao gerados visualmente (atraves do
   apontador) e a estes elementos e ligado o codigo que implementa a acao
   ("software") que provoca o elemento. Este codigo nao e implementado visualmente,
   ficando como tarefa das linguagens convencionais (ou nao) de programacao.
   Atualmente, parece predominar a tendencia de ferramentas de programacao
   visual. Fortemente ligada aos conceitos GUI e OOP, a larga difusao dessas duas
   tendencias tem arrastado consigo a programacao visual, a qual tem influenciado
   muitos ambientes de linguagens de programacao convencionais.
   O conceito de programacao visual tem base na inversao da enfase da
   programacao. Nas interfaces baseadas em caracteres (CLI), e nos compiladores
   tradicionais de linguagens procedimentais, a enfase da programacao residia no
   projeto das estruturas de dados e na traducao logica de uma atividade para o
   codigo do programa. O projeto da interface com o usuario ficava normalmente em
   segundo plano. As ferramentas de programacao visual invertem esta equacao: o
   92
   A COMPUTACAO PARALELA - SOFTWARE
   processo de programacao comeca com a interface com o usuario, e permanece
   centralizado nela [Bonner, 1995].
   Com isso surge uma nova filosofia de codificacao, onde o codigo do
   programa fica ligado diretamente aos objetos da interface com o usuario. Isto so e
PA possivel em ambiente onde o compilador e o CASE estejam integrados.
   Dentre as ferramentas de programacao visual para ambiente Windows
   disponiveis atualmente, podemos citar como exemplos de compiladores que
   possuem ferramentas de programacao visual o Borland Delphi e o C++ Builder
   assim como o Microsoft Visual Basic. Estes compiladores possuem um parque
   estabelecido de usuarios, tornando um forte padrao para a programacao em
   ambiente Windows. As suas principais vantagens estao na simplicidade de
   elaboracao de prototipos e construcao automatica de interfaces, alem da utilizacao
   de componentes visuais, que tornam facilmente acessiveis, atraves de objetos
   (OOP), poderosos recursos de programacao.
   3.9.6 - ANALISE ESTATISTICA, GARGALOS E
   DESEMPENHO DE PROGRAMAS PARALELOS
   Conforme comentamos anteriormente, a principal motivacao para a
   exploracao de paralelismo nas maquinas, seja via hardware ou software, e o
   aumento da performance. A grande questao e avaliar a performance de um
   software. Mesmo nos softwares sequenciais, avaliacao de performance e muito
   complexa, chegando a ser subjetiva, uma vez que interacao entre as camadas
   inferiores (ver Figura 3.1) exerce papel fundamental no desempenho em questao.
   Normalmente, a avaliacao de performance e feita atraves da comparacao de
   desempenho entre as aplicacoes. Esse metodo e conhecido como benchmark
   [benchmark].
   No entanto a confiabilidade nas medidas de benchmark sao questionaveis,
   uma vez que a comparacao entre os algoritmos e sua performance pode dar
   resultados completamente diversos dependendo da arquitetura na qual a aplicacao
   esta sendo executada. Como exemplo, se compararmos dois algoritmos que
   utilizam estrategias adversas para solucionarem o mesmo tipo de problema, e
   utilizarmos duas plataformas diferentes, e bastante frequente ocorrer que um
   algoritmo possua uma performance superior a seu concorrente em uma plataforma,
   e esse resultado se inverta completamente na outra plataforma. Isso ocorre devido
   93
   CAPITULO 3
   a interacao entre as camadas inferiores a aplicacao.
   A complexidade da avaliacao de desempenho de um software aumenta
   muito quando tratamos de computacao paralela, especialmente no caso dos
   sistemas baseados em computacao distribuida, que ainda podem ser compostos
   por plataforma heterogeneas. Em computacao paralela, alem de avaliar o
   desempenho como um todo, e essencial que seja analisado o desempenho de cada
   uma das etapas de execucao dos programas, da comunicacao entre processos,
   acesso a disco, etc. Somente atraves da analise de performance e tempo
   despendido em cada uma das etapas e que podemos localizar os gargalos, ou seja
   regioes responsaveis pelo comprometimento da performance.
   (A)
   (B)
   (C)
   Fig. - 3.16 - Comparacao entre a vazao de fluxo em um sistema de
   encanamento e o desempenho do conjunto hardware/software.
   O conceito de gargalo em software e similar ao gargalo em fluxo de fluidos.
   Podemos comparar o fluxo de execucao do software a vazao de fluidos em um
   sistema de encanamento. A Figura 3.16 apresenta um exemplo que ilustra a
   comparacao entre a execucao de software paralelo e vazao em sistema de
PA encanamento. Devemos observar que o termino de execucao ou vazao ocorre
   quando nao ha mais fluido em nenhum ducto. Na representacao devemos observar
   que cada ducto corresponde a um conjunto hardware/software e o fluido ao fluxo de
   processamento. Devemos observar ainda que o diametro do ducto corresponde ao
   desempenho computacional de cada conjunto hardware/software, com isso, quanto
   maior o diametro do ducto, maior sera a sua vazao ou desempenho. Porem de,
   modo similar ao que ocorre nos fluidos, existem regioes, onde o estreitamento do
   ducto compromete sua vazao. Essas regioes sao denominadas de gargalos. O
   gargalo limita a vazao do ducto como um todo, nao importando seu diametro
   94
   A COMPUTACAO PARALELA - SOFTWARE
   anterior, do mesmo modo, no conjunto hardware/software, nao importa o poder
   computacional anterior ao gargalo, dependendo de quao estreito seja o gargalo,
   todo o desempenho do conjunto sera comprometido.
   Desse modo, observamos que embora o ducto (B) tenha um poder de vazao
   maior que os ductos (A) e (C), devido ao gargalo que possui, sua vazao e muito
   menor que a vazao de (A) ou de (C). Em termos do conjunto hardware/software, o
   ducto (B) poderia ser comparado a um sistema com um processador mais
   poderoso, porem em algum ponto de seu programa existe um intensivo acesso a
   um dispositivo de hardware lento (acesso a disco ou rede) ou ainda algum tipo de
   processamento dispendioso. Podemos observar tambem, que simultaneamente ao
   momento em que ocorre o gargalo no ducto(B), o ducto (C) aumenta seu diametro.
   Isso seria equivalente a uma sub-utilizacao de seus recursos computacionais num
   dado momento. A partir da analise de gargalo, o programador pode rever a
   estrategia de paralelizacao de modo a balancear a carga de processamento da
   etapa critica (gargalo) de (B) com a fase de sub-utilizacao de (C), eliminando o
   gargalo e consequentemente, aumentando o desempenho do sistema como um
   todo.
   Como vimos, a localizacao e a eliminacao dos gargalos e vital para o
   desempenho do software (o mesmo se aplica ao hardware). Embora na
   computacao sequencial a analise e localizacao de gargalos sejam importantes, elas
   sao cruciais na computacao paralela, que deve sua existencia principalmente a
   velocidade. Sem a localizacao e a eliminacao de estreitos gargalos, um sistema
   paralelo com diversos processadores pode possuir a mesma velocidade, ou ainda
   pior, ser mais lento que seu equivalente sequencial, tornando-se completamente
   ineficiente e sem sentido.
   Basicamente, a tecnica utilizada para localizar os gargalos de um software
   consiste no mapeamento de todas as suas etapas, registrando a performance
   individual de cada uma. Embora existam algumas ferramentas para auxiliar a
   medida de cada uma das etapas (Engenharia de Software), na maioria dos casos
   essa tarefa e realizada pelo programador, que deve fazer uma analise estatistica do
   tempo de execucao de cada uma delas. No caso do CVMP, implementamos
   ferramentas especificas para a localizacao de gargalos e analise de desempenho
   de software, que serao comentadas no Capitulo 6.
   A partir do mapa de desempenho, pode-se localizar com precisao os
   gargalos dos sistemas paralelos e deste modo auxiliar sua eliminacao. Uma outra
   95
   CAPITULO 3
   estrategia seria analisar diferentes etapas de algoritmos lineares, e apos localizar
   as etapas mais custosas, tracar uma estrategia de paralelizacao mais eficiente
PA antes mesmo da implementacao da versao paralela. Como exemplo dessa
   abordagem, a Figura 3.17 mostra um diagrama que representa uma analise de
   desempenho em uma aplicacao sequencial e posteriormente sua versao paralela.
   Algoritmo Sequencial
   Proc. 1
   Algoritmo Paralelo
   Proc. 1
   Leitura de dados
   Proc. 2
   Processamento parte 1
   Processamento parte 2
   Proc. 3
   Gravacao de dados
   Proc. 4
   Transmissao de dados
   Tempo de duracao da execucao sequencial versus paralela
   Sequencial
   Paralela
   Fig. - 3.17 - Mapa de desempenho das diferentes etapas de um programa e a
   eliminacao de um gargalo atraves de sua paralelizacao.
   Como podemos observar, neste exemplo a aplicacao foi dividida em quatro
   etapas: leitura de dados, processamento parte 1, processamento parte 2 e escrita
   de dados. Segundo constatamos ao observar o diagrama, a etapa processamento
   parte 1 e onde se localiza o gargalo do programa e supondo que essa etapa nao
   possua uma grande dependencia de dados e seja simples de paralelizar, podemos
   dividi-la em quatro partes, atraves da paralelizacao. Embora essa divisao
   acrescente mais etapas, responsaveis pela transferencia de dados entre os
   processadores ou maquinas, o principal gargalo do sistema e eliminado e
   96
   A COMPUTACAO PARALELA - SOFTWARE
   consequentemente ocorre um ganho no desempenho. No caso do exemplo, para
   quatro processadores, o tempo de execucao do programa paralelo e da ordem de
   2,5 vezes menor.
   Devemos observar, entretanto, que quando concentramos esforcos ou
   recursos computacionais apenas em um unico ponto do problema, ocorre que o
   gargalo e transferido para uma outra etapa. Na Ciencia da Computacao esse
   paradoxo e conhecido como lei de Amdahl [Hockney & Jesshope, 1988]. Tomando
   o nosso exemplo, se aumentarmos o recurso computacional, ou seja, se
   aumentarmos o numero de processadores na versao paralela, a um determinado
   momento, o gargalo sera deslocado para outras etapas do programa, e a partir
   desse momento nao faria mais sentido aumentar os recursos computacionais para
   essa fase, havendo entao necessidade de eliminar os outros gargalos para
   aumentar o desempenho de forma efetiva.
   Ainda quanto a analise, e possivel medir objetivamente a performance e
   desempenho de um software paralelo em relacao a seu equivalente sequencial.
   Essa medida, denominada de "speed-up" ( Sp), e dada pela razao entre o tempo de
   execucao do programa sequencial ( ts) pelo tempo de execucao do programa
   paralelo ( tp) (Equacao 3.1). Ainda em termos de desempenho, e importante
   tambem saber a eficiencia da paralelizacao, ou seja, se foi realizado um
   balanceamento de cargas efetivo, e consequentemente sem gargalos. A eficiencia
PA e dada pela razao entre o tempo em que o programa utiliza os recursos
   computacionais ( tu - tempo de processador em uso) e o tempo total de execucao
   ( tt) (Equacao 3.2). Embora existam outras formas de mensurar o desempenho de
   software paralelo, o "speed-up" e a eficiencia sao as mais genericas [Costa &
   Slaets, 1991] [Faber et al., 1987].
   ts
   Sp( N ) =
   (3.1)
   tp( N )
   tu
   E =
   (3.2)
   tt
   97
   CAPITULO 3
   3.9.7 - ENGENHARIA DA UTILIZACAO
   O projeto PARC (Palo Alto Research Center) da Xerox, influenciou a ciencia
   da computacao em diversos aspectos diferentes, dentre os quais podemos citar: a
   interface grafica com o usuario (GUI), a descoberta do apontador (mouse), a
   virtualidade do monitor (atraves de eventos e botoes GUI), a programacao visual, a
   programacao orientada a objetos, a estacao de trabalho, etc. Observando a
   computacao atual, e a importancia desses conceitos podemos concluir que grande
   parte da historia da computacao moderna foi escrita no PARC [Bruno, 1995]. Dentre
   as novas ideias apresentadas pelo PARC, uma das mais importantes foi a
   consagracao do computador e do software como uma ferramenta de trabalho.
   Embora esse conceito nao tenha sido diretamente ditado pelo PARC, foram suas
   novas ideias que impulsionaram o surgimento dessa tendencia.
   A tendencia de assumir o computador como uma ferramenta de trabalho
   surgiu atraves da revolucao da micro-informatica. Com a queda dos computadores
   de grande porte ( mainframes) e o aparecimento dos microcomputadores, esses
   comecaram a proliferar e a informatica iniciou sua jornada de influencia em todas as
   areas de nossa sociedade. A partir desse momento, a concepcao da utilizacao dos
   computadores comecou a mudar. Inicialmente, os computadores existiam em
   numero reduzido, eram carissimos e as poucas corporacoes que desfrutavam
   dessas maquinas possuiam uma equipe de profissionais altamente treinados para
   opera-los. Neste contexto, nao havia a necessidade de se preocupar com a
   dificuldade de manipular ou programar os computadores, uma vez que estes eram
   operados e programados apenas por profissionais altamente especializados e
   treinados. A complexidade dessas tarefas nao era um problema, era apenas uma
   caracteristica do perfil das profissoes ligadas a computacao, uma vez que tais
   profissionais eram os unicos usuarios dos computadores.
   Com o surgimento da micro-informatica e com a proliferacao dos
   microcomputadores, o perfil dos usuarios mudou drasticamente. Ao inves de
   especialistas altamente treinados, os usuarios passaram a ser pessoas comuns,
   dispostas a utilizar os computadores para auxiliar de alguma forma suas tarefas.
   Dentro desse novo contexto nao ha lugar para a complexidade e a sobrevivencia de
   um produto (computador ou software) passou a depender tambem de sua
   simplicidade e objetividade para o usuario.
   E claro que essa transicao nao foi imediata. Nenhuma evolucao ou
   98
PA A COMPUTACAO PARALELA - SOFTWARE
   revolucao envolvendo o carater humano ocorre do dia para noite. O periodo de
   transicao entre o complexo e o simples na historia da informatica vem ocorrendo
   desde o final da decada de 70, e ainda continuamos vivenciando esse processo.
   Atraves da simplificacao da manipulacao dos computadores surgiu o conceito de
   ferramenta de trabalho, onde o computador e a informatica sao vistos como uma
   ferramenta para auxiliar o trabalho humano.
   Esse novo conceito nao e apenas uma tendencia, mas sim um novo
   postulado na Ciencia da Computacao. Atualmente contamos com novas areas tais
   como Interacao Homem - Maquina e Engenharia da Utilizacao que basicamente
   estao preocupadas com essas questoes.
   Comentamos anteriormente, as novas concepcoes apresentadas pelo PARC
   (Palo Alto Research Center) da Xerox foram essenciais para formar as bases da
   concepcao de ferramenta de trabalho. O conceito de interface grafica com o usuario
   (GUI) fez com que o metodo de utilizacao do computador se tornasse simples ao
   usuario inexperiente e agil ao usuario experto, como podemos constatar pela
   analise feita por Hayes [Hayes, 1990].
   No dia-a-dia, podemos observar que a questao da utilizacao e importante
   nao apenas para a informatica mas tambem para todas as demais areas. Se
   tivermos que escolher entre dois abridores de latas automaticos, que executam a
   mesma funcao com a mesma qualidade e eficiencia, sendo que um deles possui
   apenas um botao, bastando pressiona-lo para abrir a lata e o outro apresenta uma
   interface com o usuario bem mais complicada, com dezenas de ajustes, botoes e
   alavancas, qual dos dois abridores seria a ferramenta mais util ?
   Como consequencia da tendencia de simplificar a manipulacao dos
   computadores, descobrimos que nao apenas as aplicacoes voltadas ao usuario
   final apresentam-se com mais vantagens quando analisadas e pensadas sob o
   ponto de vista da engenharia da utilizacao, mas tambem as ferramentas, ambientes
   e linguagens de desenvolvimento. A razao para isso e bastante simples, quando
   utilizamos ferramentas complicadas, normalmente temos que perder tempo em
   treinamentos desnecessarios ou ainda executarmos um numero demasiado de
   procedimentos para realizar apenas uma tarefa. Ao passo que utilizando
   ferramentas simples, a situacao e completamente diferente, poucos procedimentos
   sao necessarios para realizar as tarefas assim como o tempo desperdicado com
   treinamentos e menor.
   Alguns conceitos foram essenciais para o desenvolvimento de ferramentas,
   99
   CAPITULO 3
   ambientes e linguagens de desenvolvimento de software mais adequados sob o
   ponto de vista da engenharia de utilizacao [Preece et al., 1994]. Atraves da
   programacao orientada a objetos, interface grafica com o usuario e programacao
   visual (PARC), assim como de conceitos extraidos da engenharia de software, tais
   como ferramentas CASE e reutilizacao de codigo, temos hoje uma serie de
   linguagens visuais, sistemas operacionais com GUI e ferramentas de
   desenvolvimento, que obedecem as regras da engenharia da utilizacao e sao
   simples e eficazes para os programadores.
   A engenharia da utilizacao e uma area da Ciencia da Computacao
   responsavel pelo estudo da maneira mais adequada de se utilizar e desenvolver
   interfaces entre o homem e a maquina. Atraves de analise estatistica sobre o
   comportamento humano ao utilizar um determinado software, e possivel encontrar o
PA modo mais adequado para que o software em questao torne-se uma ferramenta
   simples, intuitiva e eficaz [Preece et al., 1994].
   A medida que aumenta a sofisticacao das aplicacoes, dos programas e dos
   sistemas fica cada vez mais obvio a necessidade de ferramentas de
   desenvolvimento que utilizem os conceitos de engenharia da utilizacao e se tornem
   mais simples, intuitivas e eficazes. Isso fica claro especialmente para o
   desenvolvimento de aplicativos em GUI. O autor apresentou em sua dissertacao de
   mestrado [Bruno, 1995] um exemplo entre um ambiente visual e um compilador
   tradicional. Observando o codigo fonte e a diferenca entre procedimentos, podemos
   constatar a importancia de utilizar uma ferramenta adequada, que simplifica o
   trabalho, sem perder a eficiencia e qualidade. Enquanto no compilador tradicional o
   programador deveria escrever o codigo para todo o sistema de interface, ao inves
   de concentrar seu esforco na implementacao do algoritmo principal, atraves do
   ambiente visual, o programador simplesmente desenha a interface, e atraves de
   ferramenta CASE e gerado o codigo, economizando assim seu tempo. E muito mais
   vantajoso o programador concentrar o tempo de programacao em seu algoritmo
   principal do que programando a interface.
   O exemplo do ambiente de programacao visual e apenas uma
   demonstracao do emprego da filosofia da engenharia da utilizacao sob o aspecto
   macro (sistema como todo), no entanto a engenharia da utilizacao preocupa-se
   tambem com os detalhes, ou seja, interfaces, graficos, icones e nomes de funcoes
   e modo de utilizacao de bibliotecas de funcoes, visando tornar as ferramentas mais
   intuitivas e faceis de utilizar.
   100
   A COMPUTACAO PARALELA - SOFTWARE
   Pelo que observamos ao longo de nossa pesquisa, normalmente as
   ferramentas voltadas para a computacao paralela nao se preocupam com as
   questoes da engenharia de utilizacao, sendo na maioria dos casos complexas,
   exigindo treinamento amplo e geralmente necessitando ser manipuladas por
   especialistas da area. A historia nos mostra a importancia da engenharia de
   utilizacao e do mesmo modo a importancia de ferramentas simples e eficientes.
   Nao estamos questionando a eficiencia das ferramentas de desenvolvimento
   paralelo, mas sim sua simplicidade e sua preocupacao com a utilizacao (ser
   amigavel com o usuario). Temos observado que existe uma latencia na computacao
   paralela para a adocao dos principios da engenharia da utilizacao. Conforme
   comentamos anteriormente, um dos grandes problemas da computacao paralela e
   o desenvolvimento e manutencao de software. Existem muitos fatores responsaveis
   pela complexidade desses itens, porem acreditamos que um deles e a falta da
   adocao dos principios da engenharia da utilizacao e consequentemente com a falta
   de preocupacao com o usuario, que embora normalmente seja um especialista da
   area, poderia ser favorecido com tais conceitos.
   Visando esses fatores, um dos principais objetivos desta tese e o
   desenvolvimento de uma ferramenta intuitiva e simples de utilizar, voltada para a
   computacao paralela, a qual, atraves de sua simplicidade, pode ser utilizada
   mesmo por programadores com o minimo de conhecimento em computacao
   paralela. Portanto, uma das principais bases do pacote CVMP que sera
   apresentado no Capitulo 6 e a sua abordagem sob o ponto de vista da engenharia
   de utilizacao. De acordo com a evolucao natural da computacao e vital a existencia
   de uma ferramenta para desenvolvimento de aplicacoes paralelas que obedeca aos
   requisitos da engenharia da utilizacao, sendo desse modo intuitiva, facil de usar,
PA simples e eficiente.
   101
   CAPITULO 3
   102
   CAPITULO
   4
   OS CAMINHOS PARALELOS
   DA VISAO
   Paralelism is therefore of profund significance for understanding the workings of the
   cerebral cortex, and increases by several orders of magnitude the enormity of the
   task needed to understand the workings of the brain.
   Semir Zeki
   103
   CAPITULO 4
   104
   OS CAMINHOS PARALELOS DA VISAO
   CAPITULO 4 - OS CAMINHOS
   PARALELOS DA VISAO
   4.1 - INTRODUCAO
   Neste capitulo estaremos abordando a visao biologica, o mais eficiente
   sistema de aquisicao de informacao criado pela natureza, com enfoque em seu
   paralelismo. Iniciaremos nossa discussao abordando a evolucao em funcao da
   informacao e do paralelismo, correlacionando esses topicos. A seguir,
   discorreremos um pouco sobre as tecnicas de estudo de visao e apresentaremos
   uma breve introducao a neurociencia e finalmente discutiremos o sistema de visao
   natural dos primatas, apresentando o percurso da informacao visual dentro do
   maquinario neural enfocando o paralelismo.
   4.2 - INFORMACAO, EVOLUCAO, VISAO
   Quando lemos um livro, estamos alimentando nossa memoria com
   informacoes e, deste modo, aprendendo. Normalmente, atribuimos esse
   aprendizado a nossa inteligencia e nos esquecemos da importancia da aquisicao de
   informacoes nesse processo. Para salienta-la, podemos fazer as seguintes
   perguntas:
   Existe inteligencia sem a informacao ?
   Um individuo que nao possui nenhum sentido, ou seja, cujo cerebro nao
   possui conexao alguma com o meio exterior possui inteligencia ?
   Se refletirmos um pouco sobre essas questoes, logo podemos chegar a
   conclusao de que tanto a razao quanto a inteligencia nao existem sem a
   informacao, e ainda mais, podem ser definidas simplesmente como a interpretacao,
   aprendizado e compreensao da informacao. A palavra inteligencia tem sua origem
   do latim intelligentia, e sua definicao, segundo o tradicional dicionario Aurelio da
   lingua portuguesa, e a faculdade de aprender, apreender ou compreender;
   105
   CAPITULO 4
   percepcao, capacidade de compreender e adaptar-se facilmente e ainda maneira
   de interpretar ou entender. Devemos observar que nao podemos aprender,
   compreender ou perceber sem a informacao, e, deste modo, podemos concluir que
   nao existe inteligencia sem informacao.
   A importancia da informacao e tamanha que, durante bilhoes de anos, a
   natureza vem aprimorando os sentidos dos seres vivos, para que possam de
PA maneira mais eficiente se adaptar ao meio e, deste modo, sobreviver. Em algum
   ponto da historia da vida neste planeta, comecou a competicao entre as especies, e
   a informacao passou a desempenhar um papel importante, senao vital, para a
   sobrevivencia. Vamos imaginar as primeiras especies deste planeta a procura de
   alimento, ou seja, garantindo sua sobrevivencia. No inicio, essas criaturas primitivas
   nao possuiam sistemas sofisticados de aquisicao de informacao (sentidos),
   portanto seus metodos de procura por alimentos eram bastante ineficientes. Muitas
   vezes essas criaturas estavam proximas ao alimento e, devido a falta de
   informacao, nao localizavam-no e deste modo desperdicavam as oportunidades.
   Vamos supor que algumas especies, atraves da evolucao [Darwin, 1859],
   tivessem desenvolvido algum tipo de sistema de aquisicao de informacao, atraves
   do qual pudessem encontrar alimento de maneira mais eficaz que as demais. No
   primeiro momento em que houvesse escassez de alimento no "habitat" no qual
   concorriam, as especies que possuissem o sistema de aquisicao mais eficiente,
   certamente sobreviveriam, ao passo que as outras sucumbiriam.
   A informacao passa a ser ainda mais vital quando, alem da competicao por
   alimento, estao envolvidas tambem as atividades predatorias. A vitoria da luta entre
   presa e predador e dada, praticamente, pela informacao. Para o predador, e
   fundamental um sistema de aquisicao de informacao que localize a presa, enquanto
   que para a presa e vital a informacao sobre o predador. A natureza desenvolveu
   dispositivos tanto para a presa quanto para o predador com o intuito de obter
   informacoes (sentidos) ou oculta-las (camuflagem).
   Neste ciclo de adaptacao, luta e sobrevivencia, basicamente girando em
   torno da informacao, a natureza desenvolveu, ao longo de bilhoes de anos de
   evolucao, um sistema poderoso para obter informacao: a visao.
   Dentre todos os sentidos que a natureza desenvolveu, a visao consegue
   absorver a maior quantidade de informacao. A visao pode ser definida como a
   capacidade fisiologica de ver e perceber o mundo. Atraves de orgaos
   especializados, os olhos, as ondas eletromagneticas sao captadas e direcionadas
   106
   OS CAMINHOS PARALELOS DA VISAO
   para sensores capazes de senti-las, ou seja, converter a informacao proveniente
   em sinais neurologicos. Alem disso, a visao tambem consiste no processamento e
   interpretacao desses sinais, e foram exatamente nesses processos que a natureza
   encontrou seus maiores desafios e, atualmente, nossa ciencia tambem: como
   funciona a visao ?
   4.3 - EVOLUCAO, PARALELISMO E VISAO
   Nesta secao vamos discorrer sobre a evolucao, o paralelismo e a visao.
   Embora essa combinacao possa inicialmente parecer muito estranha e sem razao,
   veremos que seu sentido surge a partir dos paradoxos da evolucao.
   De acordo com a teoria da evolucao de Darwin, a vida na terra comecou a
   partir de uma forma de vida primitiva. Nao podemos provar com certeza como era a
   sua consistencia e composicao exata, porem teoricamente supomos que essa
   forma primordial de vida era constituida por uma unica celula, ou seja estamos
   falando de um ser unicelular. Nao sabemos por que, nem qual e o objetivo ultimo da
   evolucao, mas e claro o seu anseio por formas de vida mais adaptadas e muitas
   vezes, em consequencia disso, complexas.
   Na busca da adaptacao, e consequentemente da complexidade, em algum
   momento da evolucao surgiu um individuo cujo organismo era formado por mais de
   uma celula, surgiram assim os individuos pluricelulares. Podemos observar aqui a
PA primeira escolha da natureza pelo paralelismo, se nesse caso considerarmos a
   celula como uma unidade de processamento biologico. Mas por que teria a
   evolucao optado em criar seres vivos compostos por diferentes unidades celulares?
   Por que a evolucao nao optou por desenvolver os seres unicelulares e deixa-los
   cada vez mais complexos e adaptados, porem permanecendo unicelulares?
   Pensando nessas respostas, verificamos que a evolucao optou realmente
   pelo paralelismo, e o quanto ela favoreceu os individuos unicelulares. Se
   observarmos os seres mais evoluidos, podemos constatar que todos sao
   pluricelulares. Mas poderiamos conjecturar que o fato dos seres terem mais de uma
   celula nao significa nada em termos de paralelismo, ou ainda que correlacao teria o
   paralelismo com isso. Se pensarmos em termos de microorganismos, o conceito de
   paralelismo nao e tao obvio, mas e se pensarmos num mamifero ?
   No caso de um mamifero qualquer, cada uma dos bilhoes de celulas possui
   o mesmo programa genetico e funcoes independentes, sem falar ainda nos
   107
   CAPITULO 4
   processos fisiologicos tais como respiracao, reproducao, excrecao, etc. Se
   pensarmos agora em termos de orgaos, o paralelismo fica ainda mais obvio.
   Qualquer mamifero possui uma serie de orgaos, responsaveis por uma
   determinada tarefa essencial a vida. Estes, por sua vez, sao compostos por celulas
   operando em paralelo, e ainda exercem suas funcoes paralelamente em relacao
   aos outros demais orgaos. Como exemplo, podemos pensar no coracao, pulmao,
   orgaos do sistema digestivo e sensorial, todos executando suas tarefas no mais
   absoluto paralelismo. Podemos concluir que os seres pluricelulares sao sistemas de
   vida paralelos, e que quanto maior o seu grau de evolucao, maior a escala de
   paralelismo envolvida.
   Agora que concordamos com o paralelismo envolvendo os seres
   pluricelulares, voltamos a perguntar: Se os seres unicelulares satisfazem a
   condicao basica de vida, por que razao a evolucao optou pelo desenvolvimento de
   seres paralelos (pluricelulares) ? Por que nao existem seres unicelulares com alto
   grau de evolucao ? A resposta parece ser um conjunto de fatores, envolvendo a
   natureza quimica e fisica da vida. Infelizmente nosso conhecimento ainda e muito
   limitado, e nao sabemos como se comportaria a vida em condicoes adversas a
   nossa. Nao sabemos nem ao menos se existe vida evoluida fora da terra. Nao
   sabemos responder se existe apenas um universo, se as leis da fisica regem nosso
   universo como um todo ou ainda se existe outro ou outros universos. Agora,
   hipoteticamente falando, se houver outro universo, a probabilidade das leis fisicas
   serem exatamente iguais as nossas e remota. Poderia em situacoes adversas, a
   natureza desenvolver vida com alto grau de evolucao sem a multiplicacao de
   unidades basicas de vida ? Ou seja poderia a natureza escolher como caminho de
   evolucao seres unicelulares?
   As respostas a essas perguntas e conjecturas parecem estar longe do
   nosso alcance. No entanto, na natureza nada e por acaso, bilhoes de anos de
   evolucao nao foram em vao e, como a natureza optou pelo paralelismo em massa,
   o melhor a fazer e compreender e estudar suas vantagens.
   Compreendemos que a natureza encontrou no paralelismo celular um otimo
   mecanismo na busca da complexidade, adaptacao e evolucao, mas aonde entraria
   a visao nesse contexto ? Por que estaria a natureza preocupada com sistemas de
   visao paralelos ?
   Como comentamos anteriormente a visao esta ligada a necessidade dos
PA seres vivos de obter informacoes do meio. Quando individuos competem no mesmo
   108
   OS CAMINHOS PARALELOS DA VISAO
   habitat, e concorrem pela alimentacao, qualquer informacao a esse respeito e vital
   para a sobrevivencia, e aquele que obtiver mais informacao sera favorecido na luta
   da sobrevivencia. Ate este ponto apenas a qualidade da informacao foi levada em
   conta, no entanto a situacao e um pouco diferente: alem da qualidade, um outro
   fator crucial nessa questao e a velocidade, pois alem de saber onde esta e como
   chegar ate o alimento, e necessario tambem que o individuo obtenha essa
   informacao antes dos demais. Vamos imaginar duas especies concorrentes,
   disputando o mesmo alimento escasso. Supondo que a principal fonte de
   informacao de ambas seja a visao, e ainda que uma das especies possua um
   sistema de visao lento e a outra um sistema de visao veloz. Se a diferenca basica
   entre as duas especies fosse essa qual sobreviveria ? Parece-nos bastante obvio
   que a especie que obtivesse a informacao de modo lento pereceria, uma vez que
   os concorrentes chegariam ao alimento antes.
   A necessidade de velocidade na percepcao visual se torna ainda mais critica
   quando levamos em conta a disputa entre predador e presa. Neste caso, e
   fundamental para ambos, presa e predador, obter informacoes a respeito de seu
   oponente. Embora a visao nao seja a unica fonte de informacao numa tal disputa,
   que conta com outros estimulos (olfato, audicao, etc.), podemos dizer que a
   informacao pela visao ainda assim tem uma relevancia fundamental, e ate mesmo
   primordial em algumas especies. E claro que a natureza ao longo desses anos tem
   encontrado diversos mecanismos para contornar e iludir o sistema de informacao
   do oponente, como a camuflagem, mas a velocidade do reconhecimento e
   localizacao da presa ou do predador e fundamental para a sobrevivencia.
   Como vimos nos capitulos anteriores, a historia da computacao demonstra
   que a resposta para o desempenho de sistemas de informacao artificiais e o
   paralelismo. Desde sua opcao pelo paralelismo, no desenvolvimento de seres
   pluricelulares, a natureza se tornou mestra na arte de paralelizar, nao seria de se
   espantar que ela usasse essa mesma arte para aprimorar os sistemas de visao
   biologicos, e e exatamente isso que o estudo da visao tem constatado. Neste
   capitulo apresentaremos uma revisao sobre os sistemas de visao biologicos, com
   enfoque nos primatas, e finalizaremos apresentando alguns estudos que
   demonstram a adocao do paralelismo ja nas primeiras fases do processo visual.
   Visao artificial e hoje um tema de pesquisa de ponta, e tentamos a todo
   custo desenvolver sistemas artificiais de visao. No entanto, por maior esforco que
   realizemos e por maior o numero de areas cientificas envolvidas, nao conseguimos
   109
   CAPITULO 4
   sequer igualar a eficiencia de nossos sistemas com o sistema de visao dos seres
   mais primitivos. Tendo a natureza encontrado no paralelismo uma escolha ao longo
   de bilhoes de anos, por que nos, que possuimos um conhecimento tao limitado
   (funcionamento cortical), iriamos discordar?
   4.4 - O ESTUDO DO CEREBRO E DA VISAO
   Embora a ciencia tenha se esforcado arduamente durante todo este seculo,
   o cerebro ainda permanece uma caixa preta. Se considerarmos o estudo do
   cerebro como um livro, nosso conhecimento cientifico atual corresponderia apenas
   as primeiras paginas. Devemos observar a grande complexidade envolvida nesta
   questao. A uma primeira instancia o estudo do cerebro pode parecer pertencer a
PA algumas poucas areas cientificas, mais especificamente a areas fundamentadas
   em biologia. No entanto, uma tendencia cientifica atual vem unindo diversas areas
   na construcao do imenso quebra-cabeca no qual se relacionam este estudo. Assim
   sendo, o estudo do cerebro esta reunindo, concentrando e integrando diversas
   areas cientificas, possuidoras de caminhos historicos bastante diferentes. Nenhum
   outro tema cientifico reuniu areas tao distintas, e talvez, gracas ao desafio de
   desvendar nosso proprio cerebro, nossa ciencia altere seu curso separatista na
   historia.
   4.4.1 - AS ESPECIALIZACOES FUNCIONAIS CORTICAIS
   Ate o seculo passado o cerebro era visto como uma caixa preta, dividida
   apenas em duas partes: areas de projecao e areas de associacao [Machado, 1993].
   Na metade do seculo passado o neurologista frances Pierre Paul Broca, iniciou um
   estudo que expandiria a divisao dualista do cerebro [Broca, 1861]. Atraves de um
   caso clinico de um paciente que perdeu a capacidade de falar e, realizando
   autopsia apos seu obito, Broca constatou que uma area especifica do cerebro era
   responsavel pelo caso clinico, mas foi duramente criticado pelo meio cientifico de
   sua epoca. Porem seu trabalho introduziu a nocao de que o cortex cerebral era
   composto de areas distintas diferenciadas por sua especializacao. No entanto, a
   crenca na dualidade cerebral perduraria, especialmente pela dificuldade de localizar
   regioes anatomicamente distintas no cortex, assim como a questao da plasticidade
   cerebral.
   110
   OS CAMINHOS PARALELOS DA VISAO
   Uma grande diversidade de trabalhos cientificos viriam a consolidar a
   divisao do cortex em areas distintas classificadas mediante a funcao, entre eles
   devemos destacar os trabalhos de Fritsch e Hitzig [Fritsch & Hitzig, 1870], que
   conseguiram provocar movimentos em determinadas partes do corpo atraves de
   estimulos eletricos em areas especificas no cortex do cao.
   A divisao do cortex em areas funcionais possibilitou que a classica
   estrategia de dividir e conquistar fosse aplicada a neurociencia, permitindo a
   canalizacao de diferentes estudos relativos a funcao de suas areas determinadas.
   Com isso, ao estudarmos uma determinada funcao especifica do cortex, podemos
   concentrar esforcos na sua regiao cortical correspondente.
   4.4.2 - ANALISE MULTI-ESCALA
   Uma questao muito importante no estudo cortical e a sua complexidade
   multi-escalar. O cortex deve ser explorado sob diferentes prismas relativos a
   escala. Deste modo, do ponto de vista multi-escala, podemos dividir a analise
   cortical em tres partes [Costa, 1996]:
   Microscopica: Dentro dessa abordagem o cortex e estudado em nivel
   celular. Sao estudadas as celulas que o compoe: neuronios, fibras e glias. Alem do
   comportamento do estudo histologico dos componentes de cada celula, nessa
   escala sao ainda estudadas as ramificacoes dendriticas e axonais. As tecnicas de
   estudo nessa escala sao histologicas / anatomicas (empregam corantes,
   dissecacoes e sao feitas in vitro).
   Intermediaria: Nesta classe sao estudados grupos de celulas e suas
   conexoes. O comportamento das arvores dendriticas e como sao compostas as
   redes neurais. Sao ainda exploradas as conexoes neurais dentro de uma regiao
   cortical. Um exemplo do estudo cortical nessa escala sao as visualizacoes de redes
   neurais e de seu comportamento nas regioes V1 e V2 do cortex visual. Atraves das
   tecnicas de citoarquiteturas, citochromo oxidase e mieloarquiteturas e possivel a
PA visualizacao das sub-regioes de cataventos em V1 (blobs e inter-blobs) e das sub-
   regioes em forma de faixas em V2 ("thin stripe", "inter stripe" e "thick stripe") [Zeki, 1993] [Hubel, 1995].
   Macroscopica: A esta categoria pertence o estudo de regioes inteiras do
   cortex. Embora essa escala possa ser explorada do ponto de vista anatomico, o
   maior interesse reside na sua pesquisa fisiologica. A principal caracteristica da
   111
   CAPITULO 4
   exploracao fisiologica e que esta envolve aspectos funcionais da parte estudada e
   sao executadas in vivo. Assim, temos como exemplo da escala macroscopica os
   estudos cirurgicos (como o de Broca), tomografia por ressonancia magnetica e
   PET (Positron-Emition Tomography).
   Devemos lembrar que nao existe uma divisao distinta entre as escalas.
   Ninguem sabe exatamente onde uma escala comeca ou termina. Essa
   classificacao tem como unico objetivo apresentar as caracteristicas multi-escala do
   estudo do cortex.
   4.4.3 - VISUALIZANDO O CEREBRO ATRAVES DA VISAO
   Como vimos anteriormente, o cerebro sempre foi visto como uma caixa
   preta (em especial o cortex). Do ponto de vista anatomico tradicional, quando
   analisamos o cortex, este se apresenta como uma estrutura uniforme,
   diferenciando-se apenas pelas depressoes, intituladas sulcos, que delimitam os
   giros e lobos. Entretanto, a existencia dos sulcos nao dizem nada em termos da
   funcionalidade do cortex, eles sao apenas uma estrategia utilizada pela natureza
   que permite aumento da superficie sem grande aumento do volume (no homem,
   cerca de dois tercos do cortex esta "escondido" pelos sulcos) [Machado, 1993].
   Desta forma, o cortex apresenta-se singular: uma unica materia uniforme enrugada
   (sulcos e giros). Devido a essa caracteristica uniforme, Semir Zeki [Zeki, 1993]
   sugere que, embora o cortex seja diferenciado pela funcionalidade de cada regiao,
   deva existir uma estrategia unica ou geral para o seu funcionamento. Deste modo,
   se explorarmos e desvendarmos o funcionamento de uma regiao cortical, teremos
   conhecimentos suficientes para desvendar as demais regioes.
   Nessas ultimas decadas, a visao recebeu uma atencao especial. Nenhum
   outro sentido ou regiao cerebral foi mais explorado do que a visao. Embora tenha
   sido alvo da pesquisa cientifica, tem revelado muito pouco sobre o seu
   funcionamento.
   Assim, o estudo da visao esta trazendo evidencias de como funciona o
   cerebro como um todo, e aproveitando o trocadilho proposto pelo titulo do livro A
   Vision of the Brain, de Semir Zeki [Zeki, 1993], fornecendo uma poderosa
   ferramenta de visualizacao do funcionamento do cerebro.
   Embora esta subsecao seja destinada ao estudo do cerebro, vamos a partir
   daqui enfocar a visao: o sentido e a regiao mais explorados do cortex.
   112
   OS CAMINHOS PARALELOS DA VISAO
   4.4.4 - VISAO - UMA AREA MULTIDISCIPLINAR
   Dentre as areas do conhecimento cientifico, talvez a que envolva a maior
   diversidade de disciplinas seja a visao. E facil verificar esta suspeita. O estudo da
   visao pode ser dividido em visao natural e artificial. Em visao natural, os objetos de
   estudos sao os sistemas biologicos de visao, ao passo que no segundo caso,
   temos as ciencias exatas tentando reproduzir artificialmente o processo de
   interpretacao visual do mundo realizado pelos sistemas biologicos. O verdadeiro
   fascinio dessa ciencia ocorre na integracao de suas duas partes: visao natural e
PA artificial, integrando as ciencias exatas com as ciencias biologicas. Se por um lado
   a biologia tenta desvendar a arquitetura e funcionamento do cerebro, a cibernetica
   desenvolve modelos baseados nos sistemas biologicos e experimentam sistemas
   artificiais. Embora aparentemente estejam percorrendo caminhos diversos, a
   integracao ocorre na realimentacao do conhecimento cientifico.
   No entanto, a visao e muito mais complexa e contem um numero maior de
   areas de conhecimento envolvidas do que a versao dualista anteriormente
   apresentada. Para explorar algumas dessas areas envolvidas, vamos considerar a
   definicao de visao utilizada por David Marr. Segundo Marr [Marr, 1982], visao e o
   processo de descobrir atraves de imagens o que esta presente em nosso mundo e
   suas respectivas posicoes. Seguindo essa abordagem, o primeiro estagio da visao
   e a aquisicao de imagens. Assim, os olhos captam energia eletromagnetica na
   forma de luz e a converte em impulsos nervosos atraves de celulas fotorreceptoras.
   A visao e um mecanismo neurologico, baseado em estimulos do universo fisico,
   necessitando deste modo, para sua compreensao de conhecimentos em ambos
   universos cientificos (compreensao fisica e neurologica).
   Nesse patamar a complexidade da questao fica bastante evidente, assim
   como a diversidade de areas cientificas envolvidas. Num primeiro plano temos as
   neurociencias, atraves das quais sao estudados os mecanismos neurais. O
   entendimento dos processos de percepcao, compete a psicologia, assim como
   entramos em questoes de interesse filosofico quando levantamos a questao da
   consciencia envolvida em todo o processo. Se ponderarmos sobre a questao do
   comportamento do sistema visual em resposta ao ambiente, assim como do
   processo evolutivo que levou ao desenvolvimento do sistema de visao natural,
   devemos considerar a ecologia e o darwinismo. Encerrando o processo do estudo
   da visao temos a matematica e a fisica desenvolvendo os modelos formais das
   113
   CAPITULO 4
   interpretacoes encontradas para o processo visual e finalmente a computacao
   auxiliando no desenvolvimento de experimentos, fazendo analises abstratas ou nao
   das simulacoes e modelagens, e desenvolvendo sistemas artificiais
   correspondentes (Figura 4.1).
   Visao
   Matematica
   Ecologia
   -
   Fisica
   Neurociencia
   Ciencia da
   Filosofia
   Computacao
   Psicologia
   Fig. - 4.1 - Visao, uma ciencia formada pela integracao de muitas outras.
   4.5 - INTRODUCAO A NEUROCIENCIA
   Nesta secao iremos discutir sucintamente as bases da neurociencia, para
   que possamos no contexto desse capitulo discorrer sobre o funcionamento do
   cortex visual. O sistema nervoso e constituido basicamente por dois tipos de
   celulas: celulas neurais ou neuronios e glias ou neuroglias. Enquanto os neuronios
   sao celulas especializadas na conducao e processamento de sinais eletroquimicos,
   as glias tem como finalidade o revestimento ou isolamento, modulacao da atividade
PA neural e defesa [Machado, 1993]. Nesta secao iremos enfocar nossa discussao nos
   neuronios, uma vez que estamos nos limitando ao perfil de processamento de
   informacoes.
   4.5.1 - SISTEMA NERVOSO
   Em termos evolutivos, a complexidade do sistema nervoso dos seres vivos
   determina sua escala hierarquica. Assim, quanto mais primitivo, mais rudimentar e
   o seu sistema nervoso, se comparado com o sistema nervoso dos vertebrados e
   114
   OS CAMINHOS PARALELOS DA VISAO
   mais ainda se compararmos com os representantes do apice da piramide evolutiva,
   os primatas. No entanto, todos eles possuem uma unidade fundamental, as celulas
   neurais ou neuronios [Kovacs, 1997]. Os sistemas nervosos sao constituidos por
   aglomerados dessas celulas (ganglios, nucleos e cortices). Atraves de seus
   sistemas nervosos, os seres vivos sao capazes de agir e reagir a eventos no
   ambiente, e muitas vezes ate mesmo a modela-lo.
   O sistema nervoso dos vertebrados costuma ser dividido em duas porcoes
   com caracteristicas distintas: o sistema nervoso central, localizado dentro do
   esqueleto axial (cavidade craniana e canal vertebral) e o sistema nervoso periferico
   localizado fora do esqueleto axial. O sistema nervoso central e formado pelo
   cerebro, medula espinhal e retina do sistema visual, ao passo que o periferico e
   composto pelas fibras aferentes e suas conexoes com os orgaos sensoriais e pelas
   fibras eferentes, conexas com os musculos [Machado, 1993] [Costa, 1996]. A
   Figura 4.2 apresenta um esquema detalhado das divisoes do sistema nervoso.
   Sistema
   Nervoso
   Sistema
   Sistema
   Nervoso
   Nervoso
   Central
   Periferico
   Encefalo
   Medula
   Ganglios e
   Nervos
   terminacoes
   nervosas
   Cerebelo
   Cerebro
   Tronco
   Espinhais
   Cranianos
   Telencefalo
   Diencefalo
   Ponte
   Bulbo
   Mesencefalo
   Fig. - 4.2 - Subdivisoes do Sistema Nervoso [Costa, 1996].
   Neste trabalho estaremos mais interessados no cerebro, que e composto
   pelo diencefalo e telencefalo. Na Figura 4.3 encontramos uma ilustracao das
PA divisoes do encefalo onde podemos encontrar essas duas regioes. O diencefalo fica
   localizado na base do telencefalo. Um dos componentes do diencefalo e o talamo,
   que e composto por duas regioes localizadas simetricamente em sua porcao latero-
   dorsal. A grande maioria dos caminhos sensoriais fazem conexoes ao talamo, entre
   115
   CAPITULO 4
   eles o caminho visual, uma vez que o nucleo geniculado lateral faz parte do
   complexo do talamo.
   Telencefalo
   Diencefalo
   CEREBRO
   Mesencefalo
   ENCEFALO
   Ponte
   Tronco
   Bulbo
   Encefalico
   Cerebelo
   Fig. - 4.3 - Divisoes do Encefalo.
   O telencefalo por sua vez e composto pelos dois hemisferios cerebrais
   (direito e esquerdo) e pelo corpo caloso, atraves do qual os hemisferios sao
   interconectados. Os hemisferios podem ser divididos em duas partes: o cortex
   cerebral e o centro branco medular. O cortex e aonde estao concentrados a grande
   maioria dos neuronios de todo o sistema nervoso, tambem denominado de materia
   cinza, que possui cerca de 2mm de espessura nos mamiferos. Devido a sua
   natureza superficial, o cortex e alojado dentro da cavidade craniana assemelhando-
   se a um jornal amassado. Desta maneira, formam-se diversos sulcos, giros e lobos
   (Figura 4.4). Conforme ja comentado, essa foi uma estrategia encontrada pela
   natureza a fim de que o cortex ocupasse uma area menor e possibilitando deste
   modo ficar contido dentro do cranio. O cortex reveste o centro branco medular, que
   e constituido pelos axonios que interconectam as regioes corticais e tambem pela
   conexao das regioes corticais com os centros subcorticais (ex: talamo, que funciona
   como uma estacao de distribuicao dos sinais sensoriais).
   116
   OS CAMINHOS PARALELOS DA VISAO
   Sulco central
   Lobo parietal
   Lobo frontal
   Sulco
   parieto-occipital
   Lobo occipital
   Lobo temporal
   Sulco lateral
   Cerebelo
   Fig. - 4.4 - Lobos e sulcos corticais.
   4.5.2 - NEURONIOS
   A Figura 4.5 apresenta um neuronio tipico transmitindo sinais eletroquimicos
   a outras tres celulas neurais. Os neuronios sao celulas especializadas na conducao
   e processamento de sinais eletroquimicos. Embora exista uma grande quantidade
   de classes de neuronios, que sao agrupados atraves de suas caracteristicas
PA funcionais e morfologicas, a base de seu comportamento eletroquimico e a mesma
   para todas as classes [Costa, 1996]. Os neuronios sao delimitados por uma
   membrana celular e sao constituidos basicamente de um corpo celular ou soma,
   um filamento alongado denominado axonio e dendritos (caracterizados pela sua
   natureza arborizada).
   As dimensoes, formas e localizacao do soma em relacao a arvore dendritica
   variam muito entre os diversos tipos de neuronios. Os diametros podem ir da ordem
   de 2 microns a mais de 0,5 milimetros. Em geral os neuronios apresentam apenas
   um unico axonio. Sua funcao basica e a transmissao de sinal, resultante do
   processamento de informacoes recebidas pelos dendritos, atraves de pulsos
   eletricos. O axonio se caracteriza por ser um filamento de diametro uniforme que se
   projeta do neuronio percorrendo distancias que vao desde centenas de microns ate
   mais de um metro. O diametro dos axonios esta relacionado a velocidade de
   transmissao: quanto maior o diametro, maior e a taxa de transmissao do sinal
   [Costa, 1996]. No Sistema Nervoso Periferico, axonios aferentes [Machado, 1993]
   transportam a informacao proveniente dos sensores para o Sistema Nervoso
   117
   CAPITULO 4
   Central. O caminho inverso tambem ocorre, quando as informacoes sao
   transmitidas pelos eferentes ao organismos. Os axonios podem se agrupar em
   feixes. Quando agrupados no Sistema Nervoso Periferico, esse conjunto recebe o
   nome de troncos nervosos ou nervos, que podem conter desde poucas unidades a
   dezenas de milhares de axonios. No Sistema Nervoso Central, os agrupamentos
   sao denominados de tractos [Kovacs, 1997].
   Fig. - 4.5 - Estrutura de um neuronio tipico.
   Nos vertebrados a maioria dos axonios sao revestidos por uma cobertura
   gordurosa denominada de capas de mielina (bainha de mielina). Essa substancia e
   produzida por celulas neurogliais de Schwamm [Kovacs, 1997]. Este tipo de arranjo
   permite o isolamento eletrico das fibras aumentando a sua velocidade de
   transmissao e diminuindo seu diametro. Estima-se que nosso cerebro seria dez
   vezes maior caso nao fosse adotada as capas de mielina [Dowling, 1992]. Os
   invertebrados, em geral, nao possuem esse mecanismo, o que indica que a
   mielinizacao dos axonios foi um passo evolutivo, que aumentou a velocidade de
   propagacao dos impulsos nervosos e diminuiu a dimensao das fibras nervosas,
   oferecendo uma significativa vantagem competitiva.
   Se por um lado os axonios tem como funcao a transmissao dos impulsos
   nervosos, cabe aos dendritos a sua recepcao. Os dendritos sao prolongamentos
   filamentares de arranjo arboreo, constituindo a parte receptiva dos neuronios. Sua
   natureza de ramificacao arborea tem como finalidade possuir uma ampla area para
   a recepcao dos sinais. A transmissao do sinal entre os axonios e dendritos ocorre
   118
   OS CAMINHOS PARALELOS DA VISAO
   em estruturas de contato denominadas sinapses. Embora as sinapses
   frequentemente ocorram entre axonios e dendritos (axodendriticas), elas podem
   ocorrer tambem entre axonios e a soma (axossomaticas), e em casos mais raros
   entre: axonio-axonio (axoaxonicas), dendrito-dendrito (dendrodendriticas), dentrito-
   soma (dendrossomaticas), soma-soma (somatossomaticas), soma-dendrito
   (somatodendriticas) e soma-axonio (somatoaxonicas) [Machado, 1993].
   (a)
   (b)
PA Fig. - 4.6 - (a) Ilustracao de uma sinapse. (b) Fenda sinaptica. [Dowling, 1992]
   A Figura 4.6a apresenta uma sinapse. Nela podemos observar duas
   membranas: pre-sinaptica e pos-sinaptica. A membrana pre-sinaptica transmite o
   sinal, enquanto que a pos-sinaptica o recebe. Ambas as membranas sinapticas sao
   separadas por uma fenda denominada de fenda sinaptica, que podemos observar
   na Figura 4.6b. Quando um pulso nervoso chega pelo axonio ate a membrana pre-
   sinaptica, esta libera vesiculas com mediadores quimicos, denominados de
   neurotransmissores (Figura 4.6), que atraves da fenda sinaptica, chegam a
   119
   CAPITULO 4
   membrana pos-sinaptica, provocando alteracao em sua polaridade. Uma
   caracteristica fundamental da sinapse e a de propagar sinais em um unico sentido:
   da membrana pre-sinaptica para a membrana pos-sinaptica.
   Quanto a funcao, podem ocorrer dois tipos de sinapses: excitatoria e
   inibitoria. De acordo com as caracteristicas quimicas dos neurotransmissores pode
   haver uma despolarizacao ou hiperpolarizacao da membrana pos-sinaptica, onde a
   despolarizacao desta e denominada de potencial pos-sinaptico excitatorio (PPSE) e
   a hiperpolarizacao denominada potencial pos-sinaptico inibitorio (PPSI) [Coelho,
   1998]. A Figura 4.7 ilustra as sinapses excitatoria e inibitoria assim como as PPSE
   e PPSI.
   Cada sinapse (PPSE ou PPSI) produz um efeito minimo no neuronio. No
   entanto os neuronios apresentam muitas sinapses, segundo Kovacs [Kovacs, 1997]
   a ordem de sinapses e de 5000 nos neuronios motores da medula e pode chegar
   ate mesmo a 95000 nas celulas de Purkinje (neuronio do cortex cerebelar) e que
   para cada milimetro cubico do cortex cerebral existam 105 neuronios e 109
   sinapses. Assim, o neuronio funciona como um integrador de sinais, de modo que o
   conjunto dos sinais sinapticos determinara a resposta do neuronio.
   Fig. - 4.7 - Sinapses excitatoria, Sinapses inibitoria, PPSE e PPSI.
   Cada sinapse pode produzir polarizacoes diferentes, que sao determinados
   por um conjunto de fatores, tais como: tamanho da sinapse, quantidade de
   neurotransmissores liberados, distancia do ponto sinaptico ao soma e tipo da
   120
   OS CAMINHOS PARALELOS DA VISAO
   sinapse (PPSE - despolarizacao e PPSI - polarizacao) [Kovacs, 1997] [Costa,
   1996]. Para que o neuronio responda ao estimulo, a somatoria da polarizacao das
   sinapses deve produzir uma despolarizacao suficiente para ultrapassar um limiar,
   conhecido como limite de disparo. Acontecendo isso, a membrana despolariza em
   questao de microsegundos muito alem do limiar, e o estimulo e transmitido pelo
   axonio, fazendo que deste modo a polarizacao da membrana retorne lentamente
   (em relacao ao disparo) a sua polarizacao original. Este fenomeno e denominado
   potencial de acao. A velocidade de transmissao do impulso nervoso e de algumas
   dezenas de centimetros por segundo em fibras nao mielinizadas e ate 150 metros
   por segundo em fibras mielinizadas [Kovacs, 1996].
   Existe um grande numero de modelos matematicos de neuronios e redes
   neurais. A motivacao inicial da modelagem de neuronios artificiais ocorreu em 1943
   com o trabalho de McCul och e Pitts [McCulloch & Pitts, 1943]. Por algumas
   decadas essa ideia nao teve muitos seguidores ate emergir novamente na decada
   de 80 com forca renovada nas linhas de pesquisa. A Figura 4.8 apresenta um
   modelo matematico tipico de um neuronio. Nele os estimulos X1...Xn sao integrados
   com o produto interno de seus respectivos pesos W produzindo s, que sofre uma
PA transformacao nao linear implementada pela funcao f. Transpondo essa
   representacao para o modelo biologico temos cada entrada X representada por
   uma sinapse, que apresenta "pesos" diferentes sob determinados aspectos [Costa,
   1996], cuja despolarizacao e integrada pela soma celular que, caso exceda o limiar,
   dispara um impulso nervoso representado por y.
   X1
   W1
   X2
   .
   W2
   f
   y
   .
   s
   r r
   .
   y = f ( xT w
   . )
   Wn
   Xn
   Fig. - 4.8 - Modelo matematico tipico de uma celula neural.
   121
   CAPITULO 4
   4.6 - O CAMINHO VISUAL
   Assim como os demais sentidos, a visao tem como objetivo a percepcao,
   compreensao e ate mesmo (nos seres mais evoluidos) a modelagem do meio
   ambiente e dos objetos a sua volta. A diferenca basica entre a visao e os demais
   sentidos e a quantidade de informacoes que sao adquiridas por este sentido e sua
   complexidade. A importancia, assim como sua complexidade, e tamanha que 60%
   de todo o mecanismo neural do cortex e utilizado para esse sentido [Hubel, 1995]
   [Tovee, 1996] [Levine, 1985]. Nesta secao vamos discutir o caminho visual, que se
   inicia com a luz refletindo nos objetos e sendo transformada em impulsos nervosos
   pelos fotorreceptores e finaliza com a abstracao e percepcao dos sinais nervosos
   processados pela retina e cortex visual primario.
   4.6.1 - CAPTANDO A LUZ
   Os olhos tem como funcao basica captar a luz e focaliza-la na retina, uma
   fina camada localizada na parede posterior interna composta de neuronios
   especializados em converter os sinais eletromagneticos em neurologicos. Entende-
   se por luz visivel a regiao do espectro da radiacao eletromagnetica visivel pelos
   seres humanos. Embora possua um sistema de visao eficiente, o homem e cego a
   grande maioria das ondas eletromagneticas. A Figura 4.9 apresenta o espectro da
   radiacao eletromagnetica, destacando a porcao percebida pelo nosso sistema de
   visao.
   Fig. - 4.9 - Espectro da radiacao eletromagnetica com destaque para a porcao
   visivel.
   122
   OS CAMINHOS PARALELOS DA VISAO
   A Figura 4.10 apresenta a estrutura geral do olho humano. O olho apresenta
   funcionamento semelhante a uma camara fotografica, atraves do seu sistema de
   lentes, composto pela cornea e pelo cristalino, focaliza a imagem na retina. A luz e
PA inicialmente refratada pela cornea, que atraves de sua superficie concava, converte
   os raios luminosos para o interior do olho. Apos os raios refratados terem passado
   pela cornea e pelo humor aquoso, atingem a superficie curva anterior da lente do
   cristalino e entao a superficie curva posterior (lente convexa). Deste modo os raios
   luminosos sao refratados em tres locais diferentes e atraves dessas refracoes sao
   convergidos e focados na retina. O cristalino e flexivel e pode ser alongado e
   comprimido pela acao dos musculos ciliares. Atraves dessa alteracao da forma do
   cristalino a dioptria do sistema optico e alterada, possibilitando focar objetos
   localizados em distancias diferentes. Enquanto o cristalino e responsavel pelo
   ajuste fino do foco, a cornea e a maior responsavel pela convergencia dos raios,
   cerca de 70% da refracao e realizada por ela [Tovee, 1996]. Uma outra forma de
   alterar a dioptria de um sistema optico seria o deslocamento do cristalino, do
   mesmo modo como e utilizado nas camaras fotograficas. Embora esse metodo nao
   seja utilizado pelos primatas, alguns animais, como por exemplo a ra, adotam essa
   estrategia [Schmidt, 1980].
   Fig. - 4.10 - Olho humano, corte lateral.
   O globo ocular e sustentado por tres pares de musculos, que sao
   responsaveis por sua movimentacao, conforme mostra a Figura 4.11. Os musculos
   de cada pa trabalham em oposicao e sao responsaveis pelo movimento em relacao
   123
   CAPITULO 4
   a tres planos perpendiculares. Os movimentos do globo ocular possuem precisao
   da ordem de um minuto de arco e podem fornecer um angulo de visao de no
   minimo 140o [Braham, 1996]. O sistema de movimentacao do globo ocular trabalha
   em conjunto com uma colecao de reflexos precisamente sintonizados, incluindo os
   que controlam a posicao da cabeca [Hubel, 1995].
   (a)
   (b)
   Fig. - 4.11 - Musculos de sustentacao do globo ocular. (a) Globo ocular vista
   dorsal. (b) Disposicao dos musculos na cavidade ocular.
   4.6.2 - A RETINA
   A retina, localizada na parede posterior do olho, recebe toda a luz captada
   pelo sistema optico. Uma vez focalizada a imagem na retina, inicia-se o processo
   de transformacao da luz em impulso nervoso.
   A retina e uma parte do cerebro que se desprendeu atraves da evolucao e
   permaneceu conectada atraves do nervo optico. Ela e composta por tres camadas
   de corpos de celulas nervosas separadas por duas camadas de sinapses,
   compostas por axonios e dendritos. As estruturas da retina encontram-se altamente
   organizadas. A retina tem a forma de uma placa ou camada e encontra-se
   depositada na parede posterior do olho, possuindo uma espessura de
   aproximadamente 0,25 mm [Hubel, 1995]. A Figura 4.12 apresenta uma ilustracao
   contendo um olho e a retina ampliada apresentando suas estruturas. Curiosamente
   a ultima camada da retina e composta pelos fotorreceptores, celulas nervosas
   sensoriais capazes de converter a luz em sinal nervoso. Deste modo a luz
   atravessa todas as demais estruturas da retina ate chegar nos fotorreceptores.
   124
   OS CAMINHOS PARALELOS DA VISAO
   (a)
   (b)
   Fig. - 4.12 - Corte da retina (a) e mapa da distribuicao vascular dos capilares
PA na macula (b).
   A retina costuma ser considerada em duas camadas: a neurossensorial e o
   epitelio pigmentar. A retina sensorial e uma estrutua celular complexa, estratificada,
   composta pelas celulas fotorreceptoras, ganglionares, interneurais (bipolar,
   horizontal, amacrina e interplexiforme) e glias. A retina sensorial subdividi-se em
   duas partes: (i) interna, englobando a membrana limitante ate a nuclear interna
   (todas as celulas de processamento neurologico descritas anteriormente) e (i )
   externa constituindo da plexiforme externa aos fotorreceptores. A retina sensorial
   interna e vascularizada a partir dos vasos sanguineos oriundos da arteria central da
   retina, ao passo que a retina externa e avascular, sendo nutrida pela coroide (a
   nutricao atravessa o eptelio pigmentar) [Bruno, 1999].
   4.6.2.1 - OS FOTORRECEPTORES
   Os fotorreceptores sao celulas nervosas adaptadas, responsaveis pela
   conversao do sinal luminoso em sinal nervoso. Existem dois tipos de
   fotorreceptores na retina: os cones e os bastonetes. A retina humana contem cerca
   de 120 milhoes de bastonetes e 6 milhoes de cones [Tovee, 1996]. A Figura 4.13
   apresenta um grafico que ilustra a distribuicao dos cones e bastonetes ao longo da
   retina. Como podemos observar, os cones estao concentrados na regiao central da
   retina. Sua concentracao apresenta um pico numa regiao denominada fovea. Os
   bastonetes por outro lado, se concentram mais nas regioes perifericas, tendo uma
   presenca praticamente nula na regiao foveal.
   125
   CAPITULO 4
   2m
   Ponto cego
   m
   por
   es
   Bastonetes
   onet
   s e bast
   cone
   Cones
   de
   ero
   Num
   Fovea
   Periferia nasal
   Periferia temporal
   Fig. - 4.13 - Distribuicao dos cones e bastonetes ao longo da retina.
   Ainda observando a distribuicao dos fotorreceptores na retina, podemos
   observar o ponto cego, que constitui a regiao por onde chega a vascularizacao ate
   a retina e tambem a regiao por onde sai o nervo optico, conjunto de axonios que
   levam as informacoes processadas na retina ao cortex.
   Alem da distribuicao ao longo da retina, os cones e bastonetes tambem se
   diferenciam quanto a forma e funcao. Os bastonetes sao mais sensiveis a luz que
   os cones, possuindo uma maior percepcao para locais com pouca iluminacao ou
   visao noturna, entretanto sua resolucao e menor. Os cones por outro lado sao os
   sensores utilizados para a visao diurna com alta precisao. Alguns primatas, entre
   eles o homem, possuem tres tipos de cones, sensiveis a diferentes frequencias
PA eletromagneticas: ondas curtas (azul), medias (verde) e longas (vermelho). Sendo
   assim, os cones sao responsaveis pela visao cromatica. A Figura 4.14 apresenta as
   curvas sensibilidade a frequencia para cada classe.
   A grande maioria dos cones se encontra na fovea, devido a este fato, essa
   regiao da retina e responsavel pela visao de precisao. Cerca de 5% a 10% do
   cones, respondem ao azul. Eles ficam distribuidos na regiao periferica da fovea,
   formando assim uma estrutura anular. Os cones que respondem ao vermelho e
   verde sao arranjados de forma bastante regular, estabelecendo padroes na retina.
   A razao entre os cones sensiveis ao vermelho e verde e de 2 para um [Tovee,
   126
   OS CAMINHOS PARALELOS DA VISAO
   1996].
   (%)
   rcao relativaso
   Ab
   Comprimento de onda (nm)
   Fig. - 4.14 - Sensibilidade dos tres tipos de cones da retina dos primatas.
   Bastonete
   Cone
   rodopsina
   rodopsina
   Terminacoes
   sinapticas
   (A)
   (B)
   Fig. - 4.15 - (A) Diagrama esquematico dos fotorreceptores (cones e
   bastonetes) [Tovee, 1996]. (B) Imagem microscopica apresentando os
   fotorreceptores (em destaque cone) [Dowling,1992].
   Tanto os cones quanto os bastonetes, possuem funcionamentos
   semelhantes, baseados em moleculas sensiveis a luz, intituladas rodopsinas. O
   conjunto das moleculas rodopsinas, localizadas no segmento exterior das celulas
   fotorreceptoras e responsavel por sua excitacao, um unico bastonete humano
   contem cerca de 100 milhoes de moleculas, que sao interligadas proximamente,
   127
   CAPITULO 4
   cuja distancia entre moleculas possui cerca de 20 nm [Tovee,1996]. A Figura 4.15a
   apresenta uma comparacao entre um cone e um bastonete em relacao a forma
   assim como a disposicao das moleculas de rodopsina e a Figura 4.15b apresenta
   uma imagem dos fotorreceptores.
   4.6.2.2 - RETINA SENSORIAL INTERNA
   Ha algumas decadas atras acreditava-se que a unica funcao da retina era
   converter a luz em sinais nervosos e transmiti-los para o cortex. No entanto,
   existem cerca de 126 milhoes de fotorreceptores na retina, cada um transmitindo
   informacoes sobre a luz absorvida em um determinado ponto da retina. A
   informacao e transmitida para o cortex atraves do nervo optico, que e o conjunto
   dos axonios das celulas ganglionares, e existem apenas 1 milhao deste. A relacao
   126 milhoes para 1 milhao, deixa bastante clara a existencia de processamento nas
   celulas da retina sensorial interna.
   As evidencias indicam que a retina realize os primeiros processamentos da
   informacao visual [Goldstein, 1989] [Hubel, 1995], destacando a deteccao de
PA bordas [Marr, 1982] [Bruce & Green, 1990]. Alem da deteccao de bordas, uma outra
   funcao importante implementada na retina e o inicio da divisao dos caminhos
   visuais (parvo e magno), que sera comentada mais adiante.
   A retina sensorial interna e formada por quatro tipos de celulas neurais:
   celulas bipolares, celulas horizontais, celulas amacrinas e celulas ganglionares (ver
   Figura 4.12). Embora essas celulas tenham sido vastamente estudadas, estaremos
   interessados neste trabalho nas celulas ganglionares, que sao a ultima camada de
   celulas nervosas na retina, sendo que seus axonios formam o nervo optico.
   Nas celulas ganglionares da retina de primatas foram encontrados dois tipos
   distintos de celulas : M e P (Magno e Parvo) [Shapley & Perry 1986]. As celulas M
   tem como caracteristicas um campo dendritico pequeno na regiao foveal, que
   aumenta em tamanho de forma linear quanto mais as celulas se distanciam da
   fovea ao passo que as celulas P sao muito mais numerosas e possuem um campo
   dendritico pequeno, que se mantem de tamanho constante ao longo de toda a
   retina. Essas celulas irao originar os caminhos Magnocelular e Parvocelular,
   caminhos independentemente correlacionados que percorrem quase todo o sistema
   visual. Conforme veremos em breve (Secao 4.6.3.1) as propriedade dos caminhos
   Parvocelular e Magnocelular sugerem uma correlacao direta entre as celulas
   ganglionares M e P e as duas classes de fotorreceptores (cones e bastonetes).
   128
   OS CAMINHOS PARALELOS DA VISAO
   4.6.2.3 - CAMPOS RECEPTIVOS DA RETINA
   O campo receptivo se caracteriza por uma regiao sensorial que influencia
   uma celula especifica. Os campos receptivos sao encontrados e estudados em
   diversos pontos do caminho visual. Na retina, os campos receptivos sao
   classicamente estudados a partir das celulas ganglionares. Deste modo cada celula
   ganglionar possui uma regiao na retina (fotorreceptores) que a influencia.
   On-Center
   Off-Center
   On-Off
   Estimulo
   Estimulo
   Centro
   Unico ponto
   Periferia
   Sentido
   preferencial
   Centro e
   Sentido
   periferia
   contrario
   (A)
   (B)
   (C)
   Fig. - 4.16 - Campos receptivos das celulas ganglionares da retina. (a) "On-
   Center" - excitacao na regiao central e inibicao na regiao periferica. (b) "Off-
   Center" - inibicao na regiao central e excitacao na regiao periferica. (c) "On-
   Off" - respostas a movimentos.
   Na retina os campos receptivos se caracterizam por formarem estruturas
   concentricas conhecidas como centro-periferia, apresentando basicamente tres
PA tipos quanto a funcionalidade: "On-Center", "Off-Center" e "On-Off". Na Figura 4.16
   temos exemplos das respostas das celulas em relacao aos estimulos em seus
   campos receptivos. As celulas com campos receptivos "On-Center" (Figura 4.16a)
   disparam quando o centro do campo receptivo e iluminado, ao passo que com as
   celulas com campos "Off-Center" (Figura 4.16b) ocorre justamente o contrario. As
   celulas com campos receptivos "On-Off" (Figura 4.16c) sao sensiveis ao
   movimento, respondendo quando um ponto luminoso percorre uma direcao e
   sentido preferencial [Dowling, 1992] [Coelho, 1998] [Costa, 1996].
   129
   CAPITULO 4
   E importante observar que os campos receptivos se sobrepoem, de modo
   que uma celula fotorreceptora da retina pode fazer parte de muitos campos
   receptivos de diferentes celulas ganglionares [Hubel, 1995]. Quanto ao tamanho
   dos campos receptivos, este difere de uma celula para outra, tendo em media
   tamanhos menores quando o campo receptivo esta nas regioes foveais e maiores
   na periferia. David Marr [Marr, 1982], descreve uma modelagem matematica dos
   campos receptivos da retina, que se tornou um classico na literatura, sendo
   conhecida como filtro de Marr-Hildreth, que e descrita pelo laplaciano da gaussiana
   (Equacao 4.1). Segundo tal modelo, os campos receptivos ganglionares sao
   excelentes detectores de bordas.
   2
   2
   1
   r
   r
   2
   2
   2
   G( r) =
   1
   e
   (4.1)
   4
   2
   2
   4.6.3 - CONEXOES ENTRE A RETINA E O CORTEX
   O proximo passo no caminho visual e a transmissao da informacao
   processada na retina para o cortex visual. As informacoes luminosas capturadas e
   processadas na retina sao enviadas ate o LGN (Nucleo Geniculado Lateral). A
   conexao entre a retina e o LGN e realizada pelo nervo optico, que nada mais e do
   que o conjunto de axonios das celulas ganglionares. Pode-se dizer que a retina e
   mapeada topograficamente nas celulas do LGN [Zeki, 1993], o que ocorre
   entretanto e que o mapeamento obedece a sofisticadas estrategias, que privilegiam
   a fovea e fazem a integracao das imagens obtidas pelas duas retinas.
   A Figura 4.17 apresenta um diagrama do caminho optico. A imagem e
   focalizada na retina e entao processada e transmitida atraves do nervo optico. Apos
   passar pelo quiasma optico, o nervo optico recebe a denominacao de trato optico,
   chegando ate o LGN ou nucleo geniculado lateral. Deste ponto a informacao e
   finalmente transmitida ate o cortex, atraves dos axonios das celulas do LGN, fibras
   que sao denominadas radiacao optica.
PA 130
   OS CAMINHOS PARALELOS DA VISAO
   Olho
   Nervo optico
   Quiasma optico
   Trato optico
   LGN
   Radiacao optica
   Cortex visual primario
   Fig. - 4.17 - Caminho optico: trajetoria dos sinais visuais, da retina ao cortex
   visual primario.
   Vamos comentar agora a estrategia de mapeamento que propicia a
   integracao das imagens obtidas nas retinas assim como a priorizacao da regiao
   foveal no percurso optico. Antes de prosseguirmos, devemos lembrar que cada
   retina e dividida em quatro partes ou quadrantes [Zeki,1993], e que quando o olho
   focaliza uma imagem, esta e sobreposta nos quadrantes de cada retina (Figura
   4.18).
   A Figura 4.18 apresenta um diagrama que demonstra o mapeamento da
   imagem formada na retina em cada etapa do caminho optico. Para
   compreendermos melhor esse diagrama, devemos observar o campo visual e a sua
   projecao e sobreposicao em cada uma das retinas, onde a regiao central do campo
   visual (coloracao mais escura) corresponde a regiao da imagem que sera projetada
   na regiao foveal da retina, assim como as regioes perifericas do campo de visao
   respectivamente na periferia da retina.
   O primeiro tipo de mapeamento da imagem vai ocorrer ja na propria retina
   que, como dissemos anteriormente, possui na regiao foveal uma concentracao
   maior de fotorreceptores (cones). Como a dimensao dos campos receptivos
   ganglionares e menor nessa regiao, de modo a favorecer o tamanho dessa regiao
   no mapa, ocorre uma distorcao ampliando essa regiao no mapa.
   131
   CAPITULO 4
   Regiao central
   Regiao periferica
   intermediaria
   Campo Visual
   Regiao periferica
   extrema
   Imagem
   projetada na
   retina
   Mapeamento da
   retina no LGN
   Mapeamento da
   retina no cortex
   visual primario
   Fig. - 4.18 - Diagrama da estrategia de mapeamento da imagem ao longo do
   caminho optico.
   No quiasma optico ocorre a integracao dos dois mapas visuais. Se
   dividirmos o campo visual em duas partes (direita e esquerda), a parte esquerda do
   campo visual e projetada na porcao nasal da retina do olho esquerdo e na temporal
PA da retina do olho direito ao passo que a parte direita do campo visual na porcao
   nasal da retina do olho direito e na temporal da retina esquerda. Deste modo,
   teremos em cada retina informacao sobre as duas partes do campo visual (direita e
   esquerda). Quando o nervo optico de cada uma das retinas chega ate o quiasma
   optico, as imagens do campo visual sao integradas e o mapa de cada retina
   separado, de forma que toda a informacao referente ao lado esquerdo do campo
   visual, integrada com informacoes de ambas retinas, se dirija ao hemisferio direito
   do cerebro, acontecendo o mesmo com o outro lado, que se integra e dirige-se para
   o hemisferio esquerdo.
   Os mapas correspondentes a cada lado do campo visual (esquerdo e
   132
   OS CAMINHOS PARALELOS DA VISAO
   direito), sao entao enviados ate o LGN pelo trato optico. Nas celulas do LGN a
   retina continua mapeada, embora esse mapeamento seja relativo ao topografico, a
   sua distribuicao difere, devido a quantidade maior de celulas voltadas a regiao
   central (macula e fovea). A partir do LGN, as informacoes visuais sao transmitidas
   para o cortex visual primario. As celulas do cortex visual continuam mapeando
   topograficamente a retina. Esse mapeamento e demostrado a partir da analise de
   lesoes de V1 [Zeki, 1993], assim como dos campos receptivos. No caso dos
   campos receptivos, verifica-se que celulas adjacentes em V1 apresentam campos
   receptivos adjacentes, comprovando a manutencao do mapeamento da retina no
   cortex, sempre lembrando que ocorre uma distorcao devido a uma super-
   representacao celular da regiao foveal. Alem de V1 outras regioes do cortex visual
   tambem apresentam em suas celulas o mapeamento topografico da imagem
   correspondente a retina, no entanto observa-se que a medida que a informacao
   caminha de V1 para as regioes seguintes, os campos receptivos, embora
   continuem adjacentes, aumentam de tamanho, caracterizando uma maior abstracao
   de informacao [Zeki, 1993].
   4.6.3.1 - NUCLEO GENICULADO LATERAL
   O Nucleo Geniculado Lateral ou LGN (do ingles "Lateral Geniculate
   Nucleus"), e um nucleo talamico que faz a mediacao entre a retina e o cortex visual
   primario, aqui as informacoes transmitidas pela retina sofrem a primeira conexao
   sinaptica. Conforme comentamos anteriormente, o mesmo mapeamento celular das
   informacoes visuais transmitidas pela retina e mantido nesse nucleo, de forma
   precisa. Em relacao ao processamento realizado pelo LGN, foram detectadas
   respostas em suas celulas em relacao a impulsos cromaticos e iluminacao difusa,
   no entanto existem evidencias de que ocorram outros tipos de processamentos
   [Costa, 1996].
   Nesse trabalho estaremos interessados em duas caracteristicas do LGN: (i)
   a segregacao dos caminhos parvo e magno iniciados na retina e (ii) a distribuicao e
   replicacao do mapa visual para o cortex visual.
   133
   CAPITULO 4
   Camadas
   parvocelular
   Camadas
   magnocelular
   Fig. - 4.19 - Nucleo Geniculado Lateral [Hubel,1995].
   Conforme iremos comentar, o caminho visual como um todo e caracterizado
   pelo dualismo do caminho Parvo e Magno. Embora esses dois caminhos se iniciem
PA na retina, (nas celulas ganglionares da retina observa-se a existencia de duas
   classes celulares, P e M) a divisao mais marcante ocorre no LGN, a qual pode ser
   observada nao somente atraves da forma e funcao celulares mas tambem no nivel
   da sua organizacao. O LGN e formado por seis camadas conforme podemos
   observar na Figura 4.19. Destas seis camadas, quatro sao caracterizadas por
   celulas pequenas, parvocelulares, e duas camadas por celulas grandes, magno
   celulares [Hubel, 1995]. A Tabela 4.1 apresenta um resumo das caracteristicas
   entre as celulas magno e parvo do LGN. Observando as caracteristicas desta
   tabela, podemos concluir que o caminho magno possui caracteristicas menos
   evoluidas que o caminho parvo. Isto pode ser notado principalmente pela diferenca
   de resolucao e velocidade de resposta.
   Caracteristica
   Magno
   Parvo
   Tamanho do soma
   Menor
   Maior
   Sensibilidade a Cor
   Nao
   Sim
   Resolucao
   Baixa
   Alta
   Velocidade
   Rapidas e Transientes
   Lentas e Continuas
   Contraste
   Mais Sensitivo
   Menos Sensitivo
   Tabela 4.1 - Principais diferencas entre as celulas magno e parvocelular.
   134
   OS CAMINHOS PARALELOS DA VISAO
   Como segunda caracteristica do LGN temos a distribuicao e replicacao do
   mapa visual para o cortex visual. Como vimos, o LGN e composto de seis camadas
   (4 parvo e 2 magno), cada olho sendo mapeado em 3 das 6 camadas (2 parvo e 1
   magno). Deste modo, a retina e mapeada tres vezes no LGN [Livingstone & Hubel,
   1988]. Essa caracteristica e especialmente importante para esse trabalho por
   evidenciar o paralelismo do sistema visual, onde podemos supor que, assim como
   nos sistemas computacionais, a natureza foi obrigada a fazer copias, devido a
   necessidade de envia-las a sistemas distintos que trabalharam com as informacoes
   de modo independente. A grande maioria das informacoes correspondentes aos
   mapas replicados do LGN sao transmitidos para camadas distintas do cortex visual
   primario (V1), embora uma pequena parcela seja projetada em outras regioes [Zeki,
   1993].
   4.7 - O CORTEX VISUAL
   Embora, o processamento visual se inicie logo apos a captacao da imagem,
   nas celulas nervosas da retina, a grande maioria do processamento visual, ou seja,
   a abstracao da informacao visual em algo inteligivel para o maquinario neural, e
   realizado pelo cortex visual. O cortex visual se localiza no lobulo occiptal, (ver
   Figura 4.4), que se encontra na regiao posterior do cerebro ou, segundo a divisao
PA de Broadmann, nas areas 17 e 18. Possui uma aparencia bastante uniforme,
   podendo a uma primeira instancia ser reveladas duas regioes: o cortex estriado e o
   cortex pre-estriado. O cortex pre-estriado, atraves de diferentes tecnicas (ex:
   citoarquitetura e citocromo oxidase), quando analisado demonstra ser composto por
   quatro regioes distintas. Deste modo, o cortex visual e composto por cinco areas,
   que apresentam caracteristicas funcionais bem definidas, sendo cada uma delas
   respectivamente denominadas de: cortex visual estriado ou V1, cortex visual pre-
   estriado ou V2, V3, V4 e V5. Algumas dessas regioes apresentam estruturas bem
   definidas (como "blobs", colunas, "stripes", etc), que obedecem a uma hierarquia.
   Ao longo de todo o cortex visual sua espessura e formada por seis camadas de
   estratificacao (citoarquiteturas), que sao caracterizadas em termos de tipo e
   distribuicao de celulas neurais.
   Nesta secao discutimos a organizacao, o funcionamento e as estrategias de
   paralelismo do cortex visual dos primatas.
   135
   CAPITULO 4
   4.7.1 - ESPECIALIZACAO FUNCIONAL DO CORTEX
   VISUAL
   As informacoes transmitidas pelo LGN sao enviadas para a area 17 de
   Broadmann, tambem conhecida como cortex visual primario, ou ainda V1, de onde
   prosseguem para as demais regioes corticais que constituem o cortex visual. As
   regioes do cortex visual apresentam uma modularizacao hierarquica. Entre as
   teorias a respeito da modularidade do cortex visual destaca-se a teoria da
   especializacao funcional do cortex visual de Zeki e Shipp [Zeki & Shipp, 1988],
   segundo a qual o cortex visual e dividido em modulos, que sao responsaveis por
   atributos especificos ou seja, especializados e agregados segundo a funcao que
   exercem no processamento visual. Estaremos especialmente interessados na teoria
   da especializacao funcional do cortex visual. Tambem a levaremos em conta como
   inspiracao biologica para alguns modelos apresentados futuramente neste trabalho.
   4.7.2 - NIVEIS DE PARALELISMO
   Antes de avancarmos no caminho visual discorrendo sobre a organizacao
   do cortex visual comentaremos um pouco a respeito dos provaveis niveis de
   paralelismo cortical. Conforme veremos, nao apenas o cortex visual, mas todo o
   cortex e massivamente paralelo. Conforme mostrado na Figura 4.20, o paralelismo
   do cortex visual se apresenta em multiplas escalas. Na micro escala, ocorre
   paralelismo entre os neuronios; na escala intermediaria entre regioes e sub-regioes
   corticais; e no topo da escala o macro paralelismo ocorre entre os dois hemisferios
   cerebrais.
   Diversas evidencias apresentam o paralelismo em cada uma das escalas.
   Quanto ao nivel celular, o paralelismo nao tem novidade alguma, estando presente
   na propria natureza das celulas neurais, cuja principal caracteristica e receber e
   integrar informacoes que chegam simultaneamente de diferentes celulas. Alem
   disso, a velocidade de processamento e individualmente lenta nos neuronios,
   impossibilitando a existencia de sistemas seriais complexos e velozes, como
   encontramos normalmente na maioria dos seres vivos. De fato o paralelismo
   encontrado na natureza das celulas nervosas tem motivado intensamente areas
   como as redes neurais artificiais.
   Quanto ao paralelismo em macro escala, vivenciamos suas evidencias todos
   136
   OS CAMINHOS PARALELOS DA VISAO
PA os dias. O simples fato do cerebro possuir dois hemisferios e a maior prova desse
   paralelismo. Cada hemisferio do cerebro possui processamento independente e, do
   ponte de vista motor e sensorial, cada hemisferio e responsavel por uma metade do
   corpo. De fato, a nossa propria arquitetura, composta por pares (membros, olhos,
   ouvidos, etc.), pode estar associada a essa composicao. Do ponto de vista da visao
   cada hemisferio recebe informacoes e e responsavel por uma metade do campo
   visual. A integracao dos dois hemisferios e realizada pelo corpo caloso [Gazzaniga,
   1998].
   MICRO
   Entre celulas
   Estruturas de sub-regioes (ex: "blobs", "stripes")
   INTERMEDIARIO
   Entre sub-regioes
   Areas corticais
   MACRO
   Hemisferios
   Fig. - 4.20 - Paralelismo em multi-escala.
   Neste trabalho estamos especialmente interessados no paralelismo entre
   regioes e sub - regioes corticais. As evidencias que indicam o paralelismo entre as
   regioes corticais estao presentes nas conexoes entre as areas. Podemos observar
   que todas as regioes corticais enviam saidas para mais de uma regiao. A existencia
   de saidas paralelas indicam a replicacao de dados e o funcionamento de regioes
   em paralelo [Zeki, 1993]. Alem de ocorrer concentracoes nas conexoes de saidas
   entre regioes, o mesmo acontece tambem entre sub-regioes, demonstrando as
   evidencias de paralelismo nesse nivel.
   O paralelismo entre as areas, sub-areas corticais e micro estruturas ("blobs",
   "stripes", etc.) visuais esta estreitamente relacionado com a teoria da
   especializacao funcional. Assim as regioes especializadas em atributos diferentes
   estariam executando processamento das informacoes em paralelo. A primeira
   evidencia para comprovar esse fato ocorre ja na conexao do LGN com o cortex
   visual estriado ou V1, onde a retina e replicada 3 vezes (2 copias para o caminho
   Parvo e 1 para o magno), onde cada copia e enviada para uma sub-area distinta de
   V1, comprovando a existencia do paralelismo entre suas sub-areas.
   137
   CAPITULO 4
   O mesmo tipo de paralelismo pode ser observado no cortex visual pre-
   estriado ou V2. Depois de processado em V1, as informacoes visuais sao enviadas
   para V2. Novamente, tres copias da retina sao enviadas para tres regioes distintas
   em V2, confirmando uma arquitetura semelhante a V1. Observa-se que cada
   milimetro de V1 envia fibras anatomicamente separadas para diferentes areas do
   cortex pre-estriado. Essas fibras possuem diferentes diametros, o que indica que o
   sinal e transmitido em velocidades diferentes, evidenciando o sincronismo (cada
   area recebe os sinais em tempos diferentes). Ainda quanto ao paralelismo entre as
   sub-areas de V1 e V2 (blobs, interblobs, e faixas) observa-se que estas formam
   conjuntos de arranjos repetidos, onde cada conjunto e formado por diversas
   estruturas replicadas, indicando a ocorrencia de paralelismo dentro de uma sub-
   area.
   Alem de enviar sinais para o cortex pre-estriado, o cortex estriado (V1) envia
   mapas de informacao visual para as areas V3, V4 e V5 simultaneamente. O mesmo
   ocorre com a area V2, que tambem transmite para essas regioes. Essa arquitetura
PA de conexoes apresenta as evidencias de paralelismo entre as areas. Conforme
   vamos apresentar futuramente as areas V1 e V2 apresentam um forte perfil de
   segregacao, separando sinais de diferentes atributos e enviando para as regioes
   mais especializadas (V3,V4 e V5). Esse tipo de estrutura sugere a existencia de
   uma arquitetura estilo "pipeline" entre as areas de segregacao V1 e V2 e as mais
   especializadas (V3, V4 e V5), devido a dependencia de dados. Devemos observar
   entretanto, que a comunicacao no cortex visual e extremamente complexa, e ainda
   pouco sabemos a respeito de sua arquitetura. Existem comunicacoes entre as sub-
   regioes de uma mesma area, assim como entre areas, de forma a favorecer a
   integracao e segregacao da informacao dos diferentes atributos visuais. Alem disso,
   devemos observar tambem que nao existe um caminho unidirecional. As
   informacoes transitam em ambos sentidos de forma que as camadas superiores da
   hierarquia visual realimentam as primeiras camadas do processo.
   Nas proximas secoes estaremos discutindo a organizacao, as conexoes e o
   funcionamento do cortex visual, consequentemente explorando seu provavel
   paralelismo. Para concluirmos esta secao, devemos lembrar a forte correlacao
   existente entre a distribuicao da informacao e o paralelismo. Desta forma, a busca
   pelo paralelismo no processamento biologico implica na procura pela distribuicao e
   replicacao de sinas. Uma vez que todas as areas corticais possuem saidas
   paralelas para outras diferentes areas, chegamos a conclusao que nao apenas o
   138
   OS CAMINHOS PARALELOS DA VISAO
   sistema visual e um sistema paralelo-distribuido, mas sim todo o cerebro.
   4.7.3 - DIVISOES DO CORTEX VISUAL
   Fig. - 4.21 - Fatia do cortex visual, apresentando suas areas [Zeki, 1993].
   O cortex visual se localiza no lobulo occiptal, nas areas 17 e 18 de
   Bradmann, que se caracterizam pelo seu aspecto, respectivamente como cortex
   visual estriado e pre-estriado. O cortex visual estriado constitui uma das cinco areas
   do cortex visual, tambem conhecido como V1 ou cortex visual primario, ao passo
   que o cortex visual pre-estriado e dividido segundo criterios anatomicos e funcionais
   em quatro areas (V2, V3, V4 e V5). A Figura 4.21 apresenta uma fatia do cortex na
   qual podemos observar a localizacao anatomica de cada uma das areas do cortex
   visual. Nesta secao apresentamos cada uma dessa areas.
   4.7.3.1 - AREA V1
   Tambem conhecida como cortex visual estriado, cortex visual primario ou
   ainda area 17 de Broadmann, V1 e a regiao mais estudada e melhor compreendida
   de todo o cortex. Em V1 sao recebidas e processadas todas as modalidades de
   atributos visuais, sendo que a sua principal funcao e a segregacao e a distribuicao
   139
   CAPITULO 4
   dos atributos. Conforme comentamos anteriormente, o LGN envia para V1 tres
   mapas que replicam as informacoes visuais da retina, onde cada mapa e enviado
   para uma camada cortical especifica. E importante observar que V1 e a unica area
   cortical que recebe as informacoes visuais do LGN. A conexao entre o LGN e V1 e
   feita ponto a ponto, de modo que encontramos em V1 mapas topograficos da retina,
   ou seja celulas adjacentes em V1 recebem informacoes de regioes adjacentes da
   retina. Deste modo as vizinhancas do campo visual sao precisamente mantidas,
   sendo tambem conhecida como cortex retinal devido a essa caracteristica. Como
   na retina e em todo o sistema visual, em V1 continua ocorrendo uma super-
   representacao da regiao central do campo visual, onde praticamente metade de V1
PA e responsavel por seu processamento [Costa, 1996].
   Fig. - 4.22 - Micrografia do cortex visual primario [Dowling, 1992].
   Assim como as demais areas do cortex visual, o cortex visual primario e
   composto por seis camadas, conforme apresentado na micrografia da Figura 4.22.
   Observando essa Figura vemos que as camadas 1 e 2 nao podem ser distinguidas
   nessa imagem e que a camada 4 e dividida em 3 sub-camadas: 4a, 4b e 4c. Cada
   uma dessas camadas apresentam um tipo diferenciado de composicao celular que
   e apresentado na Tabela 4.2.
   As fibras que saem do LGN chegam ao cortex visual primario atraves da
   materia branca (representado pela letra W na Figura 4.22). Os axonios
   provenientes das camadas magno celulares fazem conexao com os neuronios da
   metade superior da camada 4c, conhecida como 4c , ao passo que os axonios das
   camadas parvo celulares se conectam em duas camadas: na outra metade da
   camada 4c (4c ) e na camada 4a. A Figura 4.23 apresenta um diagrama
   140
   OS CAMINHOS PARALELOS DA VISAO
   simplificado das entradas e saidas das conexoes de V1 e como podemos observar
   as camadas corticais nao se diferem apenas pela sua natureza celular (Tabela 4.2)
   mas tambem por suas conexoes.
   Camada
   Tipos de celulas predominantes
   astrocitos, oligondendrocitos, microgliais e neuronios
   1
   com corpos celulares ovais
   2
   celulas piramidais de dendritos curtos
   3
   celulas piramidais de tamanho medio e pequeno
   neuronios estrelados espinhosos e neuronios
   4 (a, b e c)
   poligonais
   (provavelmente neuronios piramidais modificados)
   neuronios poligonais pequenos e medios e celulas
   5
   piramidais
   varias celulas, entre elas, neuronios piramidais
   6
   pequenos e medios e celulas triangulares
   Tabela 4.2 - Composicao citoarquitetural de cada camada do cortex visual
   primario.
   A dualidade do sistema visual, caminhos Parvo e Magno, continua presente
   em V1, sendo diferenciadas pelas camadas em que realizam suas principais
   conexoes. O caminho Magno apos fazer conexao na camada 4c , envia
   informacoes para a camada 4B. Nesta camada, a maioria das celulas sao seletivas
   a orientacao e tambem algumas de suas celulas apresentam seletividade para
   direcao e movimento. Alguns desses neuronios ainda sao binoculares ou seja
   necessitam de estimulos de ambos os olhos e apresentam sensibilidade a
   disparidade retinal (visao estereo) [Tovee, 1996].
   O caminho Parvo, por sua vez, apos conectar nas camadas 4c e 4a, envia
   informacoes para as camadas superiores de V1 e divide-se em dois novos
PA caminhos. Onde o primeiro deles esta relacionado com cor e e denominado P-B e o
   outro relacionado com a percepcao de formas precisas e orientacao do estimulo,
   conhecido como P-I.
   141
   CAPITULO 4
   Entrada
   Saida
   1
   2, 3
   4a
   4b
   4c
   5
   6
   LGN - Magno
   LGN -
   Outras
   Estruturas cerebrais
   areas
   distantes
   Fig. - 4.23 -Diagrama apresentando as principais conexoes das camadas do
   cortex visual primario [Hubel, 1995].
   As camadas do cortex visual apresentam conexoes entre camadas, entre as
   demais areas do cortex visual ou ainda podem apresentar conexoes com regioes
   mais distantes, sendo corticais ou nao. Todas as camadas com excecoes de 1, 4a e
   4c apresentam conexoes para fora do cortex. As camadas 2, 3 e 4B apresentam a
   grande maioria de suas conexoes para as demais areas do cortex visual, ao passo
   que as camadas mais inferiores 5 e 6 projetam suas conexoes alem do cortex, para
   o colliculu superior e de volta ao LGN respectivamente. Devemos lembrar que essa
   estrategia de realimentacao do LGN realizada pela camada 6 e uma forte evidencia
   do pre-processamento da informacao visual realizada no LGN.
   142
   OS CAMINHOS PARALELOS DA VISAO
   Fig. - 4.24 - Colunas de dominancia ocular na camada 4c (projecao 2D),
   marcadas por dois deoxiglucose [Hubel, 1995].
   Como vimos na Secao 4.6.3, a area V1 de cada hemisferio recebe
   informacoes visuais de apenas um lado do campo visual composto pelas metades
   dos dois olhos, recebendo assim sinais de ambos os olhos. Essa natureza dual da
   informacao visual apresenta estruturas no cortex visual primario denominadas
   colunas de dominancia ocular. As colunas de dominancia ocular foram reveladas
   atraves de marcacoes com dois deoxiglucose por Hubel e colaboradores [Hubel et
   al., 1977] [Hubel & Wiesel 1977], e se apresentam ao longo de todo o cortex visual
   estriado. A Figura 4.24 apresenta uma projecao 2D da camada 4C do cortex visual
   primario, revelando as colunas de dominancia. A dominancia ocular se mantem
   constante ao longo da espessura do cortex, apresentando-se no entanto de forma
   mais graduada a medida que as camadas se distanciam de 4C, camada que recebe
   os aferentes do LGN. A dominancia ocular demonstra evidencias de ser um dos
   mecanismos responsaveis pela integracao da informacao proveniente de cada olho.
   Alem de campos receptivos semelhantes aos encontrados na retina e no
   LGN, V1 apresenta dois novos tipos de campos receptivos, denominados de
PA simples e complexos. Os campos receptivos simples sao sensiveis a orientacao e
   posicao dos estimulos, e os complexos especificos a orientacao, mas os estimulos
   podem aparecer em diversas posicoes (movimentos). A Figura 4.25 apresenta um
   modelo para o mecanismo das celulas simples [Hubel, 1995], no qual as celulas
   centro-periferia de LGN aferem impulsos para as celulas simples. Atraves da
   combinacao destes estimulos, ocorre a resposta a orientacao. Seguindo essa
   mesma filosofia, podemos compreender o funcionamento das celulas complexas.
   Assim, as celulas simples de mesma orientacao enviam sinais para as celulas
   143
   CAPITULO 4
   complexas. A combinacao dos sinais das celulas simples explicaria o
   funcionamento das celulas complexas, que possuem campos receptivos maiores
   que as simples e respondem a mesma orientacao indiferente da posicao do
   estimulo no campo receptivo.
   Fig. - 4.25 - Diagrama ilustrando o campo receptivo das celulas simples, sua
   composicao a partir de celulas centro-periferia do LGN e as suas respostas a
   estimulos de diferentes orientacoes [Zeki, 1993].
   Uma outra peculiaridade importante de V1 e o arranjo no qual se encontram
   as celulas estimuladas a orientacao. Experimentalmente, Hubel e Wiesel [Hubel,
   1995] perceberam que quando o eletrodo era introduzido perpendicularmente as
   camadas, as celulas mantinham praticamente a mesma orientacao, ao passo que
   quando o caminho de penetracao do eletrodo era tangencial, a resposta a
   orientacao das celulas variavam linearmente ao longo do percurso, embora
   houvesse algumas variacoes abruptas inexplicaveis. Estas caracteristicas inspiram
   o classico modelo das hipercolunas, apresentado na Figura 4.26, que integra as
   colunas de dominancia ocular e a distribuicao das celulas de orientacao seletiva.
   144
   OS CAMINHOS PARALELOS DA VISAO
   od
   to
   to
   rei
   quer
   rei
   Di
   Es
   Di
   Fig. - 4.26 - Modelo das hipercolunas de Hubel e Wiesel.
   Quando marcado com a tecnica de citocromo oxidase, o cortex estriado
   apresenta marcas na forma de pequenas bolhas ("blobs", no ingles), conforme
   podemos observar na Figura 4.27. Do ponto de vista fisiologico desse arranjo, foi
   observado que os "blobs" nao apresentavam celulas sensiveis a orientacao, mas
   que por outro lado respondiam a variacoes do comprimento de onda (cor). No
   entanto, a regiao entre os "blobs" apresenta seletividade a orientacao. Para corrigir
   as variacoes abruptas do modelo de hipercolunas, Braitenberg & Braitenberg
   propuseram um modelo teorico que, devido ao seu aspecto, foi denominado cata-
   vento [Braitenberg & Braitenberg, 1979]. Experimentos recentes [Costa, 1996]
   [Bonhoeffer & Grinvald, 1991] [Blasdel, 1986] indicam que o modelo teorico do cata-
   vento coincide com os "blobs" do citocromo oxidase, de forma que o centro do cata-
   vento, insensivel a orientacao seja o "blob", e a regiao que o contorna possui a
PA estrutura de orientacao seguindo o padrao de cata-vento.
   Alem de coincidir com o modelo de Braitenberg, os "blobs" tambem explicam
   a dualidade do caminho parvo celular (P-B e P-I) que ocorre em V1. O caminho
   parvo P-B (de Parvo-Blob) privilegia as informacoes cromaticas e esta relacionado
   com as celulas pertencentes aos "blobs". O caminho parvo P-I ( de Parvo-Interblob)
   e voltado a percepcao precisa de formas, localizando nas regioes entre os "blobs",
   contem neuronios que apresentam respostas a orientacao (linhas e barras). Uma
   vez que as celulas dos "blobs" nao respondem a orientacao, elas possuem campos
   receptivos diferentes dos simples e complexos encontrados em V1, e respondem a
   estimulos envolvendo cromaticidade. Assim como no LGN foram encontradas
   celulas com campo receptivo de oponencia cromatica. Esse mecanismo envolve os
   pares de cores vermelho/verde e azul/amarelo, que ficam arranjados nas estruturas
   centro-periferia dos campos receptivos e podem ser observados atraves de uma
   serie de experimentos psicofisicos [Goldstein, 1989].
   145
   CAPITULO 4
   (b)
   (a)
   Fig. - 4.27 - (a) Corte longitudinal do cortex estriado, com tratamento de
   citocromo oxidase. (b) Detalhe do corte paralelo (linha da imagem a)
   apresentando as camadas 2 e 3. As estruturas em forma de pontos claros sao
   os "blobs" [Zeki, 1993].
   Uma vez que discutimos as estruturas encontradas no cortex estriado visual,
   comentaremos agora sobre seu funcionamento em termos gerais, enfocando
   sempre as questoes de paralelismo. Uma das principais funcoes de V1 e a
   segregacao dos sinais visuais. Deste modo, o sinal que vem do LGN e separado de
   acordo com o atributos e retransmitido para as areas mais especializadas. Do ponto
   de vista do paralelismo, a segregacao realizada em V1 e uma evidencia muito forte
   do paralelismo entre as diferentes areas. Nesse perfil, o cortex visual primario tem
   como funcao a divisao das tarefas, uma vez que direciona cada atributo para uma
   area especialista, e alem disso o sincronismo de sinas, como ja comentamos, V1
   possui fibras eferentes com diferentes espessuras indicando velocidades diferentes.
   Ainda quanto ao paralelismo, este pode ocorrer em diferentes niveis dentro
   do cortex estriado (Secao 4.7.2). No nivel mais baixo da escala temos o paralelismo
   entre neuronios, uma forte evidencia desse nivel em V1 sao as celulas simples e
   complexas. Como vimos, as celulas simples recebem sinal das celulas centro-
   periferia e as celulas complexas das celulas simples, isso evidencia o paralelismo
   entre neuronios em V1, e para que os impulsos sejam integrados pelo neuronio,
   eles devem ser concomitantes, indicando a ocorrencia de celulas processando
   paralelamente. Subindo a escala encontramos diversas estruturas replicadas
   indicando paralelismo entre estas assim como regioes respondendo a diferentes
   146
   OS CAMINHOS PARALELOS DA VISAO
   orientacoes. E, finalmente, encontramos em V1 tres sistemas distintos: um magno e
   dois parvos. Sendo responsaveis por diferentes atributos, ocupam espacos fisicos
   separados (embora ocorra conexoes entre eles) em estruturas ou camadas
   diferentes, indicando atraves dessa independencia a existencia de paralelismo
   entre esses sistemas.
   4.7.3.2 - AREA V2
   Adjacente a regiao V1, e embora nao tao explorada quanto esta, V2 e a
PA segunda regiao mais explorada do cortex visual. Semelhante em diversos aspectos
   ao cortex visual primario, do qual e o alvo principal das fibras aferentes, essa regiao
   segrega as informacoes visuais distribuindo para areas mais especializadas e,
   deste modo, tambem incorpora todas as modalidades visuais. Outra caracteristica
   que preserva do cortex estriado e a constancia do mapeamento da retina,
   possuindo as celulas vizinhas campos receptivos vizinhos no campo visual, uma
   vez que celulas adjacentes em V1 conectam-se com celulas tambem adjacentes
   em V2.
   Na regiao V2, alem dos campos receptivos que ja apresentamos
   anteriormente, encontramos um novo tipo peculiar, denominado de celulas
   hipercomplexas. Esse novo campo receptivo, semelhante as celulas simples e
   complexas, e seletivo a orientacao. No entanto, alem da orientacao sua resposta
   depende do comprimento do estimulo e, assim como as celulas complexas, e
   indiferente a posicao do estimulo. As celulas hipercomplexas recebem conexao das
   celulas complexas. Devido as suas caracteristicas devem haver conexoes
   inibitorias operando em conjunto com as excitatorias, a fim de possibilitar a
   seletividade ao comprimento do estimulo.
   Quando marcada com citocromo oxidase, V2 tambem revela estruturas, no
   entanto elas sao bastante diferentes das estruturas que comentamos na secao
   anterior. Conforme podemos observar na Figura 4.28, a arquitetura citocromo
   oxidase de V2 e apresentada na forma de tiras ou faixas paralelas que formam um
   angulo quase perpendicular com V1. As faixas sao formadas por tres conjuntos
   (finas, grossas e palidas), que ficam arranjados de forma intercalada.
   147
   CAPITULO 4
   V2
   V1
   Fig. - 4.28 - Regioes V1 e V2 do macaco esquilo marcadas por citocromo
   oxidase [Zeki, 1993].
   As faixas finas e grossas se caracterizam por suas cores escuras e se
   diferenciam por sua espessura, a terceira faixa apresenta uma cor mais clara,
   sendo denominada por essa caracteristica de palida, sendo tambem conhecida
   como estrutura "entre faixas". Os neuronios das faixas grossas recebem a maioria
   de suas conexoes das celulas da camada 4B de V1 (caminho magno), e suas
   celulas possuem caracteristicas semelhantes as desta camada de V1, possuindo
   seletividade a orientacao, movimento e tambem apresentam disparidade ocular,
   funcao primordial para a visao estereo.
   As celulas das estruturas "blobs" de V1 projetam parte de seus axonios para
   os neuronios das faixas finas. Os neuronios dessa estrutura nao sao sensiveis a
   orientacao. No entanto, mais da metade deles responde ao comprimento de onda,
   assim como as celulas dos "blobs". No entanto, verifica-se a ocorrencia de um
   numero maior de celulas com oponencia cromatica dupla. Os neuronios das areas
   entre "blobs" de V1, enviam parte de suas fibras para as estruturas palidas ou entre
   faixas. Essa regiao possui celulas que sao sensiveis a orientacao, mas nao
   apresentam sensibilidade a direcao (movimento) ou cor.
   Os dois caminhos parvo e o caminho magno encontrados em V1, continuam
   presentes em V2. De fato, em V2 a divisao do caminho visual fica ainda mais
   evidente, uma vez que ela se encontra visivel nas estruturas (faixas) desta area. Tal
   divisao e uma demonstracao de paralelismo em V2, que apresenta tres mapas com
   representacoes distintas, separadas, independentes e praticamente integrais da
PA retina [Zeki, 1993]. Cada mapa corresponde a uma estrutura (faixa) de V2, assim as
   faixas grossas apresentam um mapa de orientacao e movimento (caminho magno),
   148
   OS CAMINHOS PARALELOS DA VISAO
   as faixas finas um mapa cromatico (parvo B) e as palidas apresentam um mapa de
   disparidade e orientacao relacionada a formas de alta definicao (parvo I). Uma
   demonstracao de que cada um dos mapas possui uma representacao praticamente
   integral da retina esta no fato de que estruturas adjacentes (faixas finas, grossa e
   palidas) apresentam campos receptivos sobrepostos, indicando que representam a
   mesma regiao retinal. Cada um dos mapas de V2 e transmitido para areas
   especializadas em atributos especificos. Deste modo a V2 assim como V1
   continuam exercendo o papel de segregacao e distribuicao de sinais.
   4.7.3.3 - AREAS V3, V4 E V5
   A exploracao e mapeamento detalhado que ocorre na areas V1 e V2 nao
   ocorre em mais nenhuma outra area do cortex visual, uma vez que ainda nao foi
   descoberta nenhuma tecnica que permite revelar suas arquiteturas. Deste modo,
   pouco sabemos a respeito destas areas. Os estudos fisiologicos, entretanto,
   demonstram que diferentemente de V1 e V2 que apresentam todas as modalidades
   dos atributos visuais (cor, movimento, forma e estereo), essas areas sao mais
   especializadas, tornando responsaveis por atributos especificos. Esta e a situacao
   de V5, que foi denominado de area de movimento [Zeki, 1993] [Costa, 1996] por
   possuir mais de 90% de suas celulas relacionadas com esse atributo.
   Alem de ocorrer a especializacao de toda a area para um atributo especifico
   observamos tambem que as representacoes vao se tornando cada vez mais
   complexas e abstratas a medida em que o caminho visual vai adentrando as
   regioes corticais. A representacao topografica da retina nao e mais encontrada em
   nenhuma area, de modo que a previsao do campo receptivo das celulas vizinhas
   nao e mais tao obvia quanto em V1 ou V2. Outra caracteristica que vem comprovar
   o crescente nivel de abstracao e o tamanho dos campos receptivos, onde o
   tamanho do campo receptivo de V1 e menor do que o de V2 que e menor do que as
   demais areas. A Figura 4.29 contem uma ilustracao que apresenta a diferenca de
   tamanho relativo e consequente abstracao entre os campos receptivos de
   diferentes areas do cortex visual.
   Quanto ao paralelismo nestas areas, devido a falta de conhecimento sobre
   suas arquiteturas, pouco sabemos a respeito da concorrencia dentro de uma unica
   area, com excecao de V4, que recebe as duas divisoes do caminho parvo (I e B),
   indicando a existencia de no minimo dois sistemas independentes. Subindo a
   escala do paralelismo e considerando a concorrencia entre as areas, V3, V4 e V5
   149
   CAPITULO 4
   trazem fortes evidencias para este nivel de paralelismo. Isso pode ser observado se
   considerarmos a independencia entre essas areas, e suas conexoes. Deste modo
   os mapas das areas V1 e V2 que, como vimos, sao processados paralelamente, se
   estendem para essas areas em caminhos distintos e consequentemente paralelos.
   Entraremos em maiores detalhes sobre esse assunto na proxima secao.
   V1
   V2
   (a)
   (a)
   (b)
PA (c)
   (c)
   (b)
   V3
   V5
   (a)
   (a)
   (b)
   (b)
   (c)
   Fig. - 4.29 - Comparacao entre os campos receptivos das regioes V1, V2, V3 e
   V5, demonstrando o aumento do tamanho do campo receptivo e da abstracao,
   no sentido de nao ocorrer mais previsao do trajeto do campo receptivo em
   relacao ao trajeto da penetracao do eletrodo. (a) Regiao explorada e trajetoria
   do eletrodo, (b) dimensao e disposicao dos campos receptivos e (c) trajetoria
   dos centros dos campos receptivos. [Zeki, 1993]
   150
   OS CAMINHOS PARALELOS DA VISAO
   Conforme ja comentamos, cada uma dessas areas e responsavel por um
   atributo ou modalidade de visao, o que as diferencia das areas V1 e V2 que
   possuem representacoes de todas as modalidades e, consequentemente,
   designam o papel de segregadoras de sinal. Entretanto, evidencias foram
   encontradas, especialmente na projecao de fibras para diversas areas corticais, que
   indicam a ocorrencia de segregacao de sinal nas areas especializadas (V3, V4 e
   V5). Assim, devemos supor que as modalidades representadas por cada uma
   dessas areas deve ser ainda dividida em atributos distintos. Essa ideia se torna
   mais clara a medida em que vao sendo descobertas as areas satelites (V5
   complexa, V4 complexa, etc.) [Zeki, 1993]. As areas satelites sao regioes proximas
   as areas especializadas que processam a mesma modalidade da area principal. Em
   relacao ao controle de paralelismo, e importante observar que essas areas recebem
   poucas ou nenhuma projecao de V1, indicando que o controle dessas regioes e
   realizado pelas regioes especialistas. Deste modo a existencia das areas satelites
   contribui para a visao modular e estruturada do cortex visual, assim como seu
   arranjo sob o perfil de estrategias de paralelismo. A seguir vamos comentar as
   principais caracteristicas de cada uma dessas areas:
   Area V3 - E adjacente a V2 e recebe conexoes das faixas grossas, assim como da
   camada 4B de V1. Essa area se caracteriza por apresentar a grande maioria de
   seus neuronios sensiveis a orientacao, nao possuir celulas com sensibilidade a
   estimulos cromaticos e por apresentar indicacoes de que esteja relacionada com o
   processamento de forma dinamicas. Dentre as areas especializadas, V3 e a que
   mantem tracos de ordenacoes em relacao a topografia da retina. Em alguns
   primatas, com excecao dos homens, foi encontrada uma subdivisao de V3,
   denominada de V3A. A principal diferenca entre V3A e as demais partes de V3 e
   que ela nao recebe conexoes de V1.
   Area V4 - Recebe projecoes das faixas finas e das palidas de V2, assim como dos
   "blobs" de V1, deste modo as duas subdivisoes do caminho parvo (B e I) sao
   contidas nessa area. Embora, como as demais areas especializadas, apresenta
   hegemonia quando marcada com citocromo oxidase, e possivel tracar as conexoes
   de seus neuronios atraves da utilizacao de algumas substancias (entre elas as
   enzimas peroxidase). Essas conexoes, quando analisadas, sugerem que os dois
PA caminhos parvos continuam divididos, uma vez que geram padroes de conexao
   151
   CAPITULO 4
   distintos. Deste modo, acredita-se que a divisao do caminho parvo continue em V4,
   indicando portanto a existencia de dois sistemas independentes.
   Encontramos nessas areas como principais caracteristicas a seletividade a
   cor e a orientacao apresentadas pela grande maioria das suas celulas, sendo que
   os estimulos sao bem mais complexos que nas areas anteriores. Em relacao a
   sensibilidade cromatica, em vez de simplesmente responder ao comprimento de
   onda, as celulas de V4 respondem a cor. Esse fenomeno e denominado de
   constancia cromatica e pode ser exemplificada pela impressao que temos quando
   um objeto embora iluminado com diferentes fontes de luz (comprimentos de onda
   diferentes) permanece com a mesma percepcao de cor [Goldstein, 1989] [Zeki,
   1993]. Quanto a seletividade a orientacao, V4 possui caracteristicas de
   processamento de formas e objetos, que foram demonstradas atraves de
   experimentos realizados em macacos, atraves de estudos eletrofisiologicos de
   respostas celulares e lesoes [Tovee, 1996]. V4 projeta a maior parte de suas fibras
   para o cortex visual temporal, onde aparenta ocorrer uma integracao entre a cor e a
   forma dos objetos. Neuronios nessa regiao demonstraram ser seletivos a padroes e
   objetos complexos, como rostos [Rol s et al., 1994].
   Area V5 - Assim como V3, a area V5 recebe projecoes do caminho magno, sendo
   parte da camada 4B de V1 e parte da faixa grossa de V2. Se caracteriza por
   possuir praticamente todos os seus neuronios seletivos ao movimento e nao
   apresentar respostas aos estimulos cromaticos. Esta associada ao processamento
   de informacoes de movimento e estereo. V5 projeta principalmente para o cortex
   parietal, que demonstra ser uma regiao de continuidade do caminho magno,
   integrando movimento, estereo e profundidade em representacoes espaciais.
   4.7.4 - ORGANIZACAO DO CORTEX VISUAL
   Ja discutimos algumas das areas que compoem o cortex visual, assim como
   suas arquiteturas e, embora tenhamos comentado individualmente as conexoes
   entre areas, estaremos apresentando nesta secao as conexoes e a organizacao do
   cortex visual como um todo, suas estrategias de paralelismo e de segregacao e
   integracao de sinais.
   152
   OS CAMINHOS PARALELOS DA VISAO
   Cortex Inferotemporal
   Cortex Parietal
   V4
   V5
   (comp. de onda;
   (direcao;
   orientacao;
   orientacao;
   disparidade)
   disparidade)
   V3
   (direcao;
   orientacao;
   disparidade)
   Palidas
PA Faixas finas
   Faixas grossas
   (comp. de onda)
   (comp. de onda;
   (direcao; orientacao;
   orientacao;
   disparidade)
   V2
   disparidade)
   blobs
   interblobs
   4B
   (comp. de onda)
   (comp. de onda;
   (direcao;
   V1
   orientacao;
   orientacao;
   disparidade)
   disparidade)
   LGN parvocelular
   LGN magnocelular
   Cones
   Bastonetes
   Fig. - 4.30 - Mapa simplificado das interconexoes do cortex visual. [Zeki,
   1993] [Zeki & Shipp, 1988] [Levine & Shefner, 1991] [Livingstone & Hubel,
   1988].
   153
   CAPITULO 4
   A Figura 4.30 apresenta um mapa simplificado das interconexoes entre as
   areas e sub-areas do cortex visual. As consideracoes que faremos no decorrer
   deste secao serao referentes a ela. A primeira segregacao no processo visual se
   inicia ja na retina, que apresenta dois tipos de celulas especializadas para
   diferentes informacoes visuais. Mediante o dualismo dos fotorreceptores, que
   mantem as suas conexoes separadas em camadas distintas do LGN, podemos
   concluir que alem do paralelismo entre as celulas, a retina tambem apresenta dois
   sistemas distintos e independentes no seu maquinario neurologico.
   Conforme vimos na Secao 4.6.3, a visao tem um sofisticado mecanismo de
   integracao das informacoes do campo visual que estao em cada uma das retinas,
   que ocorre com o cruzamento das fibras do nervo optico no Quiasma optico. Depois
   disso, e realizada a primeira conexao sinaptica no nucleo lateral geniculado (LGN)
   onde, mais uma vez o sinal e segregado e consequentemente ocorre sua
   distribuicao. Como vimos, o LGN possui dois grupos distintos de celulas (magno e
   parvo), que estao relacionados com os dois grupos de fotorreceptores da retina. Ele
   e composto por seis camadas das quais quatro correspondem ao caminho parvo
   celular e duas ao magno celular, os quais caracterizam tres mapas distintos da
   retina.
   Se ja tivemos uma divisao de caminhos entre parvo e magno, teremos ainda
   uma segregacao do caminho parvo em LGN. Deste modo, ocorrem tres projecoes
   basicas de LGN para V1. As celulas do caminho magno projetam fibras para V1,
PA que serao relacionadas com o processamento realizado na camada 4B, e as
   celulas do caminho parvo, que foram segmentadas em dois mapas replicados da
   retina, projetam um mapa que sera relacionado com as estruturas "blobs" e outro
   mapa que sera relacionado a estrutura entre "blobs".
   O mapa da Figura 4.30 e muito simplificado e apresenta apenas as
   principais conexoes realizadas. Embora apresentamos no mapa apenas um sentido
   para as conexoes, essas sao na sua grande maioria bi-laterais, sendo essa uma
   importante caracteristica do processamento visual. Seus dois sentidos de
   transferencia de informacoes durante o processamento e referenciada muitas vezes
   na literatura como "top-down" e "botton-up" [Levine, 1985]. O cortex visual primario,
   por exemplo, projeta fibras de volta para o LGN.
   Para cada hemisferio cerebral e enviada uma metade de cada retina que,
   juntas, compoem um lado do campo visual. O cortex visual primario possui uma
   arquitetura (colunas de dominancia ocular) para o tratamento individual de cada
   154
   OS CAMINHOS PARALELOS DA VISAO
   uma das retinas (binocularidade), que indica ser um sistema de integracao entre as
   imagens de cada retina. O estimulo celular com preferencia binocular nao e
   encontrado em nenhuma outra area cortical, sugerindo que V1 seja realmente a
   area responsavel pela juncao desses sinais.
   Quanto a organizacao V1 apresenta tres sistemas independentes, que sao
   respectivos aos tres caminhos incidentes nesta area ou seja, dois caminhos parvos,
   recebem o nome de parvo I ("interblob") e parvo B ("blob") e magno. Devido a
   independencia, destino principal individual e seu aspecto funcional, acredita-se que
   eles sejam paralelos. Alem do paralelismo entre os tres caminhos, encontramos
   tambem, devido ao amplo estudo e exploracao de V1, sub-estruturas replicadas
   para cada um dos caminhos replicados, indicando o paralelismo multi-escalar
   dentro dessa area.
   O cortex visual primario caracteriza-se como um segregador, distribuidor de
   sinais e provavelmente tambem como gerenciador ou escalonador, devido a
   diferenca de diametro, que consequentemente influencia na velocidade de
   transmissao de suas fibras. Deste modo, V1 projeta fibras para diversas areas
   corticais, dentro e fora do cortex visual, assim como projecoes extra-corticais
   (culiculo superior, LGN, etc.). Dentre as principais conexoes de V1 destacam-se as
   projecoes para V2 e para as areas especialistas V3, V4 e V5. As conexoes entre as
   areas corticais em geral obedecem a padroes restritos, que indicam que os
   estimulos estao sendo transmitidos em conjunto atraves de mapas.
   A area V2 recebe tres mapas de V1, relativos aos tres caminhos (magno,
   parvo I e parvo B). Esses caminhos continuam em V2 como sistemas
   independentes e sao associados a estruturas anatomicas que assemelham a faixas
   (faixas grossa, finas e palidas). Assim como V1, V2 projeta fibras para todas as
   areas especialistas do cortex visual (V3, V4 e V5). Embora nao esteja representado
   no mapa da Figura 4.30, as areas V3, V4 e V5 apresentam em suas proximidades
   areas satelites, que processam os mesmos atributos e recebem a maior parte das
   fibras eferentes das areas principais. As areas satelites nos apresentam fortes
   indicios da distribuicao de processamento que ocorre nas areas V3, V4 e V5 [Zeki].
   Em funcao das areas satelites especializadas, encontramos uma peculiar
   diferenca entre as areas V1 e V2. Embora possuam caracteristicas semelhantes,
   como segregadoras de sinais, e ambas apresentam conexoes com todas as regioes
   especializadas, somente V2 apresenta conexoes com as areas satelites de V3, V4
PA e V5.
   155
   CAPITULO 4
   Os caminhos visuais sao projetados a partir de V1 e V2 para as areas mais
   especializadas do cortex visual: V3, V4 e V5. Essas areas se diferenciam de V1 e
   V2 por lidarem com atributos mais especificos e, consequentemente, por
   apresentarem apenas representacoes destes. O caminho magno, correspondente a
   camada 4B de V1 e faixas grossas de V2, e projetado para duas areas
   especialistas: V3 e V5. A area V3 e principalmente responsavel pelo
   processamento de formas dinamicas e a area V5 por movimento. Os dois caminhos
   parvos (I e B), entretanto, sao projetados para uma unica area: V4. Essa area e
   responsavel pelos processamentos cor (Parvo B) e formas de alta definicao
   cromatica (Parvo I).
   Cada uma das areas especialistas trocam informacoes entre si. Essas
   informacoes permitem o enriquecimento da informacao local com componentes
   processados pela outra area. Dentre as comunicacoes entre as areas
   especializadas destacam-se as conexoes entre V3 e V4. Segundo Zeki [Zeki, 1993],
   existem indicacoes que atraves dessas conexoes e realizada a integracao de sinais
   para o processamento de formas. Desta forma, V3, responsavel pelo
   processamento de formas dinamicas, enriquece seu processamento com os
   resultados de V4, responsavel por formas cromaticas de alta definicao, e vice-
   versa.
   A partir das areas especialistas, a informacao visual e transmitida para
   regioes mais profundas no cortex, ficando cada vez mais complexa e abstrata.
   Basicamente, encontramos dois caminhos principais que nos levam a dois sistemas
   de visao localizados respectivamente no cortex inferotemporal e no cortex parietal.
   Aparentemente essas conexoes sao extensoes dos caminhos parvo e magno e sao
   as bases da famosa doutrina "o que" e "onde". Segundo essa doutrina, as
   informacoes visuais sao separadas em duas primitivas basicas quando organizadas
   na memoria associativa. Uma delas e responsavel pelo processamento e
   armazenamento de todas as informacoes relativas a localizacao no espaco, e a
   outra, pelo processamento e armazenamento das informacoes relativas as
   propriedades fisicas dos objetos [Kosslyn, 1996] [Hundert, 1995].
   A doutrina "o que - aonde" entretanto nao e amplamente aceita no meio
   cientifico, sendo duramente criticada por alguns autores. Dentre as criticas,
   destaca-se a de Zeki [Zeki, 1993], que sugere que a doutrina constitua de um erro
   sistematicamente historico, que ocorre na tentativa de neuro-cirurgioes
   simplificarem as estrategias corticais, devido ao limitado conhecimento de sua
   156
   OS CAMINHOS PARALELOS DA VISAO
   constituicao e funcionamento. Segundo Zeki, o mesmo ocorreu com a teoria da
   plasticidade cortical, que via o cerebro como uma caixa preta e sem nenhuma
   modularidade especifica e tambem com a ideia de processamento linear da
   informacao visual, defendida ate ser contestada pelos experimentos de Hubel e
   Wiesel.
   4.7.5 - ESTRATEGIAS DE INTEGRACAO DA
   INFORMACAO AO LONGO DO PERCURSO VISUAL
   Os diversos estudos sobre o cortex visual apresentam diversas nocoes de
   divisao de trabalho e de segregacao funcional. A nossa experiencia diaria,
   visualizando um mundo uniforme diferente, nos leva a crer na unidade do campo
PA visual e de sua percepcao, onde todos os atributos sao processados
   simultaneamente. Para que essa percepcao seja valida devem ocorrer sofisticados
   metodos e processos de integracao de sinais. Levados pela logica, podemos supor
   que deveria existir uma regiao mestre no cortex, que receberia e seria responsavel
   pela integracao de todas as informacoes. No entanto nao existe uma regiao no
   cortex a qual todas as demais se reportam. Essa afirmativa e valida nao apenas
   para o cortex visual, mas sim para todo o cortex.
   Muito pouco sabemos a respeito das estrategias de integracao de sinais
   utilizadas pelo cortex. Mesmo no bem explorado cortex visual, ainda nao temos
   nenhum perfil de integracao e, diferentemente dos processos de segregacao de
   sinais que foram vastamente estudados, o que e feito sao apenas especulacoes
   sobre essas estrategias. Vamos a seguir apresentar algumas supostas estrategias
   de integracao realizada pelo cortex visual. Com base em algumas evidencias,
   podemos supor tres estrategias basicas para a integracao dos estimulos visuais:
   Aumento do tamanho do campo receptivo, e permitindo que as celulas estejam
   habeis a coletar informacoes de partes maiores do campo visual e que
   respondam ao conjunto de seus estimulos. Observamos, que a medida que
   vamos adentrando o percurso visual, percebemos que as celulas ficam com seus
   campos receptivos cada vez maiores, de modo que o campo receptivo das
   celulas de V1 sao maiores que as do LGN, que por sua vez os campos
   receptivos de V2 sao maiores que V1 e menores que V3, que por sua vez e
   menor que V5. Finalmente quando comparamos os campos receptivos das
   celulas do cortex inferotemporal e parietal notamos que sao maiores que as das
   157
   CAPITULO 4
   areas do cortex visual.
   Aumento da complexidade do estimulo. Ocorre simultaneamente com a primeira (i),
   uma vez que as celulas aumentam seus campos receptivos, automaticamente
   elas tratam com sinais cada vez mais complexos e propriedades mais
   especificas. A Figura 4.31 apresenta exemplos das estrategias (i) e (i ).
   Unificacao dos sinais de diferentes fontes, representando diferentes atributos
   visuais (ex: forma e movimento). A unificacao nao significa necessariamente que
   os sinais devam ser direcionados para uma celula especifica, uma possibilidade
   e que a unificacao venha a ser realizado por celulas distantes respondendo em
   sincronismo a um evento em comum [Zeki, 1993].
   158
   OS CAMINHOS PARALELOS DA VISAO
   (a)
   (b)
   (c)
   Fig. - 4.31 - Estrategias de integracao de sinal visual atraves do aumento do
   campo receptivo e da complexidade do estimulo. (a) (reta) Celulas centro-
   periferia do LGN e celulas simples de V1. (b) (cor) Projecao das celulas dos
   "blobs" em V1 para faixas finas em V2 e finalmente em V4, observar a
   piramide de projecao. (c) (movimento) Enquanto em V1 as celulas sao
   estimuladas pela orientacao das bordas independentes (um vetor de direcao
   para cada lado) ocorre a integracao em V5, de modo que suas celulas sao
   capazes de fornecer a direcao do objeto. [Zeki, 1993]
   159
   CAPITULO 4
PA 4.7.6 - INTEGRACAO DA INFORMACAO DOS DOIS
   HEMISFERIOS
   O nivel mais alto de paralelismo do processamento visual que encontramos
   no cortex e demonstrado pela divisao do cerebro em dois hemisferios. Como ja
   apresentamos, a aquisicao de todo o campo visual e realizada em cada uma das
   retinas e reorganizadas (quiasma optico) de modo que o cortex visual de cada
   hemisferio receba estimulos correspondentes a uma metade do campo visual.
   Embora exista essa divisao no campo visual, o sistema de visao possui uma
   integracao perfeita, sendo que nos e impossivel percebe-la.
   O corpo caloso e um corpusculo formado pela aglomeracao de fibras, cuja
   principal caracteristica e a conexao dos dois hemisferios. Atraves do corpo caloso
   as areas pares de cada hemisferio sao interconectadas e assim o cerebro e
   integrado. Em geral, as conexoes sao organizadas de forma bem definida e distinta
   em uma das areas corticais, formando um bom referencial sobre o numero e a
   divisao destas. Cada area e conectada separadamente com sua correspondente no
   hemisferio oposto, exatamente porque as duas metades (uma em cada hemisferio)
   possuem mecanismos que sao diferentes das outras areas e assim requerem
   conexoes separadas.
   Como sabemos, o cortex visual estriado possui um mapeamento topografico
   preciso da retina. Deste modo, seria de se esperar que apenas as regioes
   posicionadas na linha divisoria do campo visual possuissem conexoes entre
   hemisferios. De fato e exatamente isso que ocorre nas conexoes entre o cortex
   visual primario e o corpo caloso, onde a sua regularidade traca exatamente a linha
   do meridiano vertical do campo visual em cada hemisferio.
   Como o cortex visual primario, V2 possui um mapeamento topografico
   preciso da retina, apresentando tambem conexoes com o corpo caloso, presentes
   apenas nas celulas da linha divisoria do campo visual. Desta forma, seu tracado
   corresponde exatamente ao meridiano vertical do campo visual. A medida que
   avancamos no cortex visual as areas se tornam mais especificas e abstratas e,
   consequentemente, seus mapas ficam cada vez mais desorganizados em relacao a
   topografia da retina. Assim, a conexao das areas com o corpo caloso nao formam
   mais uma trilha de indicacao do meridiano do campo visual, ja que as celulas
   correspondentes a essa regiao encontram-se espalhadas. Enquanto V1 e V2
   apresentam uma estrutura muito definida, tracando o limiar do campo visual, V3
   160
   OS CAMINHOS PARALELOS DA VISAO
   possui conexoes espalhadas e, V4 e V5 nao possuem nenhum tipo de ordenacao
   clara na conexao com o corpo caloso.
   Alem de caracterizar as diferentes areas espalhadas pelo cortex e definir a
   precisao do mapeamento topografico da retina nas diferentes areas do cortex
   visual, o corpo caloso tambem evidencia o paralelismo entre hemisferios e entre
   areas. O primeiro caso e bastante obvio, a simples existencia de dois hemisferios
   por si so e uma prova de paralelismo nesse nivel. Em relacao ao paralelismo entre
   areas, para que ela ocorra e necessario que as diferentes areas do cortex visual
   apresentem uma representacao completa do campo visual. A conexao com o corpo
   caloso, independente entre cada uma das areas e a indicacao de que cada area
   possui sua propria representacao completa do campo visual atraves da conexao
   com seu par no outro hemisferio, indicando consequentemente sua independencia
   e paralelismo.
   161
PA CAPITULO 4
   162
   CAPITULO
   5
   CYVIS-1 E YNERGOS
   163
   CAPITULO 5
   164
   Cyvis-1 e ynergos
   CAPITULO 5 - CYVIS-1 E YNERGOS
   5.1 - INTRODUCAO
   Neste capitulo iremos apresentar os projetos que motivaram e constituiram
   os principios para o desenvolvimento do trabalho apresentado nesta tese.
   Conforme ja apresentamos, uma das bases da visao natural e o seu
   processamento paralelo. Entretanto, a visao artificial nao vem utilizando este
   recurso como prioridade de pesquisa. A vasta maioria da literatura sobre visao
   computacional, visao artificial e processamento de imagens tem uma forte
   tendencia sequencial. Isso se deve principalmente aos fundamentos dessas areas,
   se tomarmos os livros mais classicos, e entre eles a biblia da visao, o livro "Vision"
   de David Marr [Marr, 1982]. Embora siga a linha da inspiracao biologica, Marr, nao
   considerou esse recurso, que como vimos, foi plenamente explorado pela natureza
   nos sistemas de visao.
   Apresentaremos neste capitulo dois projetos audaciosos do grupo de visao
   cibernetica do IFSC - USP. O primeiro e o Cyvis-1, um sistema de visao versatil,
   fortemente inspirado em biologia, mais especificamente no modelo da
   especializacao funcional do cortex visual. Assim como os sistemas biologicos, o
   Cyvis-1 se caracteriza pelo perfil modular, onde cada modulo e especializado em
   um atributo visual. Assim como o modelo biologico, o projeto e baseado em
   processamento paralelo. Apresentaremos tambem alguns projetos similares ao
   Cyvis-1 encontrados na literatura e faremos uma breve comparacao explorando as
   vantagens e desvantagens dos sistemas. O outro projeto, ynergos, e um ambiente
   e laboratorio de desenvolvimento e analise de tecnicas de visao e processamento
   de imagens, que tem como objetivo auxiliar a pesquisa, implementacao,
   caracterizacao, validacao de metodos e realizacao de experimentos nestas areas.
   Ambos os projetos possuem em comum o processamento paralelo de
   algoritmos e sistemas de visao. A filosofia de processamento linear agregada a
   visao, a falta de pesquisas abrangentes de paralelismo nessa area, assim como a
   necessidade de ferramentas de desenvolvimento, controle e analise de sistemas
   paralelos para programadores nao-especializados em computacao paralela, foram
   165
   CAPITULO 5
   alguns dos principais fatores de motivacao do nosso trabalho, que serao
   comentados na parte final deste capitulo.
   5.2 - O PROJETO CYVIS-1
   Um dos maiores desafios, senao o maior, na visao artificial, e o
   desenvolvimento de visao versatil. Entendemos por visao versatil a capacidade de
   um sistema se adaptar facilmente a diferentes situacoes e ambientes, assim como
   realizar o reconhecimento visual de objetos diversos. Ao longo da evolucao a
   natureza desenvolveu uma quantidade enorme e variada de sistemas de visao
   versateis, como os sistemas de visao dos vertebrados. A grande maioria dos
PA vertebrados, mesmo os mais primitivos, possuem sistemas de visao capazes de
   responder a uma grande variedade de objetos, nas mais diversas situacoes e
   ambientes. A despeito dos muitos avancos tecnologicos e cientificos, os sistemas
   de visao que somos capazes de construir atualmente, se compararmos sob o
   aspecto da versatilidade no reconhecimento de objetos, sao mediocres em relacao
   aos sistemas de visao dos mais primitivos vertebrados, e ate mesmo de
   invertebrados.
   Normalmente a abordagem classica adotada pelos sistemas de visao e a
   exploracao de poucos atributos e seu tratamento individual, elaborando algoritmos
   cada vez mais sofisticados, mas isolados. Muito temos que aprender com a
   natureza, e de fato diversos algoritmos eficientes de visao foram nela inspirados.
   Entretanto, observando as divergencias entre os sistemas naturais e os artificiais,
   podemos perceber nos sistemas artificiais de visao ausencias de algumas
   estrategias utilizadas pela natureza com exito, das quais podemos citar:
   Estrategias de processamento em duplo sentido, nao apenas indo do baixo nivel
   para alto nivel, mas tambem o sentido inverso ("top-down" e "botton-up");
   Paralelismo: a biologia investiu ao longo da evolucao em estrategias de
   paralelismo, de modo que elas nao apenas possibilitam a execucao em tempo
   real dos sistemas de visao, mas tambem estao intrinsecamente ligados aos
   mecanismos de integracao e compartilhamento de informacoes;
   Modularidade e integracao: estao presentes nos sistemas naturais de visao e sao
   fundamentais para sua grande performance. Estando intimamente associadas as
   estrategias e arquiteturas paralelas adotadas pela natureza [Costa et al., 1994];
   166
   Cyvis-1 e ynergos
   Hierarquia: fundamental para a organizacao da informacao e dos processos, ainda
   mais quando de modo nao linear, conforme sugerido pelos itens anteriores;
   Representacao visual efetiva. [Costa et al., 1994]
   Cyvis-1, cujo nome e derivado do ingles "Cybernetic Vision System 1" e um
   ambicioso projeto do nosso grupo de pesquisa, fortemente inspirado na biologia,
   cujo intuito e o desenvolvimento de um sistema de visao versatil capaz de se
   adaptar de modo quase automatico a diferentes tipos de problemas de visao [Costa
   et al., 1994]. Uma das bases para o desenvolvimento do Cyvis-1 e o estudo e a
   incorporacao de estrategias de paralelismo, uma vez que a natureza nos demonstra
   que para o problema de visao nao sao apenas necessarias sofisticadas
   representacoes e algoritmos, mas tambem estruturas paralelas/concorrentes para,
   alem de atender no menor tempo possivel a enorme quantidade de dados
   necessarios para o processamento (especialmente nos niveis mais baixos), forca
   tambem a constituicao de estruturas modulares e hierarquicas, capazes de trocar
   informacoes durante o processamento, efetuando deste modo a sua integracao.
   5.2.1 - APRENDENDO COM A NATUREZA
   A engenharia reversa realizada em sistemas biologicos e uma linha de
   pesquisa que, devido ao seu sucesso, esta se tornando cada vez mais popular.
   Deste modo, ao inves de reinventarmos as solucoes, analisamos o modo pelo qual
   a natureza em milhoes de anos de evolucao solucionou seus problemas. Essa linha
   de raciocinio e um dos pilares fundamentais da Visao Cibernetica, que procura na
   biologia a solucao para os problemas de visao artificial. Seguindo esta estrategia,
   encontramos a base do sistema de visao artificial Cyvis-1, cuja principal
   caracteristica e a sua forte inspiracao biologica. Nesta secao, vamos apresentar
   alguns dos principais principios biologicos de processamento, representacao e
PA organizacao incorporados no projeto Cyvis-1 [Costa et al., 1994].
   5.2.1.1 - PARALELISMO, DISTRIBUICAO DE PROCESSOS E
   TROCA DE MENSAGENS
   Tradicionalmente, os sistemas de visao artificiais sao sequenciais. A figura
   5.1 apresenta um diagrama de um sistema de visao artificial classico, nele
   encontramos um dispositivo de aquisicao de imagens, um modulo de pre-
   167
   CAPITULO 5
   processamento, o qual realiza algumas operacoes de tratamento de imagem, um
   modulo de processamento primario, o qual extrai caracteristicas basicas da
   imagem, como as bordas por exemplo, e um ou alguns poucos modulos de
   processamento de atributos, que extrai as propriedades da imagem e finalmente o
   modulo de classificacao, que recebe os resultados. Ao contrario dessa abordagem,
   a natureza, ao longo de milhoes de anos de evolucao, investiu profundamente no
   paralelismo, e nos ensina que esta e uma solucao natural para a questao da visao.
   cena
   Aquisicao
   Pre-
   de imagens
   processamento
   camera
   Processamento
   Processamento
   Processamento
   de atributo 3
   de atributo 2
   de atributo 1
   Classificacao
   Resultado
   Fig. - 5.1 - Diagrama de um sistema de visao artificial classico.
   Quando pensamos em paralelismo, a primeira questao que nos vem a
   mente e o desempenho, uma vez que basicamente utilizamos o paralelismo com o
   intuito de aumentar a performance de sistemas que necessitem de respostas
   rapidas e demandem grande poder computacional. Sem duvida alguma, o
   desempenho e uma questao muito importante. Especialmente para os sistemas de
   visao versatil que, tentando resolver diversos problemas, tem necessariamente que
   se defrontar com uma serie destes que estao envolvidos diretamente com
   processamento em tempo real. Nesse contexto, a situacao se agrava ainda mais,
   uma vez que a visao utiliza algoritmos dispendiosos que demandam grande poder
   computacional, e que se tornam muitas vezes impraticaveis, especialmente com
   imagens de alta resolucao, devido ao tempo de execucao prolongado e
   consequentemente um elevado uso de recursos computacionais.
   No entanto, a natureza demonstra que sua opcao pelo paralelismo nao se
   deu unica e exclusivamente devido ao beneficio do aumento de desempenho (uma
   vez que os neuronios sao relativamente lentos). O paralelismo esta diretamente
   168
   Cyvis-1 e ynergos
   relacionado com inumeras outras questoes, que juntas caracterizam o sistema
   visual. A natureza modularizou e distribuiu o sistema visual de modo que os
   atributos visuais (cor, textura, formas, estereo, movimento e etc.) pudessem ser
PA executados concomitantemente. Alem disso, como discutimos no Capitulo 4, cada
   um dos modulos e ainda formado por inumeras estruturas concorrentes. Ademais,
   os sinais sao separados e percorrem caminhos diferentes ao longo de todo o
   sistema, caracterizando a sua distribuicao. Dentro do conceito de modulos e
   multiplos caminhos, o paralelismo, a distribuicao de processos e a troca de
   mensagens desempenham um papel fundamental, uma vez que informacoes sao
   trocadas entre os modulos de diferentes atributos, assim como de diferentes
   estagios dentro de um mesmo caminho, de modo a aprimorar o processamento
   visual. Esse tipo de processamento colaborativo nao teria sentido em um regime de
   processamento sequencial.
   Alem do trabalho cooperativo entre o processamento simultaneo de
   diferentes atributos, o cortex tambem apresenta a integracao e colaboracao de
   diferentes niveis de conhecimento. Ao mesmo tempo que as informacoes sao
   processadas de baixo para alto nivel, o mesmo ocorre em sentido inverso, e a troca
   de mensagens entre esses dois sentidos realiza a integracao das informacoes,
   aumentando o poder de processamento e reconhecimento de padroes do sistema
   biologico. Novamente, esse tipo de estrategia nao teria sentido sem a utilizacao de
   uma arquitetura massivamente paralela.
   5.2.1.2 - ALTA RESOLUCAO PARA A REPRESENTACAO DE
   IMAGENS
   Esta e uma das licoes mais basicas que a natureza nos ensina. Por
   questoes de desempenho, e ainda raro encontrar um sistema de visao artificial que
   exceda a dimensao de 512x512 (262144 pontos), no entanto os sistemas naturais
   de visao apresentam resolucoes de ordens muito maiores. Na retina de cada um
   dos olhos dos seres humanos, sao encontradas cerca de 126 milhoes de
   fotorreceptores. A indicacao que podemos tirar dessa grande diferenca e de que
   resolucoes mais altas podem aumentar substancialmente a performance da
   qualidade em reconhecimento de padroes, assim como dos resultados das tecnicas
   de processamento de imagens.
   169
   CAPITULO 5
   Evidentemente, o aumento da resolucao do sistema aumenta
   proporcionalmente o custo computacional do processamento, especialmente nos
   primeiros estagios da visao, que de um modo geral, operam a imagem pixel a pixel
   e usualmente utilizam metodos que empregam convolucoes, tornando ainda mais
   drastico o tempo de processamento e o consumo de poder computacional, devido
   ao grande numero de multiplicacoes utilizadas [Levine, 1985]. Para solucionar esse
   problema, a natureza utiliza o processamento massivamente paralelo, replicando as
   estruturas de processamento nos modulos, processando diversos modulos
   simultaneamente e ate mesmo desenvolvendo mecanismos de processamento
   paralelo de sinais intimamente ligados as estruturas de aquisicao de imagem (o
   maquinario neural encontrado na retina). Este e mais um ponto que evidencia a
   necessidade do paralelismo, que e uma das bases do projeto.
   5.2.1.3 - HIERARQUIA
   Organizacao hierarquica do processamento sempre foi caracteristica dos
   sistemas de visao artificiais, sendo talvez uma consequencia natural do
   processamento visual. No sistema de visao dos primatas, a hierarquia e bem nitida
   e pode ser sintetizada pela sequencia: retina, nucleo lateral geniculado, cortex
   visual e areas corticais de alto nivel. A cada estagio hierarquico a informacao visual
   se torna mais compacta e mais abstrata e complexa, incorporando cada vez mais
PA informacoes. Assim como os demais principios apresentados aqui, a hierarquia
   tambem esta relacionada diretamente com outros topicos, especialmente com a
   modularidade, paralelismo e com a representacao visual efetiva.
   5.2.1.4 - TRAFEGO DA INFORMACAO EM SENTIDO DUPLO
   Um principio que exerce um papel fundamental no desempenho do
   reconhecimento de padroes dos sistemas biologicos e a realimentacao de
   informacoes ou o duplo sentido da informacao. A vasta maioria dos sistemas de
   visao artificial apresentam apenas um unico sentido no trafego de imagem, o qual
   vai dos niveis baixos para os niveis altos de processamento. Entende-se por nivel
   baixo de processamento, os processamentos primarios, tais como deteccao de
   bordas, normalizacao de histograma, suavizacao e etc. A medida que as
   informacoes processadas vao ficando mais complexas (retas, regioes, formas,
   objetos e etc.), dentro dessa nomenclatura, o processamento vai se tornando de
   170
   Cyvis-1 e ynergos
   nivel mais alto.
   Nos sistemas de visao biologicos o trafego das informacoes e realizado em
   sentido duplo. Deste modo, tanto os modulos de baixo nivel transmitem
   informacoes para os de alto nivel, como o reverso tambem ocorre. A grande
   vantagem dessa estrategia e que as informacoes processadas de alto nivel,
   armazenadas em processamentos realizados anteriormente, quando enviadas para
   os modulos de processamento de baixo nivel, contribuem para a eficacia e
   performance de seus processamentos, enriquecendo a informacao visual.
   Ocasionalmente, quando observamos um objeto ou uma cena, e temos uma
   percepcao instantanea que nao condiz com a realidade, muitas vezes isto e fruto de
   um erro concebido pelo fluxo de informacoes de alto para baixo nivel.
   5.2.1.5 - MODULARIDADE
   Principalmente devido a caracteristica de plasticidade apresentada em
   determinadas situacoes pelo cortex, nos primordios da neurociencia, acreditava-se
   que o cerebro, mais especificamente o cortex, era uma massa uniforme, dividida
   apenas entre regioes de motoras - sensoriais e memoria associativa [Zeki, 1993].
   Essa antiga crenca ainda influencia o ambito computacional que se inspira em
   neurociencias. Podemos observar que a grande maioria das redes neurais artificiais
   sao caracterizadas por interconexoes uniformes constituidas de apenas um unico
   tipo de neuronio artificial. A pesquisa cientifica, entretanto, elucidou essa questao e
   pos fim a crenca da uniformidade. Como sabemos o cortex, longe de ser uniforme,
   apresenta arquiteturas e conexoes distintas em diferentes regioes. Tomando
   apenas o exemplo da cortex visual, o capitulo anterior apresenta diferentes
   arquiteturas que caracterizam as diferentes areas do cortex visual.
   A modularidade apresenta para os sistemas de visao a utilizacao de uma
   organizacao logica e estrutural, que proporciona, as bases para o processamento
   paralelo, assim como inumeras outras vantagens nos aspectos arquitetonicos, que
   sob o ponto de vista computacional sao vitais. Ferramentas e metodos para a
   modularizacao do software e hardware sao vitais para a ciencia da computacao,
   como bom exemplo disso podemos citar a programacao orientada a objetos em
   software, assim como o desenvolvimento do circuito integrado em hardware.
   171
   CAPITULO 5
   5.2.1.6 - REPRESENTACAO VISUAL EFETIVA
   Uma das questoes mais importantes nos sistemas de processamento de
PA dados consiste no modo pelo qual a informacao sera representada. Esse ponto e
   importante para os sistemas de processamento visual, uma vez que operam em
   grandes quantidades de dados, que sao armazenados sucessivamente para cada
   um dos estagios do processamento. No modelo biologico, a preocupacao com a
   representacao visual e claramente observavel, e aqui vamos tomar como exemplo o
   sistema visual dos primatas e suas diferentes representacoes ao longo de sua
   hierarquia.
   A imagem projetada na retina e convertida em sinal nervoso por cerca de
   126 milhoes de fotorreceptores, dos quais existem duas classes principais (cones e
   bastonetes) que possuem sensibilidades distintas. De modo, temos dois mapas
   com representacoes especificas. Na retina, e realizado um pre processamento de
   deteccao de borda pelo seu maquinario neural, que culmina nas celulas
   ganglionares. Os dois mapas sao entao reorganizados e as suas representacoes
   compactadas. Assim as imagens sao representadas pelas terminacoes nervosas de
   apenas 800 mil celulas ganglionares, que formam o nervo optico. Se nao ocorresse
   o pre processamento e uma representacao mais efetiva do sinal, o nervo optico
   seria muito maior, desperdicando recursos, que a natureza prima por economizar.
   Segundo Marr [Marr, 1982], isso e possivel devido a riqueza das informacoes
   contidas nas bordas, que sao suficientes para representar grande parte da cena.
   Dos ganglios da retina a informacao e entao enviada para o LGN, que entao
   redistribui representacoes distintas para entradas especificas do cortex visual
   primario, onde e realizado processamento de um nivel mais alto. Nessa etapa as
   informacoes sao representadas de forma a arranjar contextos mais ricos, tais como
   mapas cromaticos, mapas de segmentos de retas, disparidade e movimento, entre
   outros. Embora ainda sejam pouco conhecidas as representacoes em escalas
   ainda maiores, devido ao comportamento do cortex de elaborar representacoes
   mais abstratas e complexas a partir das anteriores, podemos presumir, nessa linha
   de raciocinio, que existem representacoes abstratas capazes de conter de forma
   concisa e precisa, objetos e cenas inteiras.
   5.2.1.7 - ESPECIALIZACAO DE PROCESSOS
   A antiga crenca na uniformidade do cortex, alem de influenciar as questoes
   172
   Cyvis-1 e ynergos
   estruturais e arquiteturais, como vimos na Secao 5.2.1.5, tambem caracterizou de
   modo improprio o seu aspecto funcional. Deste modo, acreditava-se que todas as
   partes do cortex eram capazes de realizar qualquer tipo de processamento, e que
   nao existiam centros ou regioes repensaveis por determinados atributos. A partir da
   localizacao da area Broca [Broca, 1861], esse conceito mudou e, mais tarde, com a
   descoberta das areas especializadas no cortex visual, a teoria da especializacao
   funcional do cortex veio a se consolidar. Deste modo alem de apresentar modulos
   com perfil arquitetonico e estrutural distintos, cada um desses modulos possui
   tambem funcoes distintas.
   Nos primatas, assim como em outros mamiferos de ordem superior, o
   processamento dos atributos visuais (movimento, orientacao, cor, textura e etc.) e
   realizado por distintas especializacoes de processamento [Zeki & Shipp, 1988]
   [Livingstone & Hubel, 1988] [Zeki, 1993] [Hubel, 1995] [Levine & Shefner, 1991]
   [Julesz, 1995]. A segregacao do sistema visual inicia-se ja na retina, alem de
   possuir diferentes celulas fotorreceptoras possui tambem caminhos diferentes de
   processamentos: magnocelular e parvocelular. Esses caminhos sao novamente
   divididos no LGN e no cortex visual, de modo que cada area ou modulo
PA especializado do cortex visual receba um fluxo de sinal principal, proveniente de um
   caminho com um sinal especifico. Essa caracteristica, alem de fundamentar o
   processamento especializado, tambem o define como distribuido. Deste modo, a
   especializacao de processos e caminhos, do ponto de vista computacional, permite
   um alto grau de paralelismo.
   5.2.1.8 - INTEGRACAO DE MULTIPLOS ESTAGIOS
   Os principios discutidos anteriormente, modularidade, hierarquia,
   paralelismo, troca de mensagens, trafego de sinais em duplo sentido e
   especializacao de processos, constituem a organizacao funcional do cortex. Uma
   de suas principais caracteristicas e a interconexao entre os modulos e caminhos
   especializados (atributos especificos) assim como entre os diferentes estagios
   hierarquicos, e foi denominada por Zeki e Shipp [Zeki & Shipp, 1988] de Integracao
   de multiplos estagios. Atraves dessa estrutura, os modulos especialistas que
   compoem um caminho ou atributo visual podem trocar informacoes em qualquer
   estagio hierarquico com modulos de outros atributos, possibilitando complementar a
   informacao. A colaboracao entre os modulos, permite uma precisao e performance
   melhores no reconhecimento dos objetos ou regioes da imagem.
   173
   CAPITULO 5
   A colaboracao entre os modulos inspirou profundamente o projeto Cyvis-1 e
   constitui atualmente um dos maiores desafios, uma vez que pouquissimos sistemas
   artificias utilizam caracteristicas de auxilio mutuo entre modulos, e quase nenhuma
   referencia na literatura apresenta essa integracao de atributos em visao artificial.
   5.2.1.9 - VISAO FOVEAL
   Uma diferenca muito grande entre os sistemas artificiais e os naturais esta
   presente na estrategia de aquisicao de imagens. Em visao artificial,
   tradicionalmente, as imagens sao captadas por cameras de video (estaticas), que
   registram e convertem toda a cena em matrizes lineares de duas dimensoes. Deste
   modo, toda a cena capturada e armazenada e cada um dos pixels da imagens (ou
   elementos da matriz) sao processados igualmente. Conforme comentamos na
   Secao 4.6.2.1, a distribuicao dos fotorreceptores na retina nao e linear, e a maior
   concentracao na regiao central ou fovea faz com que essa regiao tenha uma
   resolucao muito maior do que as demais. A regiao foveal compreende uma
   pequena porcao do campo visual e a maioria do maquinario neural esta envolvida
   especificamente com o seu processamento.
   Para a compreensao total de uma cena, o sistema visual utiliza a
   movimentacao dos olhos, e consequentemente da fovea, por toda a cena,
   processando-a regiao por regiao. A figura 5.2 ilustra essa situacao, onde foi
   registrada o percurso da regiao foveal humana em uma cena durante sua
   percepcao.
   (a)
   (b)
   Fig. - 5.2 - Movimento dos olhos durante a percepcao de uma face. Os tracos
   da figura (b) apresentam a posicao da regiao central dos olhos durante o
   rastreamento para a percepcao da imagem [Dowling, 1992] [Hubel, 1995].
   Embora a uma primeira instancia possa parecer mais objetiva a estrategia
   de captar toda a cena de uma so vez, com alta resolucao em matrizes lineares,
   esse tipo de abordagem apresenta diversas desvantagens em relacao ao sistema
   174
   Cyvis-1 e ynergos
PA foveal, entre as quais podemos citar:
   Alto custo com hardware e pouca compactacao: Se o sistema de visao humano nao
   fosse foveal, certamente o complexo de celulas do sistema neural nao caberia
   na caixa craniana.
   Alto custo computacional: Preferindo uma pequena parte, ao inves de todo o campo
   visual, o poder computacional e economizado, considerando-se custosos
   algoritmos de processamento de sinais.
   Tempo de processamento: O elevado custo computacional acarreta num tempo
   maior de processamento.
   Menor interacao com a imagem: Uma vez que o tempo de processamento e maior,
   o sistema tem um tempo de resposta igualmente maior e, deste modo, possui
   interacao menor, necessaria especialmente quando se trata de operacoes que
   envolvem movimentos.
   5.2.1.10 - ATENCAO SELETIVA
   O paralelismo, nos sistemas visuais naturais, possui uma estrutura
   piramidal, de forma que a base da piramide, formada pelos estagios de baixo nivel,
   sao massivamente paralelos, e a medida que a escalamos, encontramos estagios
   de processamento de niveis cada vez mais altos e com menor paralelismo, de
   modo que no topo da piramide os processos sao quase sequenciais.
   A atencao seletiva e um mecanismo atraves do qual os sistemas de alto
   nivel concentram temporariamente a atencao em regioes ou objetos localizados na
   fovea, obtendo uma analise detalhada dos elementos da imagem um por um. Assim
   como na visao foveal, onde a cena e rastreada pela regiao central da retina atraves
   dos movimentos dos olhos e depois integrada como um todo pelo cortex, na
   atencao seletiva, cada detalhe, regiao ou objeto localizado na fovea, e rastreado
   atraves de atencao dedicada, um a um, e sao integrados pelo cortex formando um
   conjunto detalhado.
   5.2.1.11 - INTEGRACAO COM NIVEIS DE CONHECIMENTO
   MAIORES
   Esse principio esta diretamente relacionado com o alto nivel de aprendizado
   que os sistemas naturais utilizam. Assim, o processo visual atraves de consultas a
   175
   CAPITULO 5
   memoria, realiza uma analise de contexto, ambiente, localizacao e historia,
   comparando a cena com observacoes anteriores reconhecidas e registradas, o
   sistema pode receber informacoes adicionais e deste modo proceder o
   reconhecimento. A figura 5.3 apresenta um exemplo de como nossa percepcao e
   fortemente influenciada pela analise de contexto. A analise das retas do corredor,
   dao uma informacao contextual de distancia, de modo que na imagem (a) temos a
   impressao que uma pessoa esta distante da outra, e na (b) ocorre uma situacao
   diferente da percepcao normal a que fomos treinados ao longo de nossas vidas, e
   portanto temos a ideia de que e uma miniatura. Observem tambem que as duas
   mulheres tem o mesmo tamanho na imagem, entretanto percebemos que a da
   imagem (a) e maior.
   (a)
   (b)
   Fig. - 5.3 - Importancia do contexto na percepcao visual humana. Embora
   sejam do mesmo tamanho, na imagem (b) a figura da mulher a direita parece
   menor do que a da imagem (a) [Dowling, 1992].
   5.2.2 - O SISTEMA DE VISAO CIBERNETICA - CYVIS-1
PA Com o intuito de prover a visao versatil nasceu um dos mais audaciosos
   projetos do Grupo de Visao Cibernetica, o Cyvis-1, que foi introduzido em 1994 por
   Costa e colaboradores [Costa et al., 1994]. Com base em modelos de visao
   biologica, especialmente no modelo de integracao de estagios multiplos do
   processamento visual do cerebro dos primatas, proposto por Zeki e Shipp [Zeki &
   Shipp, 1988], o sistema de visao cibernetica Cyvis-1 e um modelo conceitual para a
   visao versatil em tempo real.
   Devido a grande dificuldade proporcionada e ao seu caracter de vanguarda
   176
   Cyvis-1 e ynergos
   e pioneirismo, o projeto foi idealizado num plano de pesquisa de longa duracao, do
   qual participarao diversos pesquisadores. Atualmente, o projeto encontra-se na fase
   inicial, que consiste na implementacao de prototipos, visando o estudo do
   comportamento de sistemas de visao sob o aspecto de distribuicao e integracao de
   tarefas, assim como no desenvolvimento de algoritmos mais eficientes para cada
   uma das etapas dos modulos de processamento especifico. Nesta secao iremos
   descrever o projeto, assim como alguns itens da sua implementacao.
   Fig. - 5.4 - Diagrama de blocos do modelo estrutural do sistema Cyvis-1,
   apresentando sua organizacao geral. Adaptado de [Bruno & Costa, 1997]
   [Costa et al., 1994].
   A figura 5.4 apresenta um diagrama de blocos do modelo estrutural do
   sistema de visao cibernetica. A organizacao geral do Cyvis-1 consiste em um
   conjunto de sistemas dedicados, responsaveis pelo processamento e analise
   independente de atributos visuais (cor, bordas, formas, textura, estereo e etc.),
   representados pelas barras horizontais, um par de cameras, responsavel pela
   captura das imagens e o modulo de controle.
   Os sistemas dedicados sao responsaveis pelo processamento dos atributos
   visuais especificos. O processamento e dividido em diferentes estagios, que
   177
   CAPITULO 5
   obedecem a uma escala hierarquica correspondente ao seu nivel de
   processamento visual. A escala hierarquica de processamento visual possui
   natureza similar ao caminho visual do sistema de visao biologico, que, como vimos
   no Capitulo 4, inicia-se com o processamento de baixo nivel na retina, onde sao
   extraidas caracteristicas fundamentais da imagem (ex: bordas) e prossegue pelo
   processamento no LGN, cortex visual primario, secundario e demais areas corticais,
   onde em cada etapa do caminho visual as informacoes vao se tornando mais
   complexas, mais abstratas e representativas (exemplo: bordas -> retas -> formas ->
   objetos). Deste modo, o sistema dedicado e dividido em diversos modulos, sendo
   que cada um e responsavel pelo processamento individual dos niveis do caminho
   visual do atributo.
   Os modulos sao representados na figura 5.4 por pequenas caixas no interior
   das barras horizontais, onde os responsaveis pelos processamento de baixo nivel
   estao a esquerda e os de alto nivel a direita. Assim, a imagem capturada pela
   camera e transmitida para o modulo de mais baixo nivel, e apos ser processada,
   gera um mapa, que e enviado para o proximo modulo da hierarquia e assim
   sucessivamente ate o nivel mais elevado. Como nos sistemas biologicos, ocorre
   tambem o sentido inverso do fluxo de informacao, indicado pelo duplo sentido das
   conexoes entre os modulos. Em algumas ocasioes, o alto nivel realimenta os
   modulos de baixo nivel com informacoes de imagens processadas anteriormente,
PA contribuindo no processamento e reconhecimento da cena.
   Assim como nos sistemas biologicos, cada modulo dos sistemas dedicados
   possui um metodo de representacao de dados particular e estrategia de
   processamento propria. Deste modo, os modulos de baixo nivel possuem
   representacoes mais generalizadas, menos abstratas e que necessitam de maior
   espaco de armazenamento. A medida que subimos nas etapas hierarquicas de
   processamento, as informacoes vao ficando mais concisas, especificas e abstratas
   e consequentemente necessitam de um espaco menor para o armazenamento.
   Assim como ocorre uma alteracao evolutiva na forma de representacao dos
   dados, o mesmo acontece com a estrategia de processamento. Nos modulos de
   baixo nivel, o processamento e mais localizado, independente e em geral requer
   um numero maior de operacoes aritmeticas, bem como maiores recursos
   computacionais. Entretanto, devido a sua natureza de processamento disperso e
   independente, os niveis mais baixos possibilitam estrategias de paralelismo mais
   eficientes. Por outro lado, os niveis mais altos, envolvem processamentos com
   178
   Cyvis-1 e ynergos
   maior dependencia de dados e mais globalizados, tornando-se cada vez menos
   viavel a implementacao paralela de seus algoritmos, chegando a niveis
   predominantemente sequenciais, como por exemplo, os algoritmos de classificacao.
   Alem das conexoes horizontais, que como vimos integram os diferentes
   modulos de processamento de um atributo especifico, o Cyvis-1 possui tambem
   conexoes verticais, que ligam os sistemas dedicados permitindo a troca de
   informacoes entre atributos. E atraves destas conexoes verticais que ocorre a
   colaboracao entre os sistemas dedicados. Como exemplo, vamos explicar a
   colaboracao entre os sistemas dedicados a bordas e cor: suponhamos que o
   sistema dedicado ao processamento de bordas nao consiga definir as bordas de
   uma determinada regiao da imagem. Entao, o sistema dedicado ao atributo borda,
   requer ao sistema dedicado ao atributo cor informacoes adicionais sobre essa
   regiao, e, de posse das informacoes recebidas, as bordas da regiao, podem ser
   agora reconhecidas.
   Todos os sistemas dedicados sao controlados pelo modulo mestre, que
   alem de manipular o fluxo das informacoes em cada atributo, pode tambem
   concentrar temporariamente todo o processamento dos sistemas em uma
   determinada regiao da imagem, ou em um atributo especifico, assim como a
   atencao seletiva dos sistemas biologicos. O mestre e tambem responsavel pelo
   gerenciamento da base de conhecimento global do sistema e pela classificacao e
   reconhecimento final. Para isso, recebe as informacoes resultantes dos
   processamentos de cada atributo. Cada sistema dedicado e tambem provido de
   uma base de conhecimento local, utilizada para decisoes independentes da
   supervisao do mestre. O fluxo de execucao e em parte determinado pelos proprios
   sistemas dedicados, tomando decisoes a partir de sua base de conhecimento local,
   e em parte pelo mestre, que e responsavel pelo processamento total e pelas
   decisoes sobre o foco de atencao.
   5.2.3
   -
   IMPLEMENTACAO,
   REQUISITOS
   E
   NECESSIDADES
PA Nesta secao iremos abordar os principais requisitos, necessidades e
   dificuldades de implementacao do projeto Cyvis-1, alem dos diversos desafios
   179
   CAPITULO 5
   cientificos e tecnologicos encontrados em: visao computacional, processamento de
   imagens, computacao paralela, sistemas distribuidos, integracao de atributos
   visuais, controle e escalonamento de tarefas, e outros mais. O projeto tambem se
   confronta com a dificil tarefa de integrar os recursos humanos envolvidos.
   Conforme ja comentamos, trata-se de um projeto ambicioso de longa duracao, que
   utiliza o trabalho cooperativo de diversos pesquisadores.
   O primeiro passo a ser dado para se iniciar a implementacao e a definicao
   da plataforma de desenvolvimento. Essa definicao engloba a escolha da plataforma
   de hardware, do sistema operacional e das ferramentas e linguagens de
   programacao. A decisao desses requisitos foi baseada primordialmente nas
   ferramentas de desenvolvimento. O grupo de Visao Cibernetica possui hoje como
   plataformas de desenvolvimento o MATLAB [Etter, 1995] e o Scilab [Gomes et al.,
   1999] para o modelagem matematica dos algoritmos, e o Delphi [Cantu,1995]
   [Calvert, 1999] e o C++ Builder [Calvert, 1997] para a implementacao efetiva.
   Estando todos os membros do grupo familiarizados com estas ferramentas, a
   escolha obvia para a plataforma de desenvolvimento do projeto fixou-se nestas
   alternativas.
   As linguagens de calculo matricial sao excelentes ambientes de
   desenvolvimento, mas podem nao atender os requisitos necessarios para a
   implementacao do sistema, uma vez que alem de lentas (em geral sao
   interpretadas), nao possuem toda a versatilidade das linguagens de uso geral.
   Normalmente, em nosso grupo, os algoritmos desenvolvidos nesses ambientes sao
   convertidos em C++ ou Pascal para sua utilizacao e consequentemente sua
   compilacao nos ambientes Delphi e C++ Builder. Existem tambem ferramentas que
   possibilitam a utilizacao direta dos algoritmos nestes ambientes, tal como o
   Matcom, tambem utilizado pelo grupo [Consularo & Costa, 1998].
   Deste modo, o par Delphi e C++ Builder foi adotado como plataforma de
   desenvolvimento do projeto, uma vez que essa escolha reduz drasticamente a
   curva de aprendizado, pois alem de serem bastante populares e de facil
   aprendizado para novos membros, os pesquisadores atuais do grupo ja estao
   familiarizados com essas ferramentas. E tambem atendem aos requisitos de
   performance, versatilidade de manipulacao de baixo nivel (hardware/sistema
   operacional), programacao orientada a objetos OOP e programacao visual efetiva
   baseada em integracao de ferramenta CASE [Bruno & Costa, 1996] [Bruno & Costa
   1997] [Bruno & Costa, 2000].
   180
   Cyvis-1 e ynergos
   Tendo definido a plataforma de desenvolvimento, temos que fazer a escolha
   dos hardwares e sistemas operacionais. Como escolha de hardware foram
   adotadas maquinas baseadas no padrao IBM-PC, que possuem baixo custo, sao
   populares, e sua performance atingiu o nivel das estacoes de trabalho (ja existem
   hoje maquinas neste padrao, com multiplos processadores, cuja frequencia de
   operacao aumenta a cada dia). Quanto ao sistema operacional, tivemos que fazer
   nossa escolha com base nas plataformas de desenvolvimento. Embora os sistemas
   operacionais baseados em UNIX para IBM-PC possuam mais vantagens quanto ao
   desenvolvimento em sistemas de redes e computacao cientifica, atualmente eles
PA possuem um deficit de ambientes de desenvolvimento integrados (como o Delphi e
   o C++ Builder - programacao visual, OOP, Base de dados, etc.). Devido a tais
   fatores optamos pela utilizacao do Windows 95/98/NT, escolha esta que num futuro
   proximo devera ser estendida, uma vez que o fabricante das ferramentas de
   desenvolvimento escolhidas esta portando-as para UNIX [Kylix].
   Como vimos nas secoes anteriores, devido a sua inspiracao biologica, uma
   das bases de desenvolvimento do projeto Cyvis-1 e o paralelismo. Defrontamos
   assim com um grande desafio para a implementacao do sistema. Ja discutimos a
   importancia do paralelismo na computacao e nos sistemas biologicos, e como
   embora sendo vitais, acarretam uma serie de problemas. O desenvolvimento de
   programas paralelos envolve o aprendizado de linguagens de computacao com
   extensoes paralelas assim como de ferramentas de implementacao paralela. Um
   dos grandes problemas nesses casos e que os algoritmos ja desenvolvidos deverao
   ser portados para a nova plataforma de desenvolvimento, e na grande maioria dos
   casos, adaptados e reescritos. Alem das dificuldades encontradas para portar os
   codigos, encontramos mais um senao. A computacao paralela tem sido voltada, no
   decorrer da historia, ao ambito cientifico apenas. Com isso sua utilizacao se limita,
   na maioria dos casos, a especialistas da area, de modo que pouco se tem pensado
   para minimizar a curva de aprendizado das linguagens e ferramentas para a
   computacao paralela.
   Como ja comentamos, uma das principais linhas de desenvolvimento do
   Cyvis-1 e o trabalho cooperativo realizado por pesquisadores de visao e
   processamento de imagens. Sendo assim, o objetivo principal e que esses
   profissionais possam se integrar facilmente no desenvolvimento de um sistema
   paralelo, aproveitando seus trabalhos ja realizados, sem desperdicio de tempo com
   o longo aprendizado exigido para o dominio das ferramentas tradicionais de
   181
   CAPITULO 5
   computacao paralela. Com a deficiencia de ferramentas de desenvolvimento
   paralelo intuitivas que sejam faceis de usar, assim como pela insipiencia desse
   aspecto nos ambientes de desenvolvimento utilizados pelo nosso grupo, fomos
   motivados a desenvolver uma serie de ferramentas para prover paralelismo nos
   ambientes de desenvolvimento Delphi / C++ Builder e no sistema operacional
   Windows 95/98/NT, a fim de possibilitar o desenvolvimento rapido e efetivo de
   algoritmos de visao e processamento de imagens paralelos, possibilitando deste
   modo a integracao e cooperacao de diferentes pesquisadores para o
   desenvolvimento do sistema. No Capitulo 6 descreveremos esse conjunto de
   ferramentas intitulado de CVMP do ingles "Cybernetic Vision Message Passage".
   5.2.4 - MODELO COMPUTACIONAL
   Tendo discutido as principais caracteristicas conceituais e de
   implementacao, vamos agora apresentar o modelo formal computacional escolhido
   como base para o desenvolvimento inicial do projeto. A figura 5.5 apresenta um
   exemplo de um modelo de implementacao, nele temos 5 computadores IBM-PC
   conectados via rede, representados por blocos horizontais. Neste exemplo, cada
   atributo visual (estereo, cor textura e borda) e processado por uma maquina
   especifica, que e supervisionada pelo sistema mestre, processado tambem em uma
   unica maquina distinta. Alem dessa funcao, a maquina mestre possui tambem uma
   base de conhecimento e um classificador estatistico. A base de conhecimento e
   alimentada a cada processamento pelos resultados dos atributos, atraves dela e
   das bases locais de cada atributo, o sistema realiza o processamento em sentido
PA inverso, ou seja a partir do nivel maior para o menor.
   A classificacao da imagem tambem e de responsabilidade do mestre. A
   medida que e realizado o processamento nos sistemas dedicados de atributos, as
   caracteristicas vao sendo extraidas e enviadas para a unidade mestre. De posse
   das caracteristicas, o mestre consulta o classificador estatistico, e caso a resposta
   da consulta seja satisfatoria para a classificacao, entao o sistema finaliza o
   processamento. Caso contrario, sao aguardadas novas caracteristicas para
   alimentar o classificador, ate que o resultado seja representativo, ou tenham ja sido
   extraidas todas as caracteristicas. Essa estrategia de classificacao por demanda,
   ou seja, a tentativa de classificacao para cada caracteristica extraida, possibilita um
   aumento de desempenho do sistema, uma vez que alguns objetos sao
   182
   Cyvis-1 e ynergos
   reconhecidos com poucas caracteristicas, e deste modo o sistema nao precisa
   executar todos os seu processos, poupando tempo de execucao. Alem do
   desempenho, esta estrategia possibilita tambem um melhor controle de supervisao
   para o mestre. Com os resultados obtidos pela classificacao, o mestre obtem uma
   lista das caracteristicas mais promissoras para uma classificacao agil, e com essa
   informacao, atraves de supervisao, concentra os recursos para priorizar a extracao
   delas.
   Fig. - 5.5 - Diagrama de blocos apresentando a organizacao de hardware do
   Cyvis -1. Neste exemplo, cada atributo de imagem esta sendo processado em
   uma diferente maquina. Os computadores estao conectados por rede.
   Adaptado de [Bruno & Costa, 1997] [Costa et al., 1994].
   As imagens sao capturadas atraves do par de cameras que se encontra
   conectado ao sistema. Apenas o atributo estereo necessita de visao binocular,
   sendo que os demais atributos recebem informacoes provenientes de uma camera.
   Poderiam ser utilizadas duas cameras, trazendo beneficios de informacao, porem
   com maior custo computacional. As cameras sao conectadas diretamente nas
   maquinas de cada um dos atributos. Embora essa medida exija investimento de
   hardware, uma vez que as placas de aquisicao de imagens deverao ser replicadas
   para cada uma das maquina, ela reduz drasticamente o gargalo da distribuicao de
   imagens. Nos primeiros experimentos, ao inves da arquitetura apresentada na
   183
   CAPITULO 5
   figura 5.5, conectamos as cameras no mestre, que tambem ficava responsavel pela
   aquisicao e distribuicao das imagens [Bruno & Costa, 1996]. Observamos no
   entanto que o gargalo gerado pelo processo de distribuicao era demasiado, o que
   comprometia o desempenho do sistema. Atraves de nossas observacoes e do
   trabalho de Cantoni e Lombardi [Cantoni & Lombardi, 1999] chegamos a
   configuracao atual.
   Tendo definido a arquitetura do sistema em termos de hardware e de sua
   funcionalidade vamos agora apresentar o modelo computacional utilizado para a
   implementacao paralela. Dentre os modelos formais para a abordagem paralela,
   optamos pelo paradigma da fazenda de processadores ( processor farm) [Bruno &
   Costa, 1997] [[Inmos, 1989] [Atkin, 1987], que frequentemente possui uma
   utilizacao de processador proxima do ideal. O paradigma da fazenda
   tradicionalmente envolve um processador mestre, que e conectado, na maioria dos
   casos atraves de canais, a um numero de processadores escravos. As tarefas, por
   exemplo subproblemas que podem ser executados independentemente, sao
PA distribuidas pelo mestre de acordo com a disponibilidade dos processadores
   escravos, garantindo assim um bom balanceamento total de carga. Esse paradigma
   e particularmente apropriado quando a comunicacao pode ser realizada em
   concorrencia com o processamento, como ocorre com os Transputers [Inmos,
   1988] [Inmos, 1988b] [Inmos, 1989].
   No caso especifico do Cyvis-1, apos algumas analises, optamos por uma
   abordagem de paralelizacao baseada em uma versao modificada do paradigma da
   fazenda (processor farm). Assim como no paradigma da fazenda de processos
   tradicional, o Cyvis-1 e composto como podemos observar na figura 5.6, de um
   conjunto de escravos supervisionados por um mestre. Estamos nos referindo aos
   modulos retangulares, onde temos 4 sistemas dedicados referentes aos atributos
   cor, borda, textura e estereo, supervisionados pelo mestre. A primeira diferenca
   entre o modelo adotado e o tradicional e que cada um dos modulos responsaveis
   pelos atributos, assim como o proprio mestre, sao sistemas independentes que
   tambem obedecem ao paradigma da fazenda. Assim, cada modulo possui um
   processo mestre, que controla diversos outros processos escravos. Na figura 5.6 os
   processos locais mestre e escravos estao representados pelas letras M e S
   respectivamente.
   184
   Cyvis-1 e ynergos
   Fig. - 5.6 - Modelo de paralelismo adotado.
   Quanto as tarefas, estas sao inicialmente divididas de acordo com os
   atributos, pelo mestre do sistema, e distribuidas para os modulos de atributos. Cada
   uma dessas tarefas sao novamente divididas pelo processo mestre de cada modulo
   e repassada para os escravos. Assim como nos sistemas biologicos, o Cyvis-1
   tambem possui mecanismo para atencao seletiva [Cantoni & Lombardi, 1999]
   [Goncalves, 1999], que esta relacionado com a supervisao e a distribuicao de
   tarefas realizadas pelo mestre do sistema. Deste modo, em determinadas
   situacoes, o mestre pode concentrar o processamento do sistema em uma
   determinada regiao ou atributo, alojando um numero maior de escravos para o
   mestre do respectivo modulo.
   Dentro do sistema estao previstos ainda diferentes tipos de recursos, que se
   classificam segundo a natureza de execucao, entre o seguinte:
   Paralelismo de Maquina: sao processos que sao executados em um unico
   computador conectado pela rede (sistema distribuido).
   Paralelismo de Processador: processos que sao executados em diferentes
   processadores de maquinas com multiplos processadores.
   Multitarefa: sao processos que sao executados concorrentemente, utilizando o
   mesmo recurso de hardware, atraves do mecanismo de multitarefa do sistema
   operacional da maquina.
   Especificos: sao processos que somente podem ser alojados em maquinas que
   contem hardware especifico. Sao exemplos desta modalidade maquinas com
   185
   CAPITULO 5
   placa de aquisicao de imagem ou ainda com dispositivos de processamento de
   sinais especificos.
   Quanto ao alojamento e a distribuicao, os recursos computacionais do
   sistema se dividem em dois grupos:
   fixos: recursos que pertencem a um determinado modulo (atributo ou unidade de
   controle) e executam apenas processos associados a seu modulo, nao podendo
PA ser redirecionados para outros fins.
   moveis: recursos computacionais que podem ser utilizados por qualquer um dos
   modulos do sistema, desde que sejam redirecionados.
   Os processos mestres de cada um dos modulos sao caracterizados por
   utilizar sempre recursos fixos. O escravos podem ser dos dois tipos, um grupo
   pequeno de escravos sao fixos, e somente podem servir a um determinado modulo.
   Desse grupo fazem parte os escravos que necessitem de recursos computacionais
   extra (ex: hardware especifico, placa de aquisicao de imagem e etc.), aqueles
   envolvidos com a base de conhecimento local de cada modulo e ainda os escravos
   fixos por motivos estrategicos, exemplo, encontram-se em condicoes de se
   comunicar mais eficientemente com os recursos computacionais de determinado
   mestre (ex: maquina com processadores multiplos).
   Temos alguns motivos para a mista distribuicao de recursos (parte
   especificos e parte homogeneos) , ao inves do classico conjunto homogeneo de
   recursos ( pool of slaves):
   Maior similaridade com o sistema biologico, que nao prima pela homogeneidade,
   arquitetura e processamento diferente para modulos distintos.
   Possibilidade de incorporacao de hardware dedicado para o processamento
   especifico de determinado atributo visual.
   Os modulos podem manter dados localmente armazenados assim como bases de
   conhecimentos locais.
   Sendo o sistema misto, entre um conjunto homogeneo e outro especifico, podemos
   tirar proveito das vantagens dos sistemas com recursos especificos descritos
   acima e tambem das vantagens de distribuicao, concentracao dinamica de
   recursos e melhor balanceamento de carga dos sistemas homogeneos.
   5.3 - SISTEMAS E MODELOS DE VISAO E SUAS
   186
   Cyvis-1 e ynergos
   COMPARACOES COM O CYVIS-1
   Nesta secao vamos apresentar sucintamente alguns sistemas e modelos de
   visao encontrados na literatura, que possuam caracteristicas similares ao do
   Cyvis-1, especialmente a integracao de atributos, representacao e composicao de
   caracteristicas da imagem, versatilidade de visao e processamento paralelo. Alem
   da breve descricao de cada sistema, vamos discutir suas similaridades e diferencas
   relativas ao Cyvis-1.
   5.3.1 - SISTEMA INTELIGENTE PARA SEGMENTACAO
   BAIXO NIVEL DE IMAGENS
   O sistema inteligente para segmentacao de imagens, ou LLIS (do ingles:
   Low Level Image Segmentation), proposto por Nazif e Levine [Nazif & Levine,
   1984], e um sistema para a segmentacao primaria ou segmentacao de baixo nivel
   de imagens, e consiste basicamente uma abordagem ao problema que engloba a
   integracao de caracteristicas para a representacao das imagens, logica e memoria
   associativa.
   O primeiro estagio na visao computacional para a compreensao de imagens
   e a segmentacao de baixo nivel. Nesta etapa, deve-se extrair algumas
   caracteristicas basicas da imagem, que possuem informacoes a respeito de seu
   contexto assim como: bordas, linhas, regioes, etc. Em geral, os sistema tradicionais
   limitam-se a apenas uma abordagem, ou seja, sao especificos a extracao de uma
   unica caracteristica. O LLIS se preocupa com a integracao e representacao de
   diversas caracteristicas, de modo a formular uma representacao mais rica e
PA complexa da informacao visual.
   Um dos problemas em visao computacional e a modelagem dos dados
   resultantes do processamento de segmentacao de imagem. Como modelar uma
   estrutura de dados de tal forma que esta seja significante na representacao da
   informacao? A maioria dos modelos de segmentacao nao estruturam ou modelam
   os dados resultantes, de forma a apresentarem como resposta simplesmente
   imagens realcadas. Tais resultados, embora demonstram vasta aplicacao, nao sao
   devidamente significativos quanto ao armazenamento, transporte e aproveitamento
   de informacoes (para niveis superiores de processamento), principalmente na
   187
   CAPITULO 5
   representacao da informacao.
   O LLIS e um modelo para a segmentacao de baixo nivel de imagens que
   procura diferenciar-se dos modelos tradicionais de segmentacao de baixo nivel por
   apresentar algumas propostas de motivacao biologica, tal como memoria
   associativa e logica, assim como apresentar uma estrutura de representacao efetiva
   para combinar diferentes atributos visuais de baixo nivel, analisar e tracar em
   tempo de execucao estrategias de processamento mais apropriadas para diferentes
   situacoes, assim como a geracao de uma base de dados, a partir do
   processamento que realimente o sistema com conhecimento.
   O processamento da informacao no LLIS e baseado em regras, onde as
   informacoes referentes ao processamento sao todas analisadas com comparacoes
   logicas: (e) e (nao-e). Quando as operacoes logicas sao verdadeiras entao os
   predicados, ou seja acoes aliadas aos operadores, sao executados.
   Inicializador
   Analise de linhas
   S
   Analise de regioes
   L
   T
   T
   Analise de area
   M
   M
   Atencao de foco
   Supervisor
   Fig. - 5.7 - Diagrama em blocos do sistema LLIS.
   O LLIS e formado de modulos que compoem os processos de controle e
   segmentacao, assim como duas memorias associativas, conforme apresentado na
   figura 5.7. Os dados referentes a imagem de entrada, segmentacao e estrutura de
   saida sao armazenados na memoria STM (Memoria de curta duracao do ingles:
   Short Term Memory), ao passo que na memoria LTM (Memoria de longa duracao
   do ingles: Long Term Memory) e armazenado o conhecimento do sistema a
   respeito do processamento de baixo nivel (regras logicas sobre o comportamento
   dos dados), assim como as regras referentes as estrategias de controle. Os dados
   contidos na STM podem ser alterados durante o processamento, apagados ou
   ainda pode-se inserir dados, ao passo que a memoria LTM e fixa, podendo ser
   188
   Cyvis-1 e ynergos
   programada com as regras de comportamento antes do processamento.
PA Inicialmente a imagem situada na STM e processada e binarizada,
   resultando pontos que sao agrupados em linhas e produzem o primeiro mapa da
   imagem. Estes resultados sao armazenados tambem na STM. Uma area inicial do
   mapa e entao selecionada, e e realizado o processamento de mais alto nivel que
   determinara caracteristicas da regiao, tais como: saturacao, cor, posicionamento e
   relacionamento entre os objetos (linhas e regioes). Este processamento ira resultar
   em caracteristicas de analise e comparacao tais como: adjacencia entre as regioes,
   relacionamentos como em frente de, atras, em paralelo, a esquerda, a direita e etc.,
   para as linhas e relacionamento entre linhas e regioes tais como: a regiao esta a
   esquerda ou a direita da linha, a linha toca ou interseciona a regiao e etc. E ainda
   em relacao ao comportamento de areas: com textura, nebulosa e a sua
   proximidade com linhas, etc.
   Apos determinadas estas dependencias logicas, que podemos denominar
   de processamento de baixo nivel, e realizado o processamento de alto nivel (ao
   qual e dedicado de fato o LLIS), que e realizado pelo modelo baseado em regras.
   As regras sao divididas em tres classes: regras de estrategia, regras de controle e
   meta regras e regras de conhecimento (regiao, linha e analise de area), que ficam
   alojadas na memoria LTM. As regras de estrategia, e as regras de controle e meta
   regras nao executam nenhuma alteracao na memoria STM, elas sao destinadas ao
   controle dos processos de acao, que operam as regras de conhecimento.
   As regras de conhecimento sao responsaveis pelo processamento da
   segmentacao. Nelas sao tomados pares ou conjuntos de informacoes de
   propriedades referentes a linhas, regioes e areas, sendo entao comparadas
   logicamente. Caso as situacoes logicas satisfacam a decisao logica, entao e
   executada a acao respectiva. O funcionamento das regras e bastante simples,
   conforme podemos observar na figura 5.8, onde temos o formato e um exemplo de
   uma regra. Por um lado nos temos um conjunto de combinacoes logicas, e do
   outro, a acao executada caso a condicao seja satisfeita. Conforme ja comentamos,
   as regras ficam alojadas na memoria LTM e executam acoes sobre a memoria
   STM, com dados tambem armazenados na STM.
   CONDITION.AND.CONDITION...............AND.CONDITION - ACTIONS
   189
   CAPITULO 5
   IF: THERE IS A LOW DIFFERENCE IN REGION FEATURE 1
   THERE IS A LOW DIFFERENCE IN REGION FEATURE 2
   THERE IS A LOW DIFFERENCE IN REGION FEATURE 3
   THEN: MERGE THE REGIONS
   Fig. - 5.8 - Exemplo de regras do modelo.
   Tendo comentado o modelo baseado em regras, voltemos ao sistema. Apos
   realizada a primeira segmentacao (baixo nivel) e definidos os mapas, o sistema fica
   sob controle do modulo supervisor (figura 5.7). O modulo de foco de atencao
   seleciona uma determinada area, e e realizado o processamento atraves das regras
   pelos modulos de analise de linha, regiao e area (figura 5.7), que irao alterando
   dados na memoria STM que realimenta o sistema. Apos finalizado o
   processamento em uma area de atencao, e iniciado o processamento em uma nova
   area de atencao, e assim sucessivamente. Apos ter visitado todas as areas de
   atencao da imagem, o sistema determina entao se existe a necessidade de
   processar novas areas, e caso afirmativo, repete a visita a essas areas. Caso o
   sistema ja tenha visitado todos os focos (areas) de atencao, o sistema processa o
   mapa da imagem como um todo, e e finalizada a segmentacao da imagem.
PA 5.3.1.1 - PONTOS POSITIVOS DO LLIS
   A primeira caracteristica interessante do sistema e a elaboracao de uma
   estrutura de dados, na qual e armazenado um sistema de conhecimento, que pode
   ser compartilhado entre diferentes heuristicas. No caso do LLIS informacoes sobre
   linhas e regioes compartilham a mesma estrutura de dados. Essa estrutura torna-se
   ainda mais interessante por apresentar a possibilidade de ser flexivel a outras
   heuristicas. A combinacao de heuristicas no processamento, no caso
   processamento de linha e regiao e um outro ponto forte da proposta.
   Uma outra abordagem muito interessante adotada pelo sistema e a selecao
   de determinadas areas da imagem, e a concentracao da atencao, ou enfoque de
   processamento, nestas areas. Esta abordagem, alem de ter fortes bases biologicas
   [Kosslyn, 1996] [Goldstein, 1989] [Bal ard & Brown, 1982], tambem possui um
   interessante mecanismo de realimentacao ou fluxo inverso de informacoes em
   190
   Cyvis-1 e ynergos
   tempo de execucao. Como o resultado das regras alteraram a mesma memoria em
   que os dados das caracteristicas da imagem sao armazenados, ocorre entao uma
   realimentacao natural do sistema, ocorrendo um somatorio de processamento, que
   pode vir a enriquecer a qualidade de processamento.
   5.3.1.2 - PONTOS NEGATIVOS DO LLIS
   Um dos maiores desafios da visao computacional e a segmentacao de baixo
   nivel. Determinar a posicao de uma linha, onde ela comeca, onde termina, se faz
   laco, se e paralela a outra, se apresenta descontinuidade, e se uma area apresenta
   uma determinada textura, ou possui uma segmentacao nebulosa, ou ainda obter as
   caracteristicas de regioes, e uma tarefa extremamente dificil e que se encontra
   plenamente aberta para pesquisa. Na proposta do LLIS, e necessario uma pre-
   segmentacao na imagem, de modo que devolva as propriedades e caracteristicas
   de retas e regioes da imagem. Porem, a extracao destas informacoes e algo longe
   de ser trivial, nao existindo ainda algoritmo capaz de faze-lo com a eficiencia
   exigida pelo suposto modelo.
   E nesse aspecto que encontramos as principais falhas no modelo do LLIS.
   O modelo baseado em regras, nao segmenta de fato as imagens, apenas executa
   operacoes logicas de alto nivel em dados ja extraidos desta. Os autores nao
   comentam como um algoritmo consegue extrair informacoes da imagem original
   com performance suficiente, para operar a gramatica de regras apresentada no
   artigo.
   5.3.1.3 - LLIS VERSUS CYVIS-1
   Uma das semelhancas que podemos observar entre a proposta do sistema
   Cyvis-1 e o LLIS e o uso do processamento modular. O LLIS apresenta modulos de
   processamento especificos para linhas, regioes e areas, do mesmo modo como o
   Cyvis-1, que e dividido em modulos especificos a uma determinada caracteristica
   (cor, estereo, borda, textura). Ainda uma outra semelhanca e a utilizacao de um
   modulo de controle, para supervisionar os modulos de processamento. Embora
   possuam estas semelhancas, a abordagem difere, uma vez que o Cyvis-1 busca o
   paralelismo, solucao adotada pelo sistema de visao natural (Capitulo 4) para
   resolver diversas questoes, entre elas a integracao, sendo que o LLIS e
   essencialmente serial devido a sua modelagem, baseada em regras e predicados
   191
   CAPITULO 5
   de inteligencia artificial convencional.
PA Alem de possuirem modulos distintos para diferentes tipos de
   processamento, uma outra similaridade entre os sistemas e a tentativa de
   compartilhamento de informacoes entre os modulos a fim de melhorar a
   interpretacao e processamento da imagem. Porem a maneira com que e realizada a
   abordagem e um pouco diferenciada. O LLIS tem uma memoria global
   compartilhada (STM) onde os dados do processamento alem de estarem
   compartilhados, ainda dividem a mesma estrutura de dados, ao passo que o
   Cyvis-1 possui alem de uma base de conhecimento geral, uma memoria distribuida
   para cada modulo, onde as informacoes sao trocadas a partir de mensagens entre
   os modulos e o supervisor.
   5.3.2 - SISTEMA DE VISAO DO MIT (MASSACHUSSETTS
   INSTITUTE OF TECHNOLOGY)
   O sistema de Visao do MIT, apresentado por Poggio e Weinshal [Poggio &
   Weinshal , 1993], denominado MIT Vision Machine, possui inspiracao parecida com
   o Cyvis-1, sendo tambem baseado em paralelismo e inspirado pela natureza. Os
   sistemas biologicos, ao realizarem o processamento visual (em seus primeiros
   estagios), integram diferentes atributos de processamento da cena para realizar a
   interpretacao. Tal fato e constatado na literatura, e os autores acreditam ser esta a
   chave para as caracteristicas de flexibilidade, reaproveitamento e robustez dos
   sistemas biologicos. Inspirado na integracao de diferentes atributos visuais,
   realizado pelos sistemas biologicos, foi proposto este sistema, sendo sua proposta
   a integracao e desenvolvimento de algoritmos paralelos para visao.
   A organizacao geral do sistema pode ser observada na figura 5.9. Uma das
   intencoes do sistema e explorar o desenvolvimento de algoritmos paralelos para
   visao. Desta forma, as imagens sao processadas paralelamente por diferentes
   algoritmos e modulos, que correspondem a diferentes propriedades visuais. Alem
   dos modulos responsaveis por diferentes atributos sendo executados em paralelo,
   ainda cada um dos algoritmos que compoe os modulo sao igualmente executados
   simultaneamente, constituindo uma abordagem altamente paralela. O sistema
   possui como plataforma um computador massivamente paralelo do MIT, o
   Connection Machine [Almasi & Gottlieb, 1994].
   Os modulos sao caracterizados pelos diferentes atributos de visao
   192
   Cyvis-1 e ynergos
   utilizados, que nesse sistema sao: processamento de borda, estereo, cor, textura e
   movimento. Os modulos sao executados em concorrencia e ao final do
   processamento e gerado um mapa de descontinuidade global ou mapa resultante,
   que e formado pela integracao dos mapas de cada modulo, com as informacoes
   complementares de cada um.
   Imagem
   original
   Cor
   Textura
   Borda
   Movimento
   Estereo
   nhas e processos
   ntinuos
   Li
   co
PA Descontinuidades
   Mapa
   fisicas rotuladas
   final
   Fig. - 5.9 - Diagrama da organizacao da maquina de visao do MIT.
   A seguir vamos descrever sucintamente cada um dos modulos de
   processamento do sistema:
   Deteccao de borda - O modulo de deteccao de borda procura encontrar
   descontinuidades no brilho da imagem. Para realizar este processamento sao
   utilizados dois algoritmos no sistema, o primeiro e o cruzamento por zero do
   Laplaciano da Gaussiana [Marr, 1982], e o segundo na convolucao do template de
   Canny [Gonzalez & Woods, 1993] [Parker, 1997]. O cruzamento por zero, pode ser
   usado pelo modulo de estereo e movimento, ao passo que o Canny, e a entrada
   para a integracao utilizando os campos markovianos.
   Estereo - Para a realizacao de processamento de visao Estereo, o sistema requer
   dois dispositivos de aquisicao de imagem diferentes. Estes deverao focalizar a
   mesma cena porem atraves de angulos diferentes. Embora a cena seja a mesma,
   193
   CAPITULO 5
   devido a binocularidade, ocorrera disparidades entre as imagens. O modulo de
   estereo consiste em encontrar essas disparidades nas imagens, gerando deste
   modo um mapa das disparidades.
   Movimento - O modulo de movimento objetiva o calculo do campo de fluxo optico.
   Este procedimento consiste em armazenar um vetor de imagens, e comparar suas
   disparidades resultantes do movimento. Por exemplo, considere que, temos uma
   imagem E(x,y) e uma outra imagem, formada no instante seguinte, E + t (x,y).
   Logo, quando e encontrada a disparidade entre E(x,y) e E + t (x,y) e obtido um
   mapa de descontinuidade contendo as bordas dos objetos em movimento.
   Cor - O modulo de cor consiste em encontrar as fronteiras da superficie da funcao
   de reflectancia espectral, ou seja descontinuidades cromaticas da imagem.
   Textura - O modulo de textura dedica-se a encontrar as descontinuidades entre
   regioes preenchidas por padroes semelhantes. O resultado deste processo
   converge num mapa das fronteiras das regioes com textura. Nesse modulo, e
   utilizado uma versao simplificada do algoritmo paralelo de textura desenvolvido por
   Voorhees e Poggio [Voorhees & Poggio, 1988].
   Os modulos sao processados paralelamente originando mapas de
   descontinuidade. Cada um dos mapas contem informacoes caracteristicas (de
   baixo nivel) de cada um dos atributos respectivos a cada modulo. O objetivo do
   sistema e integrar estes modulos a fim de obter um mapa de descontinuidade geral,
   enriquecido com cada uma das caracteristicas especificas de cada um dos
   atributos (cor, borda, estereo, movimento e textura). Como resultado desta
   integracao temos um mapa de bordas da imagem original. Embora existam
   inumeros algoritmos que obtenham mapas de bordas, a contribuicao dada pelo
   sistema de Visao do MIT e um mapa enriquecido pela integracao de inumeros
   atributos, contendo deste modo concentrada e filtrada diversas informacoes. O
   resultado proveniente do processamento de cada um dos atributos e esparso e
   ruidoso. Com a adocao do modelo MRF e realizada a integracao dos diferentes
   atributos e simultaneamente a filtragem do ruido, originando um mapa mais
   confiavel.
   194
PA Cyvis-1 e ynergos
   5.3.2.1 - CYVIS-1 VERSUS MAQUINA DE VISAO
   Embora tanto o Cyvis-1 quanto o Vision Machine tenham o mesmo proposito, ou
   seja, incorporar diferentes atributos para realizar o processamento de imagem, a
   filosofia, estrutura e estrategia de cada um dos sistemas e bastante divergente.
   Discutiremos as diferencas entre os dois sistemas relativamente aos seguintes
   topicos: Estrutura, Hierarquia, Organizacao de Dados e Aspectos Computacionais.
   5.3.2.1.1 - Estrutura
   A estrutura dos dois sistemas a grosso modo e bastante parecida: ambos
   sao sistemas de visao computacional de baixo nivel, tempo real e com plataforma
   computacional paralela. Os dois sistemas tambem processam diferentes atributos
   da mesma imagem, e tentam integra-los na obtencao de um unico resultado, e para
   cada um desses atributos, os sistemas adotam modulos e algoritmos
   independentes. O que realmente diverge, e a organizacao e transferencia de dados,
   assim como a hierarquia dos sistemas.
   No sistema MIT Vision Machine, os modulos nao apresentam ordem
   hierarquica definida. Os modulos sao processados paralelamente, sem
   dependencia de dados, de maneira sincrona. Ao final do processamento de todos
   os modulos e entao realizada a integracao de seus resultados para obtencao de um
   mapa de resultados. Nessa abordagem nao existe hierarquia de processos nem
   mesmo de dados. A unica preocupacao do sistema e a integracao estatistica dos
   resultados atraves do modelo de campos aleatorios de Markov (MRF).
   O Cyvis-1 apresenta ordem hierarquica significativa. Os modulos possuem
   diferentes niveis hierarquicos e ocorre dependencia de dados entre eles. Deste
   modo, por exemplo, um modulo de deteccao de borda de nivel hierarquico mais alto
   nao podera ser executado sem o resultado de um modulo de cor, com nivel
   hierarquico inferior, ja que num nivel hierarquico mais alto, o modulo de deteccao
   de borda necessita de informacoes cromaticas da imagem.
   Deste modo, a estrategia de integracao entre os sistemas tambem e
   bastante diferenciada. Se no Vision Machine a integracao e resolvida num unico
   processo matematico (MRF), no Cyvis-1 a integracao e realizada ao longo do
   processamento de modo mais ameno. Os modulos de hierarquia superior tem como
   sua entrada de dados os resultados dos modulos de hierarquia inferior. Deste modo
   e realizada a integracao dos diferentes modulos de um mesmo atributo. Alem de
   necessitar dos resultados dos niveis hierarquicos mais baixos (de um mesmo
   195
   CAPITULO 5
   modulo), existem modulos que necessitam tambem de dados provenientes de
   modulos de atributos diferentes. Estes modulos sao responsaveis pela integracao
   de diferentes atributos, que ocorre em diferentes etapas.
   Uma outra singularidade no Cyvis-1 e a caracteristica de fornecer caminho
   inverso na hierarquia de processamento ("back propagation"). Esta propriedade faz
   com que seja possivel a um modulo de alta hierarquia requerer que um modulo de
   baixa hierarquia seja executado novamente, e passar parametros complementares
   para este. Com isso, e possivel obter informacoes que anteriormente nao foram
   extraidas.
   5.3.2.1.2 - Organizacao e transferencia de Dados
   Devido a diferenca entre a estrutura e hierarquia, a organizacao e
   transferencia dos dados apresenta tambem diferentes aspectos em cada sistema.
   No caso do Vision Machine, a estrutura dos dados e comum entre os modulos. O
PA resultado de cada modulo e constituido de um mapa de descontinuidades, bastante
   semelhante entre cada um dos modulos. Como nao ha escala hierarquica, nao
   ocorre dependencia de dados. Os resultados de cada um dos modulos de atributo
   sao semelhantes e serao integrados nos mesmos passos. Deste modo, alem da
   transferencia dos dados ser unidimensional, tambem nao e estimulada a
   comunicacao entre modulos de diferentes atributos.
   A organizacao dos dados no Cyvis-1 nao e uniforme, e sua estrutura varia
   entre diferentes modulos de atributos, assim como entre os diferentes niveis
   hierarquicos. A medida que subimos a escala hierarquica, os dados tornam-se mais
   compactos e as informacoes mais simbolicas. Nesse modelo, ocorre a dependencia
   de dados entre processos, ou seja, um processo nao pode ser executado enquanto
   nao tiver o resultado de um processo e nivel hierarquico inferior. Diferente da
   estrategia utilizada no Vision Machine, em que a integracao ocorre num estagio de
   integracao matematica (MRF), no Cyvis-1, a integracao na transferencia e
   organizacao de dados ocorre a cada modulo.
   Do mesmo modo que a organizacao de dados, o fluxo de transferencia
   tambem se altera no decorrer do sistema. Nos niveis hierarquicos mais baixos, a
   transferencia entre os modulos envolve grande quantidade de dados com uma
   frequencia baixa. A medida que vamos subindo a escala hierarquica, os pacotes de
   dados vao diminuindo e o fluxo de transferencia aumentando.
   5.3.2.1.3 - Aspectos Computacionais
   196
   Cyvis-1 e ynergos
   Os dois sistemas utilizam estrategias de paralelizacao, do ponto de vista
   computacional. O Cyvis-1 adota uma arquitetura MIMD. Deste modo, foi adotado a
   utilizacao de microcomputadores padrao PC, interconectados por rede e
   multiprocessados. Nesta abordagem, os algoritmos dos sistemas sao distribuidos
   entre as maquinas e entao processados de modo sincrono. Esta abordagem, alem
   do desempenho, visa a padronizacao e baixo custo.
   Por outro lado, o MIT Vision Machine adota como plataforma de computacao
   paralela um sistema desenvolvido pelo proprio MIT denominado Connection
   Machine, um super computador massivamente paralelo [Almasi & Gottlieb, 1994].
   Assim, temos duas abordagens diferentes, por um lado o MIT Vision
   Machine, utilizando uma plataforma exclusiva que deixa o sistema isolado (sem
   portabilidade), porem essa plataforma e poderosa e possui caracteristicas
   singulares em computacao paralela, possibilitando uma pesquisa mais abrangente
   e, consequentemente, um melhor desempenho.
   Em oposicao a essa estrategia temos o Cyvis-1, cuja preocupacao, alem de
   desempenho, e portabilidade de baixo custo. Deste modo, utiliza uma plataforma
   bastante popular (PCs) e barata, trazendo assim o beneficio da padronizacao e
   portabilidade ao seu favor.
   5.3. 3 - MODELO DO SISTEMA DE VISAO DE KOSSLYN
   O modelo de Kosslyn e apresentado no livro Image and Brain [Kosslyn,
   1996]. Diferentemente dos modelos convencionais de visao que tratam do assunto
   sob o ponto de vista da percepcao visual, o modelo de Kosslyn refere-se as
   imagens mentais, que sao formadas em nosso cerebro quando mentalizamos
   simples objetos ou ambientes inteiros.
   Quando desejamos consultar a nossa base de dados, a fim de
   relembrarmos um objeto ou ambiente, precisamos extrair as informacoes contidas
   em nossa memoria. Essas informacoes no entanto, sao compiladas pelo
PA processamento cerebral, e armazenadas de forma otimizada. Para lembrarmos, por
   exemplo, as cores da faixa dorsal do famoso fusca de Hollywood, (Herby - Se meu
   fusca falasse - Walt Disney), temos que encontrar a informacao em nossa memoria
   associativa referente a imagem do carro. A fim de compreendermos essa imagem,
   e lembrarmos de seus detalhes, ela devera ser "descompilada" e armazenada em
   nossa memoria visual. Agora, com a informacao em nossa memoria visual
   197
   CAPITULO 5
   poderemos "ver" mentalmente a imagem do fusca e entao fazer um novo
   processamento a nivel de detalhes a fim de relembrar a forma e coloracao das
   faixas que marcavam o carro, assim como o logotipo formado com seu numero.
   Experimentos demostraram que o fenomeno da formacao das imagens mentais
   possuem essa linha de processamento. Deste modo, podemos constatar o
   compartilhamento das areas de processamento visual de alto nivel entre percepcao
   e mentalizacao. A caracteristica biologica de que as conexoes que levam
   informacoes das areas processamento de alto nivel para niveis superiores existem
   em numero aproximado as que fazem o percurso inverso vem a fortalecer ainda
   mais o modelo.
   Busca de informacao
   Seletor de atencao
   Mapa
   Modulo de propriedades espaciais
   Visual
   Memoria
   Associativa
   Janela de
   Atencao
   Modulo de propriedades de objetos
   Fig. - 5.10 - Exemplo de regras do modelo.
   Kosslyn propoe um interessante modelo de processamento visual de alto
   nivel. A partir desse modelo, ele apresenta de forma empirica o compartilhamento e
   a reconstrucao de imagens mentalizadas. A figura 5.10 apresenta o modelo de
   Kosslyn o qual, devemos lembrar, se refere a um modelo de identificacao de
   objetos que e compartilhado entre percepcao e mentalizacao.
   Vamos agora fazer uma breve descricao de cada um dos elementos do
   modelo:
   Mapa Visual - Entrada de informacao provinda dos olhos, porem
   processada topograficamente pelas regioes de baixo nivel.
   198
   Cyvis-1 e ynergos
   Janela de Atencao - Area do Mapa Visual destinada ao processamento
   detalhado.
   Modulo de propriedades de objetos - Ou sistema ventral, sao areas do
   cerebro do lobulo occipital inferior para o lobulo temporal inferior. Em macacos,
   podemos dizer que o sistema ventral inclui as regioes V3, V4, TEO, TF e TE. As
   celulas destas regioes tipicamente respondem as propriedades dos objetos, como
   forma, cor e textura.
   Sua principal funcao e a codificacao dessas informacoes para o
   armazenamento na memoria associativa.
   Modulo de propriedades espaciais - Ou sistema dorsal, sao areas
PA formadas pelas regioes de conexoes que vao do lobulo occipital ate o lobulo
   parietal. Este sistema tambem e denominado "O que / Onde", e e responsavel pelas
   informacoes de localizacao, navegacao. As principais propriedades processadas
   aqui sao localizacao e tamanho dos objetos. O sistema dorsal funciona
   simultaneamente ao sistema ventral.
   Uma das principais funcoes do sistema dorsal e codificar informacoes que
   sao utilizadas primeiramente para guiar acoes, como movimento dos olhos.
   Memoria Associativa - As saidas dos sistemas dorsal e ventral chegam
   simultaneamente e sao armazenadas na memoria associativa. Na memoria
   associativa os dados nao sao armazenados somente como representacoes de
   percepcao, mas tambem de modo mais abstrato (nomes, categorias, partes de
   pronuncia, etc.).
   Em alguns casos as informacoes enviadas pelos sistemas dorsal e ventral
   sao boas o suficiente para selecionar a representacao adequada na memoria
   associativa, deste modo a identificacao e realizada. Em outros quando nao e
   possivel realizar a identificacao por falta de dados, o sistema deve entao solicitar
   uma nova coleta de dados.
   Busca de informacao - Quando os dados codificados pelos sistemas
   ventrais e dorsais nao implicam inicialmente um objeto especifico, mais informacao
   deve ser coletada. Nessas circunstancias, nos nao precisamos olhar aleatoriamente
   para o objeto, para coletar informacoes adicionais. O sistema de busca de
   199
   CAPITULO 5
   informacao realiza um processamento "top-down", ou seja ele procura informacoes
   na memoria associativa relevantes as informacoes anteriormente obtidas, e o
   sistema gera entao a partir dessas informacoes um guia para a obtencao das
   informacoes auxiliares necessarias para a identificacao. Deste modo, o sistema
   visual sabera exatamente o que procurar na tentativa de reconhecimento.
   Seletor de atencao - No processo "top-down", nao somente o acesso a
   informacao e necessario, como tambem o acionamento de mecanismos que dao
   maior atencao a regiao visual onde o objeto ou cena possuem as informacoes
   caracteristicas. O mecanismo de atencao seletiva posiciona o corpo, cabeca, olhos
   e a janela de atencao, onde uma porcao da imagem pode ser processada com mais
   detalhes.
   Tendo brevemente discutido os componentes do modelo de Kosslyn, vamos
   agora descrever o seu funcionamento. Para a percepcao, em termos sucintos, a
   imagem proveniente da retina e processada pelas areas de processamento de
   baixo nivel, e entao transmitida ao mapa visual. A imagem contida no mapa visual
   devera ser entao codificada para a sua representacao na memoria associativa.
   Esse processamento ocorre simultaneamente nos sistemas Dorsal ( modulo de
   propriedades espaciais) e Ventral ( modulo de propriedades de objetos), onde
   respectivamente as propriedades de localizacao e propriedades de forma, cor,
   textura, borda, etc., sao codificadas. A representacao codificada do objeto e entao
   transferida para a memoria associativa. Caso as informacoes estejam satisfatorias
   e existam dados coerentes ao objeto na memoria associativa, entao o objeto e
   reconhecido, caso contrario, o modulo de busca de informacao ira pesquisar na
   memoria associativa quais informacoes caracteristicas sao necessarias. Essas
   informacoes sao entao transmitidas para o seletor de atencao, que posicionara a
   janela de atencao no mapa visual, e/ou solicitara novos detalhes da imagem para o
   sistema visual. Caso nao tenha necessidade de coletar nova imagem (atencao
PA seletiva), entao a informacao contida na janela de atencao sera processada
   novamente passando apenas pelo sistema ventral. Esse ciclo e repetido ate o
   objeto ser identificado.
   Na mentalizacao de imagens, as mesmas areas sao utilizadas. Embora
   exista o compartilhamento, a utilizacao do modelo e um pouco diferente. Por
   exemplo, no caso do Herby, quando perguntamos as cores e formas das listras
   200
   Cyvis-1 e ynergos
   dorsais e logotipos do carro, precisaremos mentaliza-lo a fim de que possamos
   recordar. O modulo de busca de informacao, devera fazer uma busca na memoria
   associativa a fim de encontrar as representacoes do carro. Feito isso, a imagem e
   reconstruida no mapa visual, como se tivesse sido originada pela percepcao do
   sistema optico. O mecanismo seletor de atencao, posicionara a janela de atencao
   na porcao da imagem que contem as informacoes necessarias. A imagem sera
   entao reprocessada pelo sistema ventral, a fim de que possa ocorrer a identificacao
   das cores e formas das listras. Supondo que nao recordamos ainda do logotipo,
   pois apenas nos lembramos dele na lateral do carro. O mecanismo seletor de
   atencao ira entao posicionar a janela de atencao na posicao adequada para
   detalhar o logotipo. Pelo processamento ventral, e novamente pelas consultas na
   memoria associativa, agora podemos identificar o logotipo, sua forma cor e o
   numero presente.
   As principais diferencas entre a percepcao e a mentalizacao de imagens
   sao:
   As imagens desaparecem rapidamente no processo de mentalizacao.
   As imagens mentais sao criadas a partir de imagens armazenadas. Diferentemente
   das imagens pelo processo de percepcao, que sao originadas a partir do mundo
   exterior.
   As imagens mentais, diferentes da percepcao, podem ser recriadas com diferentes
   modos. Por exemplo, podemos rotacionar o objeto, ampliar um detalhe, mudar a
   distancia, move-lo e etc.
   5.3.3.1 - O MODELO DE KOSSLYN E O CYVIS-1
   Mesmo sendo o modelo de Kosslyn de visao de alto nivel, diferentemente do
   baixo nivel do Cyvis-1, podemos fazer algumas comparacoes entre os sistemas,
   assim como motivacoes para o Cyvis-1. O modelo de Kosslyn e estritamente
   biologico, atraves do qual e realizada uma modelagem dos processos de alto nivel
   do sistema visual humano. Esse modelo se caracteriza pelo paradigma dos
   caminhos o que / onde ( what/where ), teoria que se baseia na dualidade dos
   caminhos de informacoes visuais no cortex. No entanto esta teoria recebeu duras
   criticas na literatura, como sendo uma simplificacao de um problema complexo
   [Zeki, 1993].
   Dentro do modelo de Kosslyn os sinais (atributos) sao agrupados em dois
   conjuntos e integrados. Assim, os sinais referentes ao caminho o que (cor, linhas,
   201
   CAPITULO 5
   formas, etc.), sao separados e integrados separadamente dos sinais referentes ao
   caminho onde (movimento, estereo, etc.). No Cyvis-1 nao e realizado o
   agrupamento de sinais, assim, pode ocorrer a integracao entre qualquer
   combinacao de atributos.
   Os mecanismos de atencao seletiva foram bastante explorados no modelo
   de Kosslyn, conforme podemos observar na figura 5.10, dos 7 modulos que
PA compoe o modelo, 3 sao voltados para esta questao. O Cyvis-1 tambem incorpora a
   atencao seletiva, que e realizada pelo mestre. No entanto, o modelo de Kosslyn nos
   sugere que esta questao e complexa e necessita de um mecanismo mais robusto
   para sua implementacao, podendo nos levar no decorrer do projeto Cyvis-1 a
   incorporacao de um modulo especifico para essa questao. O que falta no modelo,
   entretanto, e uma explanacao maior sobre os detalhes de cada modulo. Por
   exemplo, a procura de informacoes na memoria associativa esta descrita de forma
   bastante subjetiva. Ainda em atencao seletiva, o modelo de Kosslyn e fortemente
   baseado na divisao de sinais onde/o que, uma vez que apenas o caminho o que ou
   propriedades do objeto estao envolvidas diretamente com o processo.
   5.3.4 - SEEMORE
   Uma abordagem classica nos sistemas de visao artificial e a analise
   profunda de uma caracteristica ou atributo marcante para a extracao de
   propriedades para a classificacao de objetos. Ultimamente, podemos observar a
   tendencia de seguir a mesma abordagem estabelecida pelos sistemas de visao
   biologica, ou seja a combinacao de diversos atributos para a classificacao de
   objetos. O sistema de visao artificial Seemore, de autoria de Barlett Mel [Mel, 1997],
   e mais um exemplo de um sistema de visao que combina diferentes atributos da
   imagem para uma classificacao mais efetiva dos objetos.
   O funcionamento basico do sistema consiste na extracao do maior numero
   possivel de caracteristicas da imagem, e sua eventual classificacao atraves de
   ferramentas estatisticas. Para analisar o sistema foram treinadas para classificacao,
   100 imagens, formadas por objetos solidos rigidos (telefone) e flexiveis (cabo
   espiral de telefone) assim como imagens complexas de duas dimensoes. O
   Seemore demostrou ser capaz de reconhecer as imagens em diferentes angulos e
   escalas variando em fator de 2. Todas as imagens foram capturadas no mesmo
   ambiente com iluminacao normalizada.
   202
   Cyvis-1 e ynergos
   O treinamento do Seemore consiste na captura de 12 a 36 diferentes vistas
   dos objetos dependendo de sua natureza. Para objetos rigidos, sao necessarios 12
   vistas em diferentes angulos, variando em intervalos de 60o em media em torno da
   esfera visual do objeto, e mais 3 imagens escaladas para cada vista, tendo 67%,
   100% e 150% da original. Para objetos flexiveis as vistas sao tiradas de modo
   aleatorio em diferentes posicoes e escalas.
   O processamento do sistema Seemore consiste na extracao de 102
   caracteristicas da imagem. Cada caracteristica e denominada de canal, e o
   conjunto dos canais constituem o vetor de caracteristicas que e a entrada para o
   classificador estatistico. Deste modo, o banco de dados para cada objeto possui um
   total de 1224 a 3672 inteiros. Os 102 canais sao divididos em 5 grupos:
   23 canais de cor, cada um dos quais correspondem a pequenos nodulos
   parametrizados pela melhor matiz e saturacao.
   11 canais de cantos, parametrizados pelo angulo de abertura.
   12 canais de caracteristicas parametrizados pela forma principal (alongada ou
   arredondada) e pelo tamanho do objeto.
   24 canais com caracteristicas de contorno.
   16 canais de textura e forma baseados na saida da funcao de Gabor [Faugeras,
   1996].
   O processamento do Seemore e sequencial, mesmo nao existindo
   dependencia de dados entre os 5 modulos e possuindo uma estrutura que permite
PA uma exploracao de paralelismo, essa questao nao foi levada em conta pelo autor.
   Deste modo, a execucao do sistema e realizada de modo a extrair as
   caracteristicas uma apos a outra ate o montante de 102. Apos a extracao, as
   caracteristicas sao enviadas para o classificador estatistico que compara o
   resultado atual com o banco de dados formado pelo treinamento, para o
   reconhecimento do objeto.
   5.3. 4.1 - CYVIS-1 VERSUS SEEMORE
   Embora combine diversos atributos para o reconhecimento de objetos, o
   Seemore possui uma estrutura muito mais simples que o Cyvis-1, uma vez que nao
   existe a integracao dos atributos, estrategias de paralelismo, analise de dados
   automatica, cooperacao entre atributos e analise "top-down" (caminho inverso),
   entre outras. Numa visao simplificada, podemos resumir o Seemore como um
   sistema que extrai o maior numero possivel de caracteristicas da cena sem analise
   203
   CAPITULO 5
   previa ou direcionamento, e alimenta com um grande numero de parametros um
   classificador estatistico. Deste modo o Cyvis-1, em termos de arquitetura de
   sistema e de visao, tem mais a ensinar do que a aprender com Seemore. Mesmo
   possuindo uma arquitetura simplificada em termos de visao, os resultados de
   reconhecimento apresentados revelam uma boa performance do sistema. Ainda
   quanto aos resultados de reconhecimento, Mel [Mel, 1997], apresentou uma tabela
   onde compara a performance da classificacao do Seemore utilizando apenas um
   atributo (cor, textura ou forma) e a combinacao de atributos. Os resultados
   demostraram a eficiencia da classificacao quando alimentada com os dados dos
   diferentes atributos. Este e um dado relevante para o Cyvis-1, uma vez que alem de
   combinar os atributos, ele tambem desempenha a integracao e cooperacao.
   A execucao do Seemore e sequencial. Mesmo nao possuindo dependencia
   de dados e hierarquia rigida, o que facilita a implementacao paralela, essa questao
   nao foi abordada, diferentemente da filosofia do Cyvis-1, que mantem a
   implementacao paralela como um de seus principais objetivos.
   5.4 - O PROJETO YNERGOS
   No desenvolvimento de sistemas e na realizacao de experimentos em visao,
   apresentam-se uma serie de dificuldades, que devem ser vencidas pelo esforco, a
   fim de que o sistema ou experimento em questao possa ser realizado com exito.
   Dentre essas dificuldades podemos citar: (i) a validacao das tecnicas: e bastante
   trabalhoso certificar que as tecnicas e algoritmos estao funcionando perfeitamente;
   (i ) a implementacao correta de algoritmos muitas vezes direcionados a linguagens
   de modelagem (ex: MATLAB); e (iii) a analise estatistica dos dados obtidos a partir
   do processamento: muitas vezes diversos atributos extraidos de uma imagem
   classificam-na de modo igual, tornando-se redundantes, assim como em algumas
   ocasioes os atributos extraidos podem nao estar distinguindo adequadamente
   diferentes classes, sendo necessario a adicao de caracteristicas no sistema.
   Normalmente, os pesquisadores desenvolvem algoritmos especificos para a
   realizacao de testes e analises, ou estudam atraves de seus experimentos para
   uma melhor compreensao dos problemas apresentados acima. No entanto, isso e
   bastante trabalhoso e custoso, implicando num tempo muito maior para o
   desenvolvimento de sistemas e experimentos. Esses problemas, comuns na area
   de visao, motivaram o desenvolvimento de uma ferramenta para auxiliar a
   204
   Cyvis-1 e ynergos
PA pesquisa, experimentos e desenvolvimento de sistemas em visao, em nosso grupo.
   O projeto ynergos [Bruno et al., 2000] [Consularo et al., 1999] [Bruno et al.,
   1998], tem como objetivo fornecer um ambiente, formado por um conjunto de
   ferramentas, para auxiliar no desenvolvimento de sistemas e experimentos em
   visao. O ynergos e composto por um conjunto de modulos caracterizados por
   ferramentas que atuam em areas especificas. Os principais modulos do ynergos
   sao:
   Pesquisa em Visao Computacional: Este modulo inclui ferramentas tradicionais
   para visao computacional e processamento de imagens, tais como Fourier e
   outros metodos de transformacao, deteccao de bordas, segmentacao de
   imagens, etc.;
   Pesquisa em Visao biologica: E composto por ferramentas para diferentes
   atividades relacionadas a visao biologica, assim como psicofisica e sintese e
   modelagem de estruturas biologicas.
   Analise dos Dados e Classificacao: Nesse modulo sao tratados os procedimentos
   de reconhecimento de padroes, analise de classes e funcoes estatisticas. Sendo
   util para auxiliar na validacao das caracteristicas.
   Validacao e Testes: Este modulo contem metodos para a verificacao da integridade
   das rotinas implementadas, assim como para avaliar e melhorar a performance
   dos algoritmos.
   Base de Dados: Base de dados para imagens e dados genericos, fornece o alicerce
   para que diferentes metodos tais como os de performance de algoritmos,
   validacao e selecionador automatico de caracteristicas, possam agir.
   Computacao Paralela: Esta abordagem e responsavel pelo auxilio em
   implementacoes de aplicacoes de tempo real atraves da paralelizacao de
   algoritmos. A base paralela adotada pelo ynergos e o CVMP (ver Capitulo 6).
   Inteligencia Artificial: Aqui se encontram as rotinas para aquisicao de conhecimento
   de sistemas especialistas ou de experimentos (exemplo algoritmo genetico
   [Goldberg, 1989]).
   Mineracao de dados (Data Mining): Este modulo se refere as funcoes para
   encontrar regras gerais em conjuntos de dados, que podem ser usadas para
   modelar estruturas biologicas ou para aquisicao de conhecimento em sistemas
   especialistas, por exemplo.
   Visualizacao e GUI: Modulo responsavel pela visualizacao cientifica dos dados e da
   interface entre o usuario e maquina.
   205
   CAPITULO 5
   Internet: Interacao com a Internet em tres diferentes situacoes: (a) sintese: geracao
   automatica de documentos HTML; (b) analise: processamento de imagens e
   dados provenientes do WWW; (c) processamento: aplicacoes rodando atraves
   da internet (via cgi-bins, Perl ou Java, por exemplo).
   Interacao com aplicativos externos: Este modulo e responsavel por permitir que o
   ynergos possa interagir e comunicar com outras aplicacoes tais como Matlab
   ou ADOBE PhotoShop, tornando-o um versatil ambiente para a investigacao de
   imagens.
   A principal ideia por tras do projeto
   ynergos, alem de auxiliar o
   desenvolvimento de sistemas e experimentos, esta o conceito de sinergia, que se
   exprime pela sentenca de que a soma das partes e maior do que o todo. Deste
   modo o resultado da uniao de diversos metodos computacionais em um unico
PA sistema pode ser maior do que a soma de suas partes, uma vez que as vantagens
   e desvantagens relativas de cada modulo podem se complementar.
   USUARIO
   I/O (GUI'S)
   GERENCIA
   BIBLIOTECA PROPRIA
   PROGRAMAS
   DATABASES
   APLICACOES
   INTERNET
   COMPUTAD. REMOTOS
   Fig. - 5.11 - Modelo em camadas do ynergos.
   Deste modo, o ynergos pode ser caracterizado como um sofisticado
   laboratorio de visao, atraves do qual podem ser desenvolvidos poderosos
   experimentos baseados na interacao entre seus modulos. A figura 5.11 apresenta
   um modelo de camadas que expressa sua arquitetura. O ynergos esta sendo
   implementado principalmente pelo colega de grupo Luis Augusto Consularo
   [Consularo et al., 1999], utilizando o ambiente de programacao Delphi e a
   plataforma Windows NT/9X. O ambiente Delphi possui ferramentas para
   programacao visual, bases de dados, programacao Internet (cgi-bin) e programacao
   orientada a objetos (OOP), e desse modo tem contribuido para a implementacao
   efetiva dos conceitos envolvidos no projeto.
   Uma das caracteristicas do ynergos e a sua natureza paralela e distribuida.
   206
   Cyvis-1 e ynergos
   A implementacao paralela e distribuida esta sendo implementada utilizando as
   ferramentas CVMP ( Cybernetic Vision Message Passage - ver Capitulo 6), tendo
   como plataforma computacional maquinas IBM/PC conectadas via rede com um ou
   mais processadores (multiprocessadas), e sistema operacional Windows NT/9X. A
   adocao da plataforma PC / Windows foi adotada preferencialmente por: (i) As
   maquinas IBM-PC atingiram um alto nivel de performance (ex: 1000 MHz), (ii)
   portabilidade e popularidade tanto do hardware quanto do software e (iii) baixo
   custo.
   5.5 - PARALELISMO E VISAO, UM DESAFIO
   Neste capitulo discutimos e apresentamos alguns sistemas de visao artificial
   e suas necessidades de paralelismo. Entretanto, a demanda por paralelismo nas
   areas relacionadas com a visao computacional e muito mais ampla, uma vez que
   esta envolve a manipulacao de grandes quantidades de dados (imagens) sendo
   processados por um elevado numero de operacoes aritmeticas, o que
   consequentemente resulta num grande consumo computacional e tempo. Alem da
   questao de desempenho, existe tambem a integracao e colaboracao entre atributos
   visuais. Ainda que esses conceitos estejam em fase inicial de pesquisa, motivados
   pelos sistemas biologicos, acreditamos estar no paralelismo as solucoes para essas
   questoes.
   Embora a visao computacional e diversas outras areas cientificas, que
   necessitem de grande poder computacional, venham a ser beneficiadas com a
   utilizacao de paralelismo, algumas barreiras frequentemente impedem sua adocao,
   tais como:
   Necessidade de escrever novo codigo voltado para o paralelismo e em muitos
   casos alterar a estrategia do algoritmo, gerando um aumento de trabalho na
PA implementacao dos algoritmos e nao permitindo a utilizacao dos codigos ja
   desenvolvidos.
   Os programas paralelos obedecem a principios de funcionamento e de
   programacao que diferem dos seriais. Isso dificulta sua implementacao, uma vez
   que a formacao tipica dos programadores e em processamento sequencial,
   sendo necessario conhecimento sobre os principios basicos do paralelismo e
   ambientacao.
   O codigo paralelo e em geral voltado para uma determinada arquitetura paralela,
   207
   CAPITULO 5
   reduzindo a portabilidade do codigo e padronizacao.
   Necessidade de mudar de linguagem e ambiente de desenvolvimento. Poucos
   ambientes de programacao apresentam solucoes para a implementacao de
   codigo paralelo, especialmente os comerciais integrados e visuais (Delphi, C++
   Builder, Visual C++ e Visual Basic), sendo necessario em algumas situacoes a
   mudanca de ambiente de trabalho e ate mesmo de linguagem de programacao.
   Com isso, alem de nao reutilizar o codigo, os programadores sao obrigados a
   aprender a operar novos ambientes e linguagens e a se familiarizar com eles.
   A grande maioria das ferramentas e linguagens de programacao voltadas ao
   paralelismo se caracterizam por serem voltadas aos especialistas em
   computacao paralela, nao se preocupando com o programador comum. Com
   isso dificultam a implementacao de programas concorrentes e aumentam
   drasticamente a curva de aprendizado [Hayes, 1990] [Baber et al., 1993] [Preece
   et al., 1994].
   Alto custo, especialmente para solucoes de paralelismo que envolvem
   computadores com arquiteturas nao convencionais.
   Analisando as barreiras podemos constatar que os maiores empecilhos para
   o desenvolvimento de programas paralelos estao relacionados ao trabalho humano.
   Se observarmos a historia da ciencia da computacao verificaremos a importancia
   da interacao entre o homem e o computador, e consequentemente das interacao e
   simplicidade de uso das ferramentas, tanto de operacao quanto de programacao.
   As ideias de simplificar o modo de operacao e as ferramentas computacionais sao
   conceitos que atingiram seu apice em relacao a pesquisa no projeto PARC [Bruno,
   1995] que culminou na tecnologia GUI [Peddie, 1992], na programacao orientada a
   objetos e em linguagens visuais (Smalltalk) [Hurson et al., 1993] [Cox, 1986].
   Gracas a esses elementos paginas foram viradas na historia da computacao e a
   informatica teve um grande impulso em sua expansao, chegando a fazer parte
   direta ou indiretamente de toda as nossas atividades cientificas.
   A importancia de ferramentas simples no desenvolvimento de programas
   pode ser tambem observada na popularidade das plataformas computacionais,
   sendo esse o principal motivo da difusao do Windows, que apresenta diversas
   ferramentas que possibilitam a criacao de aplicativos de maneira simples,
   destacando o Visual Basic, linguagem para iniciantes, simples de utilizar, e que
   possui o maior numero de aplicativos desenvolvidos.
   208
   Cyvis-1 e ynergos
   Embora os conceitos de interacao entre homem e maquina sejam
   consagrados e amplamente difundidos, eles nao foram empregados de forma
   efetiva na computacao paralela. Isso provavelmente se deve a sua natureza
   cientifica, uma vez que sua aplicacao se restringe ao meio cientifico e
PA consequentemente aos ecleticos especialistas da computacao paralela.
   Devido a demanda por paralelismo em visao computacional, e mais
   especificamente para os projetos do Grupo de Visao Cibernetica e carencia de
   ferramentas de simples utilizacao para a implementacao paralela compativeis com
   a linguagem e com o ambiente de programacao vigentes, fomos motivados a
   desenvolver um conjunto de ferramentas para implementacao de aplicacoes
   paralelas que viessem a atender a estas necessidades.
   Nasceu assim o CVMP ("Cybernetic Vision Message Passage"), que sera
   apresentado no proximo capitulo. Um conjunto de ferramentas visuais para a
   implementacao de aplicacoes paralelas, de simples utilizacao, voltada para a visao
   computacional. Atraves do CVMP os pesquisadores do Grupo de Visao Cibernetica
   nao necessitam mais mudar de linguagem e ambiente de desenvolvimento para a
   implementacao de programas concorrentes, poupando arduos treinamentos, longos
   periodos de familiarizacao e o trabalho de portar codigos. Deste modo, podem de
   maneira simples e efetiva, atraves de programacao visual e orientada a objetos,
   desenvolver programas paralelos e se integrar em grandes projetos de visao
   computacional, que necessitam de paralelismo, tais como o Cyvis-1 e o ynergos.
   209
   CAPITULO 5
   210
   CAPITULO
   6
   CVMP - CYBERNETIC VISION
   MESSAGE PASSAGE
   "Todas as coisas complexas estao condenadas a decadencia"
   Buda
   211
   CAPITULO 6
   212
   CVMP
   CAPITULO 6 - CVMP
   6.1 - INTRODUCAO
   Neste capitulo estaremos apresentando a base para o paralelismo proposta
   nesse trabalho, o CVMP. Iniciaremos este capitulo comentando os aspectos que
   nos levaram ao desenvolvimento dessa plataforma, depois estaremos
   apresentando seus principios e funcionamento e em seguida suas estrategias de
   comunicacao e seu desempenho, assim como sua disponibilidade de utilizacao nas
   plataformas MIMD memoria compartilhada e MIMD memoria distribuida.
   Finalizamos o capitulo apresentando o conjunto de ferramentas que constituem o
   CVMP.
   6.2 - MOTIVACAO E HISTORIA
   Como vimos no capitulo anterior, embora a computacao paralela traga
   inumeros beneficios para as areas de visao computacional, processamento de
   imagens e areas relacionadas, alguns obstaculos impedem sua proliferacao. Dentre
   estes, o principal obstaculo e a dificuldade de implementacao de programas
   concorrentes, uma vez que a maioria das ferramentas para o desenvolvimento de
   programas paralelos e destinada a especialistas da area. Essa dificuldade aumenta
   ainda mais devido a necessidade de mudar de ambientes de programacao e ate
   mesmo linguagens em determinados casos, de modo que alem do tempo gasto
   com o aprendizado das metodologias paralelas, e necessario tambem investir
PA tempo no processo de familiarizacao com as novas ferramentas de programacao,
   alem da necessidade de portar ou reescrever o codigo para outra plataforma.
   Observando essas dificuldades, fomos motivados a idealizar uma
   metodologia para o desenvolvimento de programas concorrentes de forma simples
   e efetiva. Alem da simplicidade de utilizacao, uma questao primordial para facilitar o
   desenvolvimento de programas concorrentes e a utilizacao das linguagens e
   ambientes de programacao integrados (visual) a que os programadores ja estejam
   ambientados, reduzindo assim o tempo de aprendizado e de portar, ou reescrever o
   213
   CAPITULO 6
   codigo. Tendo nosso grupo adotado como plataforma de desenvolvimento o
   Borland Delphi [Cantu, 1995], que alem de bastante popular, obedece as
   caracteristicas necessarias de uma plataforma de desenvolvimento moderna (ver
   5.2.3), optamos pela utilizacao deste ambiente.
   A historia do CVMP e parecida com diversos outros produtos que nasceram
   derivados de outros projetos. Essa situacao e bastante comum na Ciencia da
   Computacao, um bom exemplo e o mouse ou o do conceito de orientacao a
   objetos, que surgiram no PARC (Palo Alto Research Center) [Bruno, 1995], atraves
   de um grande projeto de interacao entre homem e maquina realizado pela Xerox ao
   longo de toda a decada de 70. No caso do CVMP o projeto em questao e o Cyvis-1,
   que foi apresentado no capitulo anterior. Uma das bases do Cyvis-1 e a adocao de
   paralelismo em sistemas de visao que, como vimos, alem de desempenho, exerce
   papel fundamental sobre a integracao e a corporacao de atributos visuais. Uma das
   caracteristicas do projeto Cyvis-1 e o numero de pessoas envolvidas, pois devido a
   sua complexidade, o Civis-1 requer o trabalho cooperativo de diversos
   pesquisadores de visao cibernetica, especialistas nas diversas modalidades
   exigidas pelo sistema, para o seu desenvolvimento.
   Sendo os pesquisadores que participam e virao a participar do projeto
   especialistas em visao e processamento de imagens, defrontamos com a grande
   barreira da computacao paralela. Dentre as inumeras dificuldades que ja
   mencionamos (ambientes e linguagens diferentes, portar codigo, dificuldade de
   implementacao, etc.), que acompanham os beneficios da computacao paralela, nos
   defrontamos principalmente com a questao da dificuldade de implementacao de
   sistemas em paralelo. Uma das caracteristicas que podemos observar na
   Computacao Paralela, que tambem se manifesta em diversas outras areas da
   ciencia, e o seu perfil ecletico. Dificilmente encontramos sistemas comerciais
   paralelos. Em geral, a utilizacao de paralelismo em sistemas de computacao
   repousa no berco da pesquisa cientifica, encontrando nela o seu principal nicho.
   Provavelmente por essa razao, nao existe uma preocupacao efetiva como a
   interacao entre homem e maquina [Preece et al., 1994] nesta area, fato que
   podemos facilmente comprovar pela natureza complicada de suas ferramentas de
   implementacao, como e o caso das famosas MPI [Pacheco, 1997] e PVM [Geist et
   al., 1996], que atraves da dificuldade de utilizacao, limitam os beneficios do
   paralelismo aos especialistas da area.
   Assim, devido a grande dificuldade de implementacao de sistemas
   214
   CVMP
   paralelos, fomos motivados a desenvolver uma ferramenta que trouxesse os
   beneficios da computacao paralela ao mundo da visao computacional e
   processamento de imagens, de modo simples de usar, possibilitando o
PA desenvolvimento de programas paralelos por pesquisadores da area de visao sem
   conhecimento especifico em computacao paralela. Nascia assim a ferramenta de
   troca de mensagens CVMP. Os principais requisitos que encontramos e atendemos
   de forma a simplificar ao maximo o desenvolvimento de programas paralelos,
   foram:
   Plataforma de desenvolvimento convencional: Como ja comentamos o treinamento
   com novas plataformas e linguagens de desenvolvimento e o tempo gasto
   portando programas e um grande empecilho. Por esta razao optamos pela
   adocao de uma plataforma de desenvolvimento convencional e popular.
   Optamos pelas ferramentas Borland Delphi e C++ Builder, que alem de
   serem bastante populares, sao as ferramentas adotadas pelo grupo de
   visao, de modo que os pesquisadores possam facilmente desenvolver
   versoes paralelas de seus programas na mesma linguagem e ambiente com
   os quais ja estao familiarizados.
   Programacao Visual: A programacao visual, diretamente associada com o
   paradigma da orientacao a objetos, e uma tecnologia que trouxe inumeros
   beneficios para o desenvolvimento de software. Atraves da programacao
   visual, o tempo de desenvolvimento de aplicativos e menor e a utilizacao de
   linguagens de programacao mais simples e facil.
   Programacao Orientada a Objetos: Inumeros sao os beneficios proporcionados por
   essa tecnologia. Em termos de operacao de computadores, o conceito de
   programacao orientada a objetos surgiu simultaneamente com a interface
   grafica com o usuario (GUI), que possibilitou um enorme passo para a
   popularizacao da informatica. Na engenharia de software, esse paradigma
   possibilitou beneficios similares ao conceito de circuitos integrados em
   eletronica [Cox, 1986]. O conceito de programacao orientada a objetos e a
   coluna dorsal do CVMP, uma vez que este paradigma possibilita alem de
   simples utilizacao, a reutilizacao de codigo e a modelagem de sistemas
   complexos.
   A partir dessas primitivas e outros conceitos que iremos apresentar no
   decorrer desse capitulo, o conjunto de ferramentas CVMP se transformou na base
   de desenvolvimento paralelo para o projeto Cyvis-1. A partir da ideia de criar uma
   215
   CAPITULO 6
   ferramenta de desenvolvimento de aplicacoes paralelas, simples de utilizar, e que
   permite sua utilizacao por profissionais de diferentes areas, tem demonstrado ser
   um interessante meio de tornar os beneficios da computacao paralela acessiveis
   para as demais areas da ciencia da computacao.
   6.3 - CVMP - CYBERNETIC VISION MESSAGE
   PASSAGE
   O CVMP e uma abreviacao do ingles "Cybernetic Vision Message Passage",
   que podemos traduzir como ferramenta de troca de mensagens para visao
   cibernetica. Trata-se de um conjunto de ferramentas para o desenvolvimento de
   programas paralelos em plataforma Delphi / C++ Builder, utilizando os conceitos de
   programacao visual e orientacao a objetos. Seu ideal, e o de contribuir com a
   proliferacao da computacao paralela e especialmente sua utilizacao de forma
   simples em nossa area (visao e processamento de imagens). Atualmente tem
   demonstrado sua eficiencia como plataforma de desenvolvimento paralelo do grupo
   de visao cibernetica, atraves de sua utilizacao por diversos pesquisadores no
   desenvolvimento de projetos que se beneficiem com a paralelismo, sendo de modo
PA especial, a base para o desenvolvimento do Cyvis-1, cujo conceito de paralelismo e
   vital para o seu modelo.
   O CVMP e composto por um conjunto de componentes ( VCL - Visual
   Component Library) nativos em Delphi e alguns aplicativos. Os componentes sao
   compostos por cinco grupos: CVMP basico, CVMP processor farm, CVMP image
   processing, Estatistica e Launcher, e os aplicativos em dois grupos: Estatistica e Launcher.
   A Figura 6.1 apresenta a paleta de componentes do ambiente Delphi com os
   componentes CVMP.
   Fig. - 6.1 - Paleta de componentes CVMP em ambiente Delphi.
   216
   CVMP
   6.3.1 - OBJETOS CVMP
   No decorrer deste capitulo forneceremos maiores detalhes sobre cada um
   dos componentes e tambem dos aplicativos que compoe o conjunto de ferramentas
   CVMP. A seguir vamos apresentar rapidamente cada um dos seus grupos de
   componentes.
   CVMP basico: Esse grupo e composto por dois componentes, que fornecem as
   primitivas de troca de mensagens, sendo um componente para sistemas MIMD de
   memoria distribuida e o outro para MIMD de memoria compartilhada:
   CVMP Pro: Contem uma biblioteca de funcoes e procedimentos e um componente
   CVMP basico com esta biblioteca encapsulada (CVMP Pro). A biblioteca CVMP Pro
   contem funcoes e procedimentos para a manipulacao de pacotes de mensagens,
   para a sincronizacao da troca de mensagens, semaforos e mecanismos de controle
   que podem ser utilizadas em conjunto com o CVMP basico, alem de suporte para
   operacoes basicas com imagens, tais como particao e divisao em blocos.
   CVMP processor farm: Contem componentes com a arquitetura fazenda de
   processadores (processor farm) implementada para ate 4, 8 e 16 maquinas
   escravas. Atraves do CVMP processor farm, o usuario pode de modo visual
   implementar facilmente uma aplicacao distribuida, sem precisar escrever nenhuma
   linha de controle para essa estrategia de paralelismo. Cada CVMP processor farm
   (ate 4 e ate 8 maquinas escravas) e composto por uma dupla de componentes, um
   mestre e um escravo. O componente mestre e responsavel pela supervisao dos
   escravos e pela divisao automatica de tarefas, enquanto que o componente escravo
   e responsavel pela execucao das tarefas.
   CVMP Image processing: Cada tecnica de processamento de imagem
   implementada pelo CVMP pode ser facilmente convertida em um novo componente
   e reutilizado futuramente. Dentro deste conjunto, temos algumas tecnicas de
   processamento de imagem implementadas e prontas para sua utilizacao, tais como:
   transformada de Fourier, convolucao de mascaras (Sobel) e transformada de
   Hough. Enfim, esta categoria esta sempre em expansao e pode ser implementada
   pelo proprio usuario, como e o caso do componente personalizado desenvolvido em
   217
   CAPITULO 6
   conjunto com Alan Salvany Felinto e Jander Moreira [Moreira et al., 1999], que
   possui inumeros protocolos personalizados e um metodo para aquisicao remota de
   imagens (a partir de placa de aquisicao de imagens de video), para o sistema de
   integracao entre cor e estereo, que apresentaremos futuramente.
   Estatistica: E composto por dois componentes, um para analise estatica e outro
   analise dinamica, para auxiliar na analise estatistica do comportamento de
   execucao dos programas concorrentes desenvolvidos com o CVMP, tais como fluxo
PA e tempo de execucao e o trafego de mensagens. O componente de analise estatica
   faz as medidas de desempenho diretamente atraves do codigo do programa, que
   deve conter em pontos estrategicos, estipulados pelo programador, chamadas a
   metodos do objeto. A partir destas chamadas, o componente realiza o calculo do
   tempo e o armazena em um arquivo que pode ser visualizado com o aplicativo de
   estatistica, que faz parte do conjunto de ferramentas CVMP. O componente para
   analise dinamica possui a mesma estrategia de utilizacao de seu parceiro,
   entretanto, ao inves de serem armazenadas em arquivo, as analises sao enviadas
   em tempo de execucao para o aplicativo de analise dinamica, podendo deste modo
   ser feito a visualizacao do desempenho, fluxo de execucao e troca de mensagens,
   enquanto o sistema e executado.
   Launcher: Composto por um unico componente, o CVMP-Launcher, possibilita o
   disparo de aplicativos nas maquinas da rede. Isto e realizado em conjunto com os
   aplicativos Launcher. A partir de chamadas aos metodos do objeto, o programa
   pode disparar a execucao de um determinado programa em uma maquina
   especifica da rede.
   6.3.2 - APLICATIVOS CVMP
   Os aplicativos CVMP sao programas que auxiliam na utilizacao ou
   funcionamento dos objetos CVMP. Os aplicativos se dividem em dois grupos:
   Analise estatistica, contendo aplicativos voltados para a analise de fluxo de
   execucao, desempenho e troca de mensagens e o Launcher, contendo aplicativos
   que permitem o disparo de programas em maquinas remotas.
   Estatistica: Existem dois aplicativos para analises estatisticas, sendo um para
   218
   CVMP
   analise estatica e outro para dinamica. O Aplicativo para a analise estatica e um
   utilitario que permite a visualizacao e analise dos resultados gerados a partir do
   componente de estatistica. O aplicativo para analise dinamica e mais complexo.
   Assim como o estatico ele tambem permite a visualizacao e analise dos resultados,
   no entanto os resultados sao obtidos em tempo de execucao. Para isso o aplicativo
   recebe mensagens do componente atraves de compartilhamento da memoria
   virtual. A cada mensagem recebida e atualizada a janela de exibicao, permitindo
   desse modo uma analise do comportamento do sistema em tempo real.
   Launcher: E composto por dois aplicativos, o modulo central e os disparadores. Os
   disparadores sao aplicativos que ficam na barra de tarefas do windows (tray) e
   ficam aguardando ordens. Atraves das ordens que recebem eles executam os
   programas determinados. O modulo central e um aplicativo que recebe comandos
   do objeto Launcher, ou entradas diretas pelo usuario. Sua missao e transmitir as
   ordens para a execucao de programas para os disparadores espalhados pela rede.
   6.4 - OS CANAIS VIRTUAIS
   A comunicacao entre os objetos CVMP e realizada sempre aos pares,
   dentro do conceito mestre/escravo, conforme apresenta a Figura 6.2. A partir de um
   par de objetos CVMP e estabelecido um canal virtual [Bruno & Costa, 1997] [Bruno
   & Costa, 2000]. O conceito de canal virtual e a base da ferramenta CVMP, ele foi
   inspirado nos canais dos transputer [Inmos, 1988] [Inmos, 1989], famosos
   processadores utilizados na decada de 80, que impulsionaram forte interesse em
   paralelismo em sua epoca, devido a facilidade de implementacao de hardware
   paralelo que eles proporcionavam. Assim como nos canais dos transputers, os
   canais virtuais sao fixos e, uma vez definidos, nao podem mais ser alterados. A
   estrategia de fixar a conexao entre os componentes foi idealizada de modo a
PA simplificar ao maximo sua utilizacao.
   Cada canal virtual conecta dois processos, onde cada processo utiliza um
   objeto CVMP, que pode atraves dele enviar e receber mensagens. Os processos
   podem estar na mesma maquina, sendo executados em concorrencia atraves da
   multitarefa do sistema operacional, podendo estar tambem em diferentes
   processadores de uma maquina multiprocessada, assim como em maquinas
   conectadas por rede.
   219
   CAPITULO 6
   M
   S
   Fig. - 6.2 - Exemplo do conceito mestre/escravo e da conexao atraves do
   Canal Virtual. A caixa M simboliza um objeto CVMP configurado como mestre,
   enquanto que a S, configurado como escravo. A barra vertical representa o
   Canal Virtual.
   Para a comunicacao de processos em diferentes maquinas conectadas via
   rede (sistema distribuido), o Canal Virtual possui duas conexoes, uma para o
   trafego de pacotes, com pequena granularidade, e utilizando protocolo TCP/IP, e
   outra para pacotes, de alta granularidade, utilizando o protocolo NetBeui ou IPX/SX.
   Essa estrategia permite um desempenho melhor da rede, possibilitando um trafego
   de pacotes mais agil. Comentaremos nas proximas secoes esta estrategia de forma
   mais detalhada.
   Em uma primeira instancia, pode parecer que, tanto a utilizacao de canais
   fixos como a conexao entre pares limitam as possibilidades de conexoes. No
   entanto, nao existe um limite para o numero de canais virtuais e nem para o numero
   de objetos CVMP utilizados por processo. Deste modo, arquiteturas complexas
   podem ser facilmente implementadas. A Figura 6.3 apresenta alguns exemplos de
   configuracoes permitidas utilizando os canais virtuais, demonstrando sua
   flexibilidade. As configuracoes apresentadas sao as mesmas tanto para sistemas
   distribuidos (MIMD distribuido) como para maquinas multiprocessadas (MIMD
   compartilhado). Em (a) temos uma maquina conectada a outras maquinas
   utilizando pares de CVMP conectados por Canais Virtuais; em (b) existem dois
   processos conectados em uma maquina monoprocessada (multitarefa); em (c)
   temos a combinacao de (a) e (b); e em (d) temos uma situacao mais complexa,
   ilustrando a versatilidade do CVMP.
   220
   CVMP
   A )
   B )
   M
   S
   M
   S
   M
   S
   C )
   M
   S
   M
   S
PA M
   S
   D )
   S
   Maquina ou processador
   M
   S
   Canal Virtual
   S
   M
   M
   S
   M
   CVMP mestre
   M
   M
   S
   M
   S
   S
   CVMP escravo
   Fig. - 6.3 - Possiveis configuracoes utilizando canais virtuais.
   6.5 - ARQUITETURAS MIMD
   Nessa secao discutimos as arquiteturas paralelas utilizadas para a
   implementacao de sistemas atraves do CVMP, assim como as tecnicas
   computacionais utilizadas para a implementacao do CVMP em cada uma delas.
   Como ja comentamos anteriormente, o CVMP incorpora duas estrategias de
   arquitetura paralela: sistemas distribuidos e maquinas multiprocessadas. Na
   literatura, o termo sistema distribuido e amplamente empregado, discriminando
   sistemas operacionais (Amoeba) [Mul ender et al., 1990], servidores de bases de
   dados e sistemas de computacao distribuida. No nosso trabalho estaremos
   empregando esse termo para designar aplicacoes (ou programas) concorrentes que
   sao executados em diferentes maquinas conectadas via rede, ou seja computacao
   distribuida. Podemos classificar os sistemas distribuidos implementados com
   CVMP como maquinas MIMD com memoria distribuida (ver Capitulo 2). Uma outra
   possivel arquitetura de paralelismo permitida pelo CVMP e o desenvolvimento de
   programas
   concorrentes
   em
   maquinas
   multiprocessadas.
   Maquinas
   multiprocessadas sao sistemas computacionais que apresentam mais de um
   processador principal. Existe uma grande diversidade de maquinas que se
   enquadram nesse perfil [Almasi & Gottlieb, 1994]. No entanto, o CVMP esta limitado
   a sistemas padrao IBM-PC multiprocessados com plataforma Windows-NT. Em
   221
   CAPITULO 6
   relacao a arquitetura anterior, podemos classificar este tipo de sistema como MIMD
   memoria compartilhada.
PA 6.5.1 ARQUITETURA MIMD DISTRIBUIDA
   Dentro do contexto do CVMP, denominamos arquitetura MIMD distribuida
   um conjunto de maquinas IBM-PC com plataforma Windows NT/9x conectadas em
   rede, apresentando um conjunto de aplicacoes, que atraves de utilizacao das
   ferramentas CVMP, conseguem cooperar executando processamento em conjunto.
   A Figura 6.4 apresenta um exemplo dessa arquitetura, nela temos um sistema
   paralelo formado por 3 processos alojados em maquinas distintas conectadas por
   rede, dos quais dois sao escravos (extremidades) e um mestre (no centro). Atraves
   dos objetos CVMP, representados na figura por pequenos quadrados cinza no
   interior dos processos, sao estabelecidos canais virtuais que possibilitam a troca de
   mensagens entre os processos.
   Canal Virtual
   CVMP
   Processo
   Fig. - 6.4 - Exemplo de uma aplicacao paralela em uma arquitetura MIMD
   distribuida.
   Para cada arquitetura, MIMD distribuida e MIMD compartilhada, e utilizado
   um objeto de base CVMP especifico, que implementa as primitivas de troca de
   mensagens apropriadas e estabelecem os canais virtuais. No modelo MIMD
   distribuido, existem dois mecanismos de troca de mensagem especificos para
   pacotes de pequena granularidade, baseada no protocolo de rede TCP/IP e na
   interface de rede socket e de alta granularidade, baseada na troca de arquivos
   atraves dos protocolos NetBeui e IPX/SX.
   222
   CVMP
   6.5.1.1 - MENSAGENS EM TCP/IP - SOCKET
   Os canais virtuais sao estabelecidos atraves de conexoes entre interfaces
   socket [Dumas, 1995], mecanismo desenvolvido pela Universidade de Berkeley
   para facilitar a troca de mensagens atraves do protocolo TCP/IP, sendo nativo para
   o UNIX, mais especificamente para o BSD ( Berkeley Software Distribution). Os
   ambientes Windows utilizam uma versao do socket de Berkeley denominado de
   Winsock. Nesses sistemas o Winsock e caracterizado por uma DLL (biblioteca de
   ligacao dinamica) [Bruno, 1995], que exerce o papel de uma API (interface de
   programacao de aplicativo) que pode ser acessada atraves de programacao.
   Embora o Delphi apresente em suas novas versoes alguns componentes
   que simplificam o acesso ao Winsock, o CVMP foi implementado sem a utilizacao
   desse recurso, fazendo chamadas diretas a API, para melhorar a performance,
   possuindo um conjunto de primitivas de troca de mensagens.
   6.5.1.2 - TROCA DE ARQUIVOS
   Observamos que em processamento de imagens e visao computacional,
   especialmente nos primeiros estagios, e bastante comum a transferencia de
   arquivos com imagens ou dados com grande quantidade de memoria. A plataforma
   Windows, dependendo da configuracao das maquinas da rede, nao apresenta o
   melhor desempenho para a troca de pacotes utilizando protocolo TCP/IP. Visando
   melhorar a performance da rede, foi incorporado uma alternativa no CVMP para
   este protocolo nas situacoes de troca de alta granularidade ou seja na troca de
   arquivos. Deste modo o CVMP tambem possui uma estrategia de troca e
   compartilhamento de arquivos atraves de metodos de API Windows que utilizam os
   protocolos nativos NetBeui e IPX/SX, determinado pela configuracao do Windows
   que, segundo a configuracao, aumenta a performance da troca de pacotes.
PA 6.5.1.3 - COMPARACAO ENTRE PLATAFORMAS DE TROCA DE
   MENSAGENS
   O CVMP pode ser visto como uma camada de software adicional a interface
   socket de acesso ao sistema de redes (CVMP distribuido), cujo objetivo e fornecer
   um modelo orientado a objetos, simples de usar, flexivel e reutilizavel para o
   desenvolvimento de programas concorrentes. Embora exista uma grande
   223
   CAPITULO 6
   diversidade de metodos para o desenvolvimento de sistemas distribuidos e
   programacao concorrente, que tambem constituem-se de camadas de software
   sobre os protocolos de rede, acreditamos que a principal contribuicao do CVMP e a
   simplificacao da metodologia, tornando mais simples e agil o trabalho do
   especialista e provendo os beneficios do paralelismo para programadores nao
   especialistas.
   Dentre as ferramentas para troca de mensagens, podemos destacar entre
   as mais populares atualmente: PVM, MPI, DCOM e CORBA. Elas representam
   duas classes distintas de estrategias de concorrencia: bibliotecas de funcoes e
   objetos distribuidos. A primeira, classe e composta pelo PVM (Parallel Virtual
   Machine) [Geist et al., 1996] e pelo MPI (Message Passing Inteface) [Pacheco,
   1997], que sao baseadas em bibliotecas de funcoes, contendo primitivas para o
   desenvolvimento de programas concorrentes, podendo ser incorporados como
   extensoes de linguagens de programacao generica ou especificas ou ainda parte
   integrante de algumas linguagens paralelas. A outra classe, objetos distribuidos, e
   caracterizada pelo DCOM (Distributed Component Object Model) [Grimes, 1997] e
   CORBA (Common Object Request Broker Architecture) [Grimes, 1997]. Nesse caso
   o paralelismo fica a cargo de uma camada extra de software integrada ao sistema
   operacional, que e responsavel pela distribuicao e comunicacao dos objetos. Um
   exemplo mais especifico do funcionamento dessa estrategia e apresentado pelo
   DCOM. O DCOM e um aperfeicoamento do COM, e por isso denominado na
   literatura de COM de longo alcance. COM (Component Object Model) [Grimes,
   1997] e uma evolucao do antigo padrao OLE (Object Linking and Embedding)
   [Wil iams, 1994]. Como e uma camada de software que fica acima das APIs do
   sistema, e possibilita a criacao de interfaces em aplicacoes, que permite que essas
   se comuniquem com outras em tempo de execucao. O DCOM e baseado na
   mesma filosofia do COM, no entanto ao inves de aplicacoes da mesma maquina se
   comunicarem, essa tecnologia permite que aplicacoes de diferentes maquinas
   conectadas via rede se comuniquem.
   Enquanto as bibliotecas de funcoes (PVM e MPI) foram desenvolvidas com
   a finalidade especifica de computacao cientifica de alta performance, ou seja
   voltadas para a computacao paralela, a tecnologia dos objetos distribuidos, possue
   uso mais voltado a integracao de aplicacoes dentro de um ambiente GUI, como e o
   caso do COM/DCOM, para a plataforma Windows e o CORBA para o projeto
   GNOME (GNU Network Object Model Environment) [GNOME], para plataforma
   224
   CVMP
   UNIX. Embora possa ser utilizado para programacao concorrente, a utilizacao mais
   frequente desta classe se destina a integracao de aplicacoes e interfaces graficas
   com o usuario sobre a rede, aplicacoes de banco de dados e Internet.
   Dentre essas duas alternativas as que mais se adequam ao
   desenvolvimento de programas concorrentes sao as bibliotecas de funcoes para
PA troca de mensagens. Entretanto, a sua utilizacao apresenta os mesmos problemas
   comuns a computacao paralela como um todo, ou seja a dificuldade de
   desenvolvimento de programas, limitando seus horizontes de utilizacao aos
   especialistas em computacao paralela. Embora a computacao paralela aparenta
   possuir um perfil ecletico, ou seja concentre seus esforcos para os especialistas,
   dificultando sua utilizacao para o programador comum, outra razao inviabiliza
   estudos mais arrojados para torna-las mais amigaveis, uma vez que essas
   ferramentas possuem uma natureza de programacao estruturada por
   procedimentos, fato que impede a utilizacao direta dos paradigmas da programacao
   orientada a objetos. Ainda que a tecnologia de objetos distribuidos seja toda
   baseada no conceito de orientacao a objetos, a sua utilizacao para a computacao
   paralela esta muito longe de ser simples para o usuario, especialmente em
   ambiente Windows. Alem de dificuldade de programacao das interfaces COM,
   mesmo sendo parte integrante dessa plataforma, e necessaria toda uma
   configuracao dos sistemas em rede para a sua utilizacao. Outro fator limitante para
   a utilizacao dessa tecnologia, e o fato de que apenas as maquinas NT podem ser
   servidoras DCOM, as maquinas com a plataforma Windows 95 se limitam apenas a
   serem clientes.
   O CVMP, mais do que um conjunto de ferramentas para a implementacao
   de programas paralelos baseados em troca de mensagens, representa um novo
   conceito, que mostra como a computacao paralela pode ser estendida para
   diversas areas e utilizada por um espectro de usuarios muito maior. Dentro desse
   prisma, o CVMP nada mais e do que uma camada adicional de software, criada
   para tornar a programacao paralela simples e amigavel. Neste contexto o CVMP
   pode estar baseado em qualquer mecanismo de troca de mensagens, podendo
   assim, ser uma camada adicional ao PVM e MPI e ate mesmo ao DCOM e CORBA.
   Em algumas situacoes essas alternativas podem ser especialmente atraentes, uma
   vez que possibilitariam uma integracao imediata com sistemas e programas
   paralelos ja implementados nessas plataformas.
   225
   CAPITULO 6
   6.5.1.4 - DESEMPENHO EM REDE
   Nessa secao vamos discutir alguns resultados do desempenho da
   transferencia de pacotes pela rede. O desempenho da comunicacao em rede
   depende de diversos fatores, que vao desde o hardware ate as diversas camadas
   de software envolvidas na comunicacao, a descricao do modelo de camadas da
   rede e suas funcoes sao apresentados de forma bastante didatica por Tanenbaum
   [Tanenbaum, 1989]. O CVMP e baseado em chamadas diretas as APIs, em ambas
   as estrategias de troca de mensagens (baixa e alta granularidade), de modo que,
   embora seja uma camada de software adicional ao sistema de rede, e praticamente
   desprezivel, no calculo do desempenho, uma vez que e diversas vezes mais leve
   que as demais camadas envolvidas no processo. Deste modo o desempenho da
   comunicacao CVMP e praticamente igual ao desempenho do Winsock, para
   pacotes de granularidade baixa e ao protocolo NetBeui - IPX/SX para as
   granularidades altas.
   Os gargalos que influenciam o desempenho da rede, podem ser
   comparados a uma piramide, onde a base (meio fisico e hardware) determina o
   desempenho maximo, que diminui a cada camada adicional. Deste modo a
   configuracao da rede e um fator imprescindivel para a eficiencia da comunicacao. A
   interface entre o software e o hardware, e um elemento que pode limitar bastante a
PA performance. Essa interface e realizada atraves de programas conhecidos como
   device driver. Usualmente os sistemas operacionais possuem device drivers
   genericos, que nao exploram as caracteristicas especificas do hardware, e
   consequentemente comprometem a sua performance.
   Realizamos as medidas de desempenho de comunicacao do CVMP em uma
   rede de computadores plataforma Windows com configuracao generica. Uma vez
   que o CVMP possui um consumo de software desprezivel em relacao as outras
   camadas da rede, nossas medidas expressam o desempenho do proprio sistema
   operacional em uma rede padrao ethernet NE2000 de 10 Mbits/s.
   226
   CVMP
   a)
   b)
   c)
   Fig. - 6.5 - Graficos do desempenho de transferencia de pacotes via rede. (a)
   CVMP usando protocolo TCP/IP, (b) CVMP usando transferencia de arquivo
   atraves de chamada a API, utilizando protocolo NetBeui e (c) comparacao
   entre os resultados de (a) e (b).
   A Figura 6.5 apresenta os graficos com os resultados obtidos da
   transferencia de diferentes tamanhos de pacotes em funcao do tempo. Neles sao
   apresentados os resultados dos dois procedimentos de transferencia de dados do
   CVMP. Na Figura 6.5 (a), e apresentado o resultado do desempenho de
   transferencia do Winsock usando TCP/IP, atraves dos procedimentos do CVMP
   para baixa granularidade e no grafico (b) os procedimentos para alta granularidade,
   que consistem na troca de arquivos atraves de chamadas a API usando o protocolo
   227
   CAPITULO 6
   NetBeui e IPX/SX. Como podemos observar no grafico (c) os protocolos NetBeui e
   IPX/SX apresentam um desempenho melhor de transferencia de dados que o
   protocolo TCP/IP em plataforma Windows, o que nos motivou a implementar dois
   metodos diferentes para troca de mensagens via rede, um para alta e outro para
   baixa granularidade de pacotes, a fim de otimizar a comunicacao. As linhas do
   grafico (c) representam o tracado da reta ajustada a partir da regressao linear dos
   pontos de cada caso, obtivemos como resultados as taxas aproximadas de 5
   megabits/s e 8 megabits/s respectivamente para os protocolos TCP/IP e NetBeui.
   6.5.2 - ARQUITETURA MIMD COMPARTILHADA
   A arquitetura MIMD compartilhada, diferente da arquitetura MIMD
   distribuida, e caracterizada pelo multiprocessamento, ou seja, por uma maquina
   constituida de diversos processadores que compartilham memoria. Assim como os
   sistemas distribuidos, comentados anteriormente, os processadores dessa
   arquitetura, podem trabalhar em conjunto, efetuando comunicacoes atraves da
   troca de mensagens. Nesse modelo, os processadores utilizam a memoria
   compartilhada para a comunicacao.
   processador
   Canal Virtual
   CVMP
   memoria
   Processo
   Fig. - 6.6 - Exemplo de uma aplicacao paralela CVMP em uma arquitetura
   MIMD compartilhada. Nesse exemplo temos uma maquina multiprocessada
PA com 3 processadores.
   A Figura 6.6 apresenta um exemplo dessa arquitetura, nela temos uma
   maquina constituida por 3 processadores, que compartilham a mesma memoria.
   228
   CVMP
   Em cada um dos processadores esta alojado um processo, dos quais os dois da
   extremidade sao escravos e o central e o mestre. Assim como na arquitetura
   distribuida, atraves dos objetos CVMP (pequenos quadrados no interior dos
   processos), sao estabelecidos canais virtuais, que possibilitam a troca de
   mensagens entre os processos.
   Processo A
   Processo B
   Processador 1
   Processador 2
   Memoria compartilhada
   Fig. - 6.7 - Diagrama ilustrativo do mecanismo de troca de mensagens em
   sistema MIMD compartilhado.
   Nos objetos CVMP memoria compartilhada, os canais virtuais utilizam a
   memoria compartilhada para trocar mensagens. A Figura 6.7 apresenta uma
   ilustracao desse conceito. Nela temos dois processadores efetuando troca de
   mensagens a partir de memoria compartilhada.
   A troca de mensagens atraves da memoria compartilhada e realizada no
   CVMP atraves do mecanismo do Windows denominado de "filemapping", que
   consiste num conjunto de APIs que permitem a manipulacao da memoria global
   (memoria RAM e memoria virtual) com requintes de tratamento de arquivos [Deatz,
   1997] [Petzold, 1995] [Petzold & Yao, 1996] [Richter, 1995]. Atraves desse
   mecanismo, sao estabelecidos os Canais virtuais, que permitem que diferentes
   processos, alojados em processadores diferentes ou no mesmo processador,
   possam realizar a troca de mensagens atraves de objetos CVMP.
   A performance da comunicacao nessa arquitetura e muito superior a
   distribuida, sendo que a taxa de transferencia entre processador e memoria RAM e
   incomparavelmente mais alta do que em rede, mesmo se considerarmos a
   229
   CAPITULO 6
   transferencia atraves da memoria virtual, que pode envolver operacoes em disco,
   ainda assim o desempenho seria muito superior ao obtido via rede. Alem de taxa de
   transferencia superior, o tempo de acesso tambem e bastante inferior, diminuindo
   assim a latencia da comunicacao. Deste modo, essa arquitetura pode ser bastante
   promissora para sistemas na area de visao, que demandam consideravel troca de
   dados. Entretanto, o alto custo de hardware, assim como o numero relativamente
   baixo de processadores por maquinas disponiveis no mercado (4 processadores
   por maquina) ainda inviabilizam essa arquitetura. A combinacao das duas
   arquiteturas, MIMD compartilhado e distribuido aparenta ser uma solucao bastante
   interessante, uma vez que aumenta o numero de maquinas no sistema paralelo
   assim como possibilita estrategias de balanceamento de carga, algoritmos com
   maior gargalo em troca de mensagens alojados na arquitetura compartilhada e
   menor na distribuida.
   6.6 - FUNCIONAMENTO BASICO CVMP
   O CVMP basico e o objeto elementar da ferramenta CVMP. Trata-se de um
   componente VCL nativo em Delphi que possui propriedades e metodos que
PA efetuam a troca de mensagens e controle entre processos, sendo composto de
   duas versoes, uma para arquitetura MIMD distribuida (Tcvmp) e outra para
   arquitetura MIMD compartilhada (Tcvmps).
   A operacao do CVMP e bastante simples. Como primeiro passo, usualmente
   nas operacoes de VCL do Delphi, o programador deve arrastar e soltar o CVMP
   basico da paleta de componentes CVMP sobre o seu formulario. Efetuado esse
   procedimento, deve-se entao criar um arquivo de configuracao do objeto. O arquivo
   de configuracao e um arquivo em formato ASCII que contem as informacoes (a
   respeito das maquinas, redes e porto socket) necessarias para que o objeto possa
   estabelecer um canal virtual. A Figura 6.8 apresenta um exemplo tipico de um
   arquivo de configuracao.
   O arquivo de configuracao pode ser criado e editado de diferentes maneiras.
   O usuario pode criar o arquivo com um editor de textos qualquer ou entao utilizar o
   gerador automatico de arquivo de configuracao, que acompanha as ferramentas
   CVMP. O gerador automatico e uma aplicacao bastante simples, onde o usuario
   preenche os campos e a partir desses dados sao gerados os arquivos de
   configuracao. Ainda outra alternativa e configurar as propriedades do componente
   230
   CVMP
   CVMP diretamente. Isto pode ser feito atraves de programacao, ou ainda pela
   janela Object Inspector do ambiente Delphi, atraves das propriedades: master_ip (ip
   da maquina), master_n (nome e dominio), master_pt (porto socket), slave_ip,
   slave_n e slave_pt.
   Conteudo do arquivo de
   configuracao
   Numero IP da maquina
   [slave]
   Informacoes sobre
   ip=10.6.1.2
   a maquina escrava
   name=neon.river.omb
   Nome e dominio
   path=c:\cyvis\temp
   ;
   [master]
   Localizacao do diretorio
   Informacoes sobre
   ip=10.6.1.1
   para troca de arquivos
   a maquina mestre
   name=acara.river.omb
   path=d:\cyvis\temp
   ;
   Informacoes sobre
   [port]
   o canal virtual
   port=5000
   Fig. - 6.8 - Exemplo de um arquivo de configuracao do objeto CVMP.
   Uma vez editado o arquivo de configuracao deve ser atribuido a propriedade
   mp_init_file o nome e o diretorio onde se encontra o arquivo de configuracao
PA correspondente ao objeto. Devemos lembrar que cada canal virtual possui dois
   arquivos de configuracao identicos, um para o objeto mestre e o outro para o
   escravo. Os arquivos de configuracao sao identicos para os objetos CVMP MIMD
   compartilhado e distribuido. Nos objetos CVMP para arquitetura distribuida, a
   configuracao port define o porto do socket a ser utilizado pelo canal virtual,
   enquanto que, para a arquitetura compartilhada, o port define os rotulos dos
   ponteiros para a memoria. Nao poderao haver mais de um Canal Virtual com o
   mesmo numero de port em uma mesma arquitetura.
   Apos a configuracao dos objetos CVMP, o canal virtual esta pronto para ser
   estabelecido e realizar a troca de mensagens, sendo estas tarefas de programacao
   realizadas a partir da manipulacao dos metodos e propriedades do objeto CVMP.
   No momento do estabelecimento dos canais virtuais, sao definidos os papeis de
   cada objeto. No objeto escravo e executado o metodo mp_listen ou mp_slave,
   231
   CAPITULO 6
   deste modo, esse objeto ficara aguardando a primeira conexao de seu par mestre
   para que o canal virtual seja estabilizado. Estando o objeto escravo aguardando a
   conexao, deve ser entao executado, no objeto a ser definido como mestre o metodo
   mp_connect ou mp_master. Deste modo esta estabelecido um canal virtual entre os
   dois objetos, permitindo a troca de mensagens entre estes dois componentes
   (mestre e escravo).
   6.6.1 - PROGRAMACAO
   A programacao de aplicacoes paralelas com o CVMP e realizada a partir de
   um conjunto de primitivas, que realizam a troca de mensagens, caracterizadas por
   metodos e propriedades do objeto CVMP. Figura 6.9 apresenta as principais
   primitivas de troca de mensagens e suas respectivas funcoes.
   mp_init_file
   Propriedade, determina o nome e a
   localizacao do arquivo de configuracao.
   mp_listen, mp_slave
   Metodo, define o objeto como escravo.
   Utilizado para estabilizar o Canal Virtual.
   mp_connect, mp_master Metodo, define o objeto como mestre.
   Utilizado para estabilizar o Canal Virtual.
   mp_send(mens:str)
   Metodo, envia uma mensagem atraves do
   Canal Virtual.
   str:=mp_receive
   Metodo, funcao que retorna a primeira
   mensagem da fila de mensagens recebidas.
   setblocking
   Metodo, define se as mensagens sao
   bloqueantes ou nao.
   sendfile(str)
   Metodo, envia mensagem de alta
   granularidade (arquivos).
   receivefile(str)
   Metodo, recebe mensagem de alta
   granularidade (arquivos).
   mp_close
PA Metodo, termina o Canal Virtual.
   Fig. - 6.9 - Principais primitivas de troca de mensagens.
   A partir da utilizacao das primitivas e possivel desenvolver as aplicacoes
   paralelas, programando as diferentes estrategias de paralelismo a partir das trocas
   de mensagens. Referencias para algumas estrategias de paralelismo sao
   encontradas em [Almasi & Gottlieb, 1994] [Amorin et al.,1988] [Bem-Ari, 1990]
   [Brawer, 1989] [Codenoti & Leoncini, 1994] [Foster, 1995].
   A Figura 6.10 apresenta um exemplo de um algoritmo concorrente utilizando
   232
   CVMP
   as primitivas CVMP. Nele temos quatro computacoes sendo realizadas, A, B, C e D,
   onde os calculos C e D sao obtidos mediante os resultados de A e B. Vamos supor
   que cada um destes calculos leva um tempo igual a t. Supondo que t e muito maior
   que o tempo da troca de mensagem realizada (basicamente os resultados e
   parametros da computacao), entao podemos desconsiderar o tempo tomado pelos
   processos de comunicacao. Caso esse algoritmo hipotetico seja implementado de
   modo sequencial, o tempo total seria de 4t. O algoritmo apresentado na Figura 6.10
   e uma versao paralela para essa computacao tal que os calculos A e B sao
   executados simultaneamente em duas maquinas, e apos a troca de resultados
   entre os processos, C e D sao igualmente processados em concorrencia, em cada
   uma das maquinas. Deste modo temos um tempo total de processamento igual a
   2t, obtendo uma performance de computacao 2 vezes maior. Caso nao houvesse a
   dependencia de dados (C e D necessitarem dos resultados de A e B), o numero de
   maquinas poderia ser maior, aumentando ainda mais a performance do sistema.
   Algoritmo processo Mestre
   Algoritmo processo Escravo
   cvmp1.MP_init_file(`init.ini');
   cvmp1.MP_init_file(`cyv.ini');
   cvmp1.MP_connect;
   cvmp1.MP_listen;
   cvmp1.MP_send:=`start';
   while f<>`start' do begin
   application.processmessages;
   f:=cvmp1.receive;
   CALCULA B
   end;
   cvmp1.MP_send:=b;
   CALCULA A
   a:=cvmp1.MP_receive;
   b:=cvmp1.MP_receive;
   CALCULA C
   cvmp1.MP_send:=a;
   (A em B)
   while f<>`end' do begin
   CALCULA D
   application.processmessages;
   (B em A)
   f:=cvmp1.receive;
   end;
   result2:=cvmp1.mp_receive;
PA cvmp1.mp_send:=`end';
   show (result1, result2);
   cvmp1.mp_send:=result2;
   Fig. - 6.10 - Exemplo de implementacao de um algoritmo paralelo utilizando
   as primitivas CVMP.
   233
   CAPITULO 6
   6.6.2 - MODELO EM CAMADAS
   Devido a sua natureza orientada a objetos, o CVMP permite sua reutilizacao
   e consequentemente o desenvolvimento de outros objetos, que herdam suas
   propriedades. Esse conceito e fundamental para a arquitetura do CVMP, permitindo
   que sejam desenvolvidos outros objetos, com maior nivel de especificidade, mais
   simples de utilizar, programacao visual mais desenvolvida e etc. Desta forma, alem
   do desenvolvimento das ferramentas que compoem o conjunto CVMP, tambem e
   possivel o desenvolvimento personalizado de novos componentes, de acordo com
   as necessidades do programador. Assim, o CVMP pode ser visto como um modelo
   de camadas, onde o CVMP basico e a camada basica que permite a insercao de
   um numero ilimitado de camadas adicionais.
   Nas proximas secoes vamos apresentar uma serie de objetos e aplicacoes
   que foram desenvolvidas a partir desse principio. Um exemplo de componente
   personalizado e o CyComm [Moreira, 1999], desenvolvido em conjunto com Jander
   Moreira e Alan Felinto. Ele incorpora diversas caracteristicas, tais como um editor
   interno para modificar o arquivo de configuracao, protocolos adicionais para troca
   de imagens e servidor de imagem para maquinas com sistema de captura. Esse
   componente foi utilizado para desenvolver o sistema de comunicacao e controle de
   alguns modulos do sistema descrito no Capitulo 8 desta tese.
   6.7 - DISPARADOR DE APLICACOES (LAUNCHER)
   Launcher ou disparador de aplicacoes e a denominacao que atribuimos a
   ferramenta responsavel pela execucao de processos remotos. Atraves de sua
   utilizacao o modulo principal do sistema pode disparar aplicativos, em geral
   escravos, ao longo da rede. O CVMP-launcher, e composto por dois aplicativos e
   um componente, sendo que os aplicativos sao constituidos pelo modulo principal e
   pelos disparadores.
   Os modulos disparadores possuem um sistema de instalacao que altera os
   registros do sistema operacional de forma que estes sao executados toda vez que o
   Windows e reiniciado, nao necessitando que o usuario sequer entre em sua area.
   Deste modo, mesmo maquinas sendo utilizadas por outros usuarios podem ser
   solicitadas para executar processos do sistema paralelo. Os modulos disparadores
   sao instalados nas diversas maquinas da rede, a serem utilizadas pelo sistema
   234
   CVMP
   distribuido; sua funcao e aguardar as ordens do modulo principal e mediante elas,
   disparar processos locais.
   (a)
   (b)
   Fig. - 6.11 - Modulo principal do aplicativo CVMP-Launcher. (a) Janela
   principal, (b) Janela de configuracao.
   Na rede pode existir uma ou mais maquinas com modulos principais, em
   geral essa ou essas maquinas sao responsaveis pelo controle do sistema, e vao
   requerer a execucao de processos escravos espalhados pela rede. A Figura 6.11
PA apresenta a janela do modulo principal, com a respectiva janela de configuracao.
   Os processos remotos podem ser disparados remotamente ou atraves do objeto
   Tlauncher, baseado no CVMP para memoria compartilhada, esse componente
   envia mensagens para o modulo principal, ativando o disparo de mensagens para
   as maquinas remotas, de modo que estas possam executar os processos remotos.
   6.8 - CVMP PROCESSOR FARM
   O CVMP processor farm e constituido de um conjunto de componentes
   Delphi, desenvolvido sobre o CVMP, que permite a implementacao visual de
   235
   CAPITULO 6
   aplicativos paralelos que utilizam a estrategia processor farm. Desenvolvido para
   simplificar a programacao de algoritmos paralelos, o CVMP processor farm permite
   que ate mesmo os programadores mais inexperientes possam desenvolver seus
   proprios sistemas distribuidos.
   Dentre as estrategias de paralelismo, observamos que o processor farm (ou
   fazenda de processadores) e bastante generico e pode ser amplamente utilizado
   nos mais diversos algoritmos de visao. Uma caracteristica bastante importante
   dessa estrategia e o balanceamento automatico de carga, atraves do qual sistemas
   hibridos, com maquinas com performances diferentes, podem ser prontamente
   utilizados, sem que o programador se preocupe com a distribuicao das maquinas
   que compoem o sistema e seu poder computacional.
   A Figura 6.12 apresenta um diagrama que ilustra essa estrategia. Como
   podemos observar, o processor farm consiste em um processo de supervisao que
   controla e distribui tarefas para um conjunto de processos escravos. Os processos
   escravos sao ordenados atraves de uma fila de processos livres, que fica
   armazenada no supervisor. Quando for necessario distribuir uma tarefa, o
   supervisor escolhe o primeiro elemento da fila, atribui a este uma tarefa, e entao
   retira-o da fila. A medida que os processos escravos vao terminando a execucao
   das tarefas, vao sendo inseridos novamente na fila de processos disponiveis. O
   principal inconveniente dessa estrategia e a sua preferencia a sistemas sem
   dependencia de dados. No entanto, atraves de algumas adaptacoes, pode-se
   utiliza-la mesmo em sistemas com relativa dependencia de dados.
   proce
   vres
   ss
   li
   os exe
   Supervisor
   cu
   rocessos
   ta
   p
   ndo
   la de
   ta
   Fi
   refas
   Fig. - 6.12 - Diagrama ilustrativo da estrategia de paralelismo processor farm.
   236
   CVMP
PA O CVMP processor farm foi desenvolvido com o intuito de fornecer
   sofisticados recursos para a implementacao de sistema distribuidos e ao mesmo
   tempo ser simples de usar, de modo que ate o mais inexperiente dos
   programadores possa desenvolver sua aplicacao paralela. Assim, o CVMP
   processor farm e o ponto aureo do CVMP, permitindo o desenvolvimento generico
   de aplicacoes paralelas de modo visual e intuitivo.
   Fig. - 6.13 - Janelas do object inspector do Delphi, mostrando as
   propriedades e eventos dos objetos CVMP Processor Farm (a) supervisor
   (TprocFarmM4) e (b) escravo (TprocFarmS).
   O CVMP processor farm e constituido basicamente de dois componentes:
   escravo e mestre (supervisor). Os componentes escravos, assim como o
   componente mestre, devem ser arrastados e soltos no formulario das aplicacoes
   escravas e de supervisao, respectivamente. Atraves do object inspector, o
   programador configura alguns poucos atributos e seleciona os eventos a serem
   programados. A Figura 6.13 apresenta a janela do object browser mostrando as
   propriedades e eventos dos objetos supervisor e escravo. O objeto supervisor
   utilizado na Figura 6.13 tem um limite de controle de 4 processos escravos
   (designados pelos eventos A,B,C e D), no entanto implementamos 3 objetos
   237
   CAPITULO 6
   supervisores, para controlar diferentes numeros maximos de processos escravos
   (4, 8 e 16 processos).
   A sua utilizacao simplificada permite, conforme vamos demonstrar, que um
   sofisticado sistema distribuido possa ser implementado mediante alguns cliques de
   mouse e poucas linhas de codigo. Para exemplificarmos, vamos imaginar um
   exemplo bem simples que possa ilustrar a utilizacao do CVMP Processor Farm.
   Dada uma funcao hipotetica, a qual vamos chamar de F, que a partir de um
   determinado numero de parametros ( p), realize um calculo interativo retornando um
   resultado, vamos presumir que nosso problema necessite dos resultados de
   diversas chamadas a F. Supondo que, toda a vez em que F e executada, um
   demasiado poder computacional seja demandado; deste modo, uma solucao
   paralela pode aumentar a performance do sistema e consequentemente diminuir o
   tempo de resolucao. Assim, supondo que cada execucao de F demore 1 minuto e
   nosso problema necessite de 120 calculos, nossa aplicacao levara 2 horas para ser
   executada em uma maquina. Nessa situacao, se utilizarmos 4 maquinas iremos
   reduzir o tempo de execucao em 1/4 (30 minutos).
   A Figura 6.14 apresenta a principal rotina da maquina escrava. Ela e
   chamada pelo evento OnTask, que podemos ver na Figura 6.13. Com pequenas
   linhas de codigo, o CVMP processor farm permite que o programador extraia os
   parametros, enviados pelo supervisor, para calculo da funcao e depois de calculado
   F retorne o resultado para ele. Em nosso exemplo como temos um unico modelo de
   escravo, nao existe necessidade de escrever um codigo especifico para cada
   maquina, bastando replicar o aplicativo e distribui-lo na rede.
   procedure TForm1.ProcFarmS1Task(Sender: TObject; me: String);
   var index,result:string;
   vet:array [1..10] of real;
   x:integer;
   Extrai o primeiro elemento da mensagem
   begin
   Extrai os dez parametros para o calculo de F
PA index:=ProcFarmS1.unpack(me);
   for x:=1 to 10 do vet[x]:=strtofloat(ProcFarmS1.unpack(me));
   result:=floattostr(calcf(vet));
   ProcFarmS1.pack(index,result);
   Calcula F - parametros passados por vet
   ProcFarmS1.mess:=result;
   end;
   Empacota o indice e o resultado
   Mensagem a ser re-transmitida para o supervisor
   Fig. - 6.14 - Exemplo de codificacao do evento OnTask do componente
   escravo do CVMP processor farm.
   238
   CVMP
   Na Figura 6.15, temos alguns segmentos de codigo da aplicacao
   supervisora. Para nosso exemplo, sao necessarios dois eventos para cada
   processo escravo, um para a designacao das tarefas ( OnIniTask) e outro para o
   termino das tarefas e recebimento do resultado ( OnEndTask), respectivamente
   mostrados na Figura 6.15 (A) e (B). Deste modo, como podemos observar atraves
   dos codigos, a programacao do supervisor e muito simples, necessitando poucas
   linhas de codigo. Para iniciar o processamento paralelo, deve ser executado o
   metodo descrito em (C), onde o primeiro parametro deve conter o numero de
   processos utilizados e no segundo, o numero de tarefas a serem distribuidas.
   procedure TForm1.ProcFarmM1IniTaskA(Sender: TObject; t: Integer); (A)
   var mensagem:string;
   a:integer;
   Incrementa i, variavel global que determina o indice da linha
   begin
   de mat, que contem os parametros a serem calculados por F
   i:=i+1;
   Empacota o indice em mensagem
   ProcFarmM1.pack(inttostr(i),mensagem);
   for a:=1 to 10 do ProcFarm1.pack(floattoint(mat[i,a]),mensagem);
   Empacota os parametros
   ProcFarmM1.task:=mensagem;
   end;
   Mensagem a ser enviada para o escravo
   procedure TForm1. ProcFarmM1EndTaskA(Sender: TObject; task: String); (B)
   var index:integer;
   begin
   Desempacota o indice, de task,
   index:=strtotint(ProcFarmM1.unpack(task));
   mensagem recebida pelo mestre.
   res[index]:=strtofloat(ProcFarmM1.unpack(task));
   end;
   Desempacota o resultado
   e armazena no vetor res.
   ProcFarmM1.execute(num. de processos, num. de tarefas)
   (C)
   Fig. - 6.15 - Exemplo de codificacao dos eventos do componente supervisor
   do CVMP processor farm. (A) Evento OnIniTask , disparado antes de ser
PA atribuida a tarefa para um processo escravo. (B) Evento OnEndTask ,
   disparado assim que o escravo finalizou a tarefa. (C) Metodo para iniciar a
   execucao do processamento.
   A configuracao do sistema tambem e muito simples e pode ser realizada
   visualmente pelo proprio usuario, nao necessitando ser feita via programacao. Para
   isso deve ser executado o metodo config (do componente supervisor), que
   apresenta uma janela em tempo de execucao na qual o usuario descrimina os
   239
   CAPITULO 6
   nomes, diretorios e IP dos processos escravos, conforme mostrado na Figura 6.16.
   Esse procedimento gera automaticamente todos os arquivos de configuracao do
   sistema, tanto para o supervisor como para os escravos.
   Fig. - 6.16 - Janela de configuracao automatica da distribuicao do sistema,
   exibida atraves de chamada ao metodo config do componente supervisor.
   Os componentes possuem ainda mecanismos para visualizar o
   processamento em tempo de execucao. Se a propriedade watch (ver Figura 6.13)
   estiver atribuida como verdadeiro, entao o sistema exibe uma janela que mostra
   simultaneamente um resumo do trafego de mensagens enviadas e recebidas pelo
   objeto. Isso pode ser bastante util para depurar o sistema, assim como para
   analisar seu comportamento. O componente supervisor possui tambem acesso
   automatico a ferramenta de visualizacao de estatistica e desempenho em tempo de
   execucao, descrita na proxima secao.
   6.9 - ANALISE DE DESEMPENHO E ESTATISTICAS
   Uma tarefa muito importante nos projetos de programas paralelos e a
   analise de desempenho e estatisticas, atraves das quais vai ser estimada a
   performance, o balanco de carga e os gargalos do sistema. Um dos empregos do
   240
   CVMP
   paralelismo consiste em aumentar a performance dos mecanismos computacionais
   para uma execucao mais rapida dos algoritmos. No entanto, os gargalos, a ma
   distribuicao das cargas e o emprego incorreto de uma determinada estrategia de
   paralelizacao podem fazer com que os sistemas paralelos sejam ate mesmo mais
   lentos que os sequenciais, perdendo completamente seu sentido de existencia.
   As medidas de analise de desempenho e suas estatisticas constituem em
   uma ardua tarefa para o programador, que muitas vezes, devido a escassez de
   ferramentas apropriadas, tem que desenvolver programas para auxilia-lo na
   realizacao dessas medidas, tomando grande parte de seu tempo. Devido a esses
   fatores, desenvolvemos algumas ferramentas para extrair medidas de performance,
   de modo a auxiliar o programador e simplificar esta importante etapa no
   desenvolvimento de sistemas paralelos.
   As ferramentas de analise de desempenho e estatistica do CVMP se
   dividem em dois grupos: analise estatica e analise dinamica.
   6.9.1 - FERRAMENTAS PARA ANALISE ESTATICA
   As ferramentas para analise estatica sao compostas por um componente
   ( TStat) e um aplicativo de visualizacao. O componente TStat, e uma ferramenta de
   uso generico para auxiliar as medidas de desempenho de programas sequenciais
   ou paralelos. Atraves dela o programador pode estimar o tempo de duracao dos
   procedimentos, funcoes, metodos utilizados em seus programas ou ate mesmo o
   tempo de execucao de uma linha ou de um conjunto de linhas de codigo.
   A Figura 6.17 contem um exemplo da utilizacao do TStat, mostrando a
PA utilizacao do componente para um caso hipotetico. Nele sao apresentados os
   metodos do componente TStat:
   initialize e terminate: Metodos utilizados para iniciar e terminar as medidas
   realizadas por TStat. Quando o metodo initialize e chamado, inicia a
   contagem do tempo total da medida, sendo concluida com o metodo
   terminate.
   start e finish: Marcam o tempo das linhas de codigo entre a chamada aos
   metodos start e finish.
   makefile: Grava um arquivo contendo as medidas realizadas.
   241
   CAPITULO 6
   stat.initialize:='medida';
   Inicia a analise (denominada medida)
   stat.start:='calcxtot';
   for a:=1 to 10 do begin
   stat.start:='calcx'+inttostr(a);
   Mede o tempo total
   x[a]:=calcx(a);
   Mede o tempo
   dos laco de calculo
   stat.finish:='calcx'+inttostr(a);
   de calcx
   de calcxtot
   end;
   stat.finish:='calcxtot';
   stat.start:='calcB';
   Mede o tempo
   calcb(vet);
   de calcB
   stat.finish:='calcB';
   Termina a analise (denominada medida)
   stat.terminate:='medida';
   stat.makefile:='nomedoarquivo';
   Gera o arquivo das medidas
   Fig. - 6.17 - Exemplo da utilizacao do componente TStat.
   (a)
   (b)
   (c)
   Fig. - 6.18 - Janelas da aplicacao StatViewer, apresentando algumas das
   diferentes formas de visualizacao em blocos das medidas. As linhas
   horizontais representam os 4 processos paralelos, formados pelos blocos
   que exprimem as tarefas. (a) Visualizacao com blocos simples, (b) com blocos
   pequenos e (c) com linhas.
   242
   CVMP
   O aplicativo de visualizacao, denominado StatViewer, apresenta as medidas
   para o usuario, a partir do arquivo gerado pelo componente TStat. Atraves de
   diagramas de barras, as medidas podem ser visualizadas, permitindo a analise da
   arquitetura paralela e da distribuicao dos processos, a localizacao de gargalos e,
   deste modo, possibilitando o aprimoramento do projeto e seu consequente aumento
PA de performance. A Figura 6.18 apresenta um exemplo da visualizacao das medidas
   atraves do StatViewer, nela sao mostradas 3 janelas com diferentes diagramas de
   barras que mostram os resultados de um sistema com arquitetura processor farm,
   composto por 4 maquinas escravas (processos), representadas pelas linhas
   verticais das janelas. Estas sao compostas por blocos, onde cada um corresponde
   a uma tarefa.
   Alem de permitir a visualizacao das medidas, o StatViewer possui uma serie
   de metodos para auxiliar o usuario, entre eles: o zoom, permitindo observar maiores
   detalhes entre os processos e tarefas; a personalizacao das cores dos blocos,
   permitindo destacar ou agrupar blocos com cores especificas, facilitando assim a
   analise; e a listagem dos processos e tarefas com suas respectivas medidas.
   6.9.2 - FERRAMENTAS PARA ANALISE DINMICA
   As ferramentas para analise dinamica se assemelham muito as estaticas,
   diferenciando-se essencialmente por permitirem a analise do sistema em tempo de
   execucao. Assim como as ferramentas para analise estatica, sao constituidas por
   um componente ( TStatOnLine) e por uma aplicacao de visualizacao ( StatOnLine).
   O componente TStatOnLine possui propriedades similares ao TStat,
   possuindo a mesma metodologia de utilizacao, no entanto, ao inves de armazenar
   as medidas e arquiva-las num arquivo, o objeto as envia para a aplicacao
   StatOnLine, permitindo desta maneira sua visualizacao em tempo de execucao. A
   comunicacao entre o componente e a aplicacao e realizada a partir do CVMP
   memoria compartilhada, para tanto foi necessario encapsular este objeto no
   componente StatOnLine.
   243
   CAPITULO 6
   (a)
   (b)
   (c)
   Fig. - 6.19 - Janelas da aplicacao StatOnLine, apresentando as medidas de
   performance de uma aplicacao paralela (processor farm) com 4 maquinas
   escravas. Visualizacao com blocos(a) e (b) e listagem das medidas (c).
   A aplicacao StatOnline fica a espera de mensagens contendo as medidas
   realizadas pelo componente, e uma vez que as recebe, armazena-as na memoria
   e exibe-as, possibilitando visualizar o comportamento do sistema durante o
   processamento. A Figura 6.19 apresenta tres janelas da aplicacao StatOnline,
   exibindo as medidas de um sistema distribuido com estrategia processor farm,
   constituido de 5 maquinas (1 supervisor e 4 escravos). Em (a) temos um diagrama
   de blocos no qual as linhas horizontais representam as maquinas escravas, os
   blocos que constituem as linhas representam as tarefas executadas em funcao do
   tempo. Em (b) cada um dos graficos (1, 2, 3 e 4) representa respectivamente cada
   maquina e os blocos das tarefas realizadas em cada uma, cuja duracao e expressa
   por sua altura. Finalmente em (c) temos as listagens das medidas de tempo de
   244
   CVMP
   duracao, inicio e termino, de cada tarefa.
   6.10 - COMPONENTE VISUAL PARA OPERACOES
   BASICAS DE PROCESSAMENTO DE IMAGENS
   A convolucao de mascaras (templates) com a imagem constitui uma
   abordagem classica para a operacao de alguns filtros, tais como detectores de
   bordas (filtros passa alta, Sobel, Robert e outros), filtros de suavizacao (filtragem
PA gaussiana, media da vizinhanca e outros) e de realce (passa baixa) [Castleman,
   1996] [Gonzalez & Woods, 1993] [Parker, 1997]. Por se tratar de operacoes basicas
   e por sua popularidade, esses filtros sao amplamente utilizados. Nessa secao
   apresentamos um experimento realizado para demonstrar o potencial de criacao de
   componentes personalizados e da extrema simplicidade de desenvolvimento e
   operacao utilizando CVMP.
   Devido a simplicidade das tecnicas de convolucao de mascaras e a sua
   larga utilizacao, decidimos adota-las para o experimento. A partir do componente
   TImage, que acompanha o Delphi, e do CVMP processor farm, foram
   desenvolvidos os componentes TSobelPar (mestre e escravo) e TMaskPar (mestre
   e escravo). Devemos lembrar que, ao inves de estarmos preocupados com as
   questoes de performance, como e usual, tratando-se de sistemas paralelos, nesses
   experimentos nos preocupamos com a didatica e com a maxima simplicidade de
   utilizacao do sistema.
   A Figura 6.20 mostra um diagrama ilustrativo de um sistema implementado
   utilizando os componentes TSobelPar. Nele temos quatro aplicacoes, uma mestra e
   tres escravas. A operacao e programacao dos componentes sao simplificados,
   bastando arrastar e soltar os componentes no formulario da aplicacao, e executar
   uma linha de codigo nas aplicacoes escravas (metodo TSobelParS.run na maquina
   escrava) e uma nas aplicacoes mestras ( metodo TsobelParM.run(numero de
   maquinas) ).
   Depois da execucao do metodo na aplicacao mestra e realizada a criacao
   dos Canais Virtuais e em seguida, a aplicacao mestre divide a imagem contida no
   componente visual TSobelParM, em tiras horizontais (no exemplo da Figura 6.20 a
   imagem e dividida em 4 tiras). Apos essa divisao, uma das tiras permanece na
   aplicacao mestre, enquanto as demais sao transmitidas para as aplicacoes
   245
   CAPITULO 6
   escravas. Apos a transmissao inicia-se a execucao da convolucao da mascara
   Sobel. As imagens dos componentes mestre e escravos sao atualizadas para cada
   pixel resultante da convolucao, apresentando de forma didatica a execucao
   paralela. Finalizado o processo de convolucao em todas as aplicacoes (mestre e
   escravas), os dados resultantes sao transmitidos para a aplicacao mestre, a qual
   monta essas tiras, e exibe o resultado da convolucao com a mascara Sobel.
   Fig. - 6.20 - Exemplo de uma aplicacao paralela utilizando os componentes
   TSobelPar .
   Uma variacao dos componentes TSobelPar sao os componentes TMaskPar,
   que possuem um funcionamento semelhante, com a diferenca de que a mascara a
   ser convoluida na imagem e determinada atraves de programacao no componente
   mestre ( TMaskParM). A matriz (5x5), que contem a mascara personalizada e
   transmitida para as aplicacoes escravas juntamente com as tiras da imagem,
   permitindo que estas realizem a convolucao.
   Este experimento teve carater didatico, uma vez que permitiu ao usuario a
   visualizacao da execucao paralela, apresentando em cada uma das maquinas o
   processamento grafico, perdendo com isso desempenho.
   246
   CVMP
   6.11 - PERSPECTIVAS CVMP
   O conjunto de ferramentas CVMP pode ser considerado como uma camada
   adicional aos protocolos de comunicacao, memoria compartilhada ou redes. Suas
PA principais vantagens em relacao a outras metodologias que possibilitam a
   computacao paralela, tais como o PVM e MPI, estao na simplicidade de utilizacao,
   programacao visual, encapsulamento, reutilizacao de codigo e programacao
   orientada a objetos.
   Embora o CVMP, como abordamos neste capitulo, possa estar relacionado
   diretamente com os protocolos de comunicacao e suas primitivas (TCP/IP, NetBeui
   e Socket), nada impede que o CVMP seja desenvolvido sobre outras metodologias,
   redirecionando os metodos de comunicacao para as primitivas de outras tecnicas.
   Acreditamos que essa caracteristica aumente o potencial do CVMP, ficando como
   sugestao para desenvolvimentos futuros versoes do CVMP sobre PVM ou MPI.
   Deste modo, permitir-se-a o desenvolvimento de aplicacoes mistas que podem,
   alem de se beneficiar com as amplas bases destas tecnologias, tambem prover a
   estas plataformas seus beneficios.
   Uma vez que tanto o MPI quanto o PVM sao voltados para o mundo Unix, e
   o CVMP para o mundo Windows, e necessario aguardar o lancamento do Kylix
   [Kylix], ambiente compativel com Delphi versao Linux, previsto para o segundo
   semestre de 2000, justificando assim a portabilidade do CVMP. Acreditamos que a
   versao CVMP para UNIX, venha trazer uma grande facilidade de desenvolvimento
   paralelo para essa plataforma, possibilitando ainda o desenvolvimento de sistemas
   paralelos heterogeneos (plataforma UNIX e Windows).
   Outro aspecto interessante do CVMP e a sua versatilidade, possuindo
   inumeras possibilidades para o desenvolvimento de arquiteturas paralelas, uma vez
   que apresenta um codigo simples e enxuto (componente CVMP basico com cerca
   de 980 linhas) e pode ser baseado em qualquer mecanismo de comunicacao. Um
   bom exemplo de uma arquitetura nao convencional que pode ser desenvolvida
   atraves de CVMP sao as maquinas MIMD distribuidas baseadas em interface SCSI.
   Uma vez que a tecnologia de redes vem constituindo cada vez mais um gargalo,
   nao conseguindo acompanhar a performance dos processadores atuais, as
   arquiteturas baseadas em interface SCSI apresentam-se como uma nova
   possibilidade de arquitetura paralela [Henry et al., 1998] [Mattson & Henry, 1998]
   [Phil ips, 1998].
   247
   CAPITULO 6
   248
   CAPITULO
   7
   ESTUDOS DE ALGORITMOS
   PARALELOS PARA VISAO E
   SUA IMPLEMENTACAO COM
   CVMP
   "Is computer design driven by problems looking for solutions, or by solutions looking
   for problems ? The anwer is, by both."
   Almasi & Gottlieb
   249
   CAPITULO 7
   250
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   CAPITULO 7 - ESTUDOS DE
   ALGORITMOS PARALELOS PARA VISAO E
   SUA IMPLEMENTACAO COM CVMP
PA 7.1 - INTRODUCAO
   Neste capitulo realizaremos um estudo sobre as estrategias e arquiteturas
   de implementacao paralela de alguns algoritmos de visao computacional e
   processamento de imagens. Iniciaremos o estudo com operadores locais, seguindo
   pelo tratamento individual dos canais cromaticos em imagens, o paralelismo nos
   algoritmos de transformadas de Fourier 2D e continuando com estrategias de
   paralelismo da transformada de Hough e restauracao de imagens baseados em
   campos aleatorios de Markov. Finalmente, encerramos o capitulo com a
   paralelizacao do calculo da dimensao fractal de Minkowski. Todos os metodos
   foram implementados com as ferramentas CVMP, de forma que podem ser
   utilizados diretamente em outras aplicacoes ou mesmo convertidos para
   componentes personalizados, de modo a complementar o CVMP.
   7.2 - OPERADORES LOCAIS
   Definimos como operadores locais os algoritmos que atuam isoladamente
   em um conjunto local de pixels, de modo que nao ocorra dependencia de dados
   com os outros componentes da imagem. Assim, algoritmos locais podem estar
   baseados em transformacoes envolvendo um unico pixel isoladamente ou em
   conjuntos de pixels locais.
   As transformacoes em conjuntos de pixels locais sao conhecidas como
   operadores de vizinhanca, que se caracterizam pela convolucao de filtros em
   dominio espacial [Gonzalez & Woods, 1993]. Estas tecnicas sao largamente
   utilizadas nos algoritmos de processamento de imagens de baixo nivel, atraves de
   filtros de borramento (passa baixa, filtragem mediana, etc.), filtros de nitidez (passa
   alta) e detectores de borda, que incluem os filtros diferenciais em geral (Sobel,
   Robert e Laplaciano da Gaussiana entre outros). Estas transformacoes podem ser
   251
   CAPITULO 7
   expressas como
   g( x, y) = T[ f ( x, y)]
   (7.1)
   onde f(x,y) e a imagem de entrada, g(x,y) e a imagem resultante do processamento
   e T e o operador de f, definido atraves de operacoes sobre a vizinhanca dos pixels
   de (x,y), que pode ser definida como uma matriz cujo elemento central e a
   coordenada (x,y), conforme podemos observar a seguir:
   ( x
   ,
   1 y
   )
   1
   ( x, y
   )
   1
   ( x + ,
   1 y
   )
   1
   ( x
   ,
   1 y)
   ( x, y)
PA ( x + ,
   1 y)
   (7.2)
   ( x
   ,
   1 y + )
   1
   ( x, y + )
   1
   ( x + ,
   1 y + )
   1
   As transformacoes envolvendo um unico pixel podem ser expressas pela
   equacao
   s = T ( r)
   (7.3)
   onde s e r sao as variaveis correspondentes aos valores de nivel de cinza das
   coordenadas de g(x,y) e f(x,y) respectivamente, e T representa a operacao a ser realizada na variavel r. Por exemplo, sendo T um operador de limiar ou binarizacao,
   a transformacao realizada por T e uma condicional, onde sendo r maior que um
   limiar, entao s sera igual a 1 e caso contrario igual a 0. As operacoes locais
   envolvendo um unico pixel, alem de serem utilizadas para a binarizacao de
   imagens, sao tambem empregadas para variacoes da intensidade de brilho, para
   alteracoes de coloracao de uma imagem [Gonzalez & Woods, 1993], ou ainda em
   conjunto com analises de histograma [Gonzalez & Woods, 1993]. Devido a pouca
   demanda computacional requerida pelos metodos dessa classe (apenas uma
   operacao por pixel da imagem), nao vamos discutir suas possibilidades de
   paralelizacao.
   Entretanto, os metodos de convolucao no dominio do espaco, por
   envolverem diversas operacoes aritmeticas para cada pixel da imagem requerem
   poder computacional e consequentemente tempo de execucao suficiente para
   requererem solucoes paralelas. Devemos lembrar que a demanda computacional
   aumenta proporcionalmente com a dimensao da mascara a ser convoluida.
   252
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   (a)
   (b)
   I
   II
   III
   IV
   V
   Fig. - 7.1 - Estrategia de paralelismo para operadores locais, para quatro
   unidades de processamento. (a) Divisao da imagem em faixas, (b) divisao da
   imagem em quadrilateros. As etapas I, II, III, IV e V representam
   respectivamente: a imagem original, divisao da imagem e sua distribuicao,
   processamento de cada parte da imagem em uma unidade de processamento
   diferente, reconstrucao dos resultados e resultado do processamento.
   Basicamente a estrategia de paralelismo para os algoritmos operadores
   locais consiste na divisao da imagem em partes e em sua distribuicao, de forma
   que cada maquina ou processador fique responsavel pelo processamento em um
PA pedaco da imagem dividida, e finalmente da uniao dos resultados. A Figura 7.1
   contem um diagrama que ilustra essa estrategia de paralelismo com duas
   abordagens diferentes de divisao de imagem, formuladas para arquiteturas
   contendo quatro unidades de processamento. A primeira (a), consiste na divisao da
   imagem em tiras, que sao distribuidas para as unidades de processamento e apos
   serem processadas o resultado e reconstituido, na segunda (b), a imagem e
   dividida em quadrilateros. A imagem pode virtualmente ser dividida em qualquer
   formato, entretanto essas duas maneiras apresentam os mais obvios e simples de
   implementar.
   Em alguns sistemas paralelos (ex: multiprocessadores), a fragmentacao da
   253
   CAPITULO 7
   imagem num numero muito maior de porcoes (alta granularidade) apresenta
   algumas vantagens tanto em desempenho quanto em balanceamento de cargas.
   No entanto, devido a grande latencia da comunicacao via rede (computacao
   distribuida), optamos por estrategias que utilizem pacotes com grande quantidade
   de dados (baixa granularidade), a fim de otimizar as transmissoes de dados. Esta
   abordagem foi utilizada nao somente nesta secao como nas demais
   implementacoes ao longo de toda a tese.
   (a)
   (b)
   Fig. - 7.2 - Detalhes da divisao imagem resolvendo a dependencia de dados
   para uma mascara 3x3. (a) Imagem original, (b) fracoes da imagem com a
   vizinhanca dos elementos das linhas divisorias (em cinza).
   O particionamento da imagem, deve levar em conta a dependencia de
   dados ocasionada pelo filtro, uma vez que a manipulacao de um pixel envolve
   computacoes referentes a sua vizinhanca. Seja qual for a abordagem de divisao
   considerada, deve-se adotar uma metodologia a fim de embutir nas porcoes
   distribuidas a vizinhanca necessaria para o calculo dos elementos das linhas
   divisorias. Na Figura 7.2 temos um exemplo que ilustra detalhes do processo de
   divisao, onde considera-se que o filtro possui dimensao de 3x3. Como podemos
   observar em (b), juntamente com a porcao da imagem a ser dividida (de cor branca)
   e acrescentada a vizinhanca dos elementos anexos as linhas de divisao, de modo a
   solucionar a dependencia de dados no calculo desses elementos.
   A implementacao do algoritmo, atraves do CVMP, pode ser realizada de
   inumeras maneiras e envolvendo diferentes numeros de maquinas ou unidades de
   254
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   processamento. Nossa opcao foi uma versao da estrategia de processor farm, onde
   ao inves de um processo supervisor, temos um processo mestre, que alem de
   distribuir as tarefas para os escravos tambem realiza processamento. Em nossa
   implementacao utilizamos o componente CVMP basico e o CVMP launcher para
   disparar os processos escravos. A Figura 7.3 mostra o arranjo esquematico dos
   processos, objetos CVMP e Canais Virtuais.
   Escravo
   CVMP
   Canal Virtual
   Mestre
   Fig. - 7.3 - Variacao da arquitetura processor farm adotada para paralelismo
   do algoritmo dos operadores locais, onde o mestre alem de distribuir as
PA tarefas tambem processa uma porcao da imagem.
   Na Figura 7.4 temos um diagrama que ilustra as trocas de mensagens num
   sistema composto por 4 maquinas. O mestre, representado por M, particiona a
   imagem e envia as partes para os escravos ( E). A seguir ocorre o processamento
   paralelo de cada parte da imagem, cujo resultado retorna ao mestre, finalizando o
   algoritmo. Podemos observar atraves dos blocos de processamento que este
   exemplo apresenta balanceamento de carga satisfatoria, uma vez que as tarefas
   terminam quase simultaneamente. Isso se deve ao fato do sistema possuir uma
   distribuicao uniforme de poder computacional. O balanceamento e automatico
   quando as unidades de processamento forem uniformes. Entretanto, em sistemas
   heterogeneos, ou seja, com unidades de processamento com diferentes
   desempenhos, o balanceamento pode ser realizado atraves da divisao da imagem,
   onde o tamanho da porcao de imagem a ser processado deve ser proporcional ao
   poder computacional de cada unidade de processamento.
   Podemos observar ainda no diagrama da Figura 7.4 tres bolhas, devido ao
   algoritmo esperar o envio de todas as fracoes da imagem para iniciar o
   processamento. Essas bolhas podem ser eliminadas, tornando o sistema mais
   255
   CAPITULO 7
   eficiente, se imediatamente apos o envio das porcoes de imagem o mestre solicitar
   aos escravos o processamento. No entanto, embora essa tatica permita um
   desempenho maior, acarreta em uma necessidade de redimensionamento das
   fracoes no processo de particao da imagem, uma vez que devem ser considerados
   tambem os tempos referentes ao envio das porcoes da imagem no calculo da
   divisao da imagem.
   Vamos a seguir apresentar os resultados de um experimento realizado
   mediante a implementacao dessa arquitetura, atraves dos quais poderemos
   analisar o comportamento do algoritmo paralelo, assim como sua performance
   frente ao seu analogo sequencial. Para o experimento, utilizamos uma rede
   composta por 4 computadores, interligados com placas ethernet NE2000 de 10
   Mb/s. Implementamos a arquitetura apresentada na Figura 7.4, com divisao igual
   dos componentes da imagem. Deste modo, para que nao houvesse
   desbalanceamento de carga no sistema, as maquinas deveriam possuir
   performance homogenea. Para isso configuramos e ajustamos 4 maquinas para
   que tivessem uma performance equivalente a um microprocessador AMD K6 II com
   frequencia interna de 375 MHz, caracterizando assim os computadores da rede
   com uma performance homogenea.
   Fig. - 7.4 - Diagrama ilustrando as trocas de mensagem e o balanceamento de
   carga do sistema.
   No experimento medimos o tempo de execucao do algoritmo paralelo e
   sequencial para quatro tamanhos de imagens diferentes (250x250, 500x500,
   750x750 e 1000x1000 pixels), sendo que para cada uma das imagens foram
   aplicadas operadores com mascaras de diferentes tamanhos (3x3, 5x5, 9x9, 15x15,
   31x31, 51x51, 71x71, 85x85 e 101x101 elementos). Utilizamos no experimento um
   dos operadores locais mais basicos que caracteriza uma filtragem passa baixa
   256
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   [Gonzalez & Woods, 1993], conforme mostrado na Figura 7.5 atraves de um
   exemplo com dimensao 3x3, consiste no somatorio dos elementos da mascara
   fracionada pelo numero de componentes do filtro.
PA 1
   1
   1
   1
   X
   1
   1
   1
   9
   1
   1
   1
   Fig. - 7.5 - Exemplo de filtro passa baixa com 3x3 elementos.
   Imagem 250x250
   Imagem 500x500
   Imagem 750x750
   Imagem 1000x1000
   Fig. - 7.6 - Comparacao entre o tempo de execucao do algoritmo paralelo e
   sequencial.
   A Figura 7.6 apresenta quatro graficos com os resultados do experimento,
   sendo que cada um deles e respectivo a um tamanho de imagem (250x250,
   500x500, 750x750 e 1000x1000 pixels). Os graficos mostram o tempo, dado em
   257
   CAPITULO 7
   segundos no eixo y, e o numero de elementos do filtro no eixo x.
   4.0
   Imagem 250x250
   4.0
   Imagem 500x500
   3.5
   3.5
   3.0
   3.0
   2.5
   Up
   2.5
   Up
   d
   d
   2.0
   2.0
   ee
   ee
   1.5
   Sp
   1.5
   Sp
   1.0
   1.0
   0.5
PA 0.5
   0.0
   0.0
   3x3
   5x5
   9x9
   15x15 31x31 51x51 71x71 85x85 101x101
   3x3
   5x5
   9x9
   15x15 31x31 51x51 71x71 85x85 101x101
   mascara
   mascara
   4.0
   Imagem 750x750
   4.0
   Imagem 1000x1000
   3.5
   3.5
   3.0
   3.0
   2.5
   Up
   2.5
   Up
   d
   d
   2.0
   2.0
   ee
   ee
   1.5
   Sp
   1.5
   Sp
   1.0
   1.0
   0.5
   0.5
   0.0
   0.0
   3x3
   5x5
   9x9
   15x15 31x31 51x51 71x71 85x85 101x101
   3x3
   5x5
   9x9 15x15 31x31 51x51 71x71 85x85 101x101
   mascara
   mascara
PA Fig. - 7.7 - Desempenho dos algoritmos paralelos.
   A performance da implementacao paralela frente a sequencial aumenta a
   medida que caminhamos no eixo x. Para filtros com poucos elementos, tais como
   3x3 e 5x5, o desempenho da versao paralela chega a ser inferior, conforme
   podemos observar na ampliacao do detalhe do grafico referente a imagem de
   750x750 pixel. Para analisarmos o comportamento da performance, utilizamos da
   medida de Speed Up ou medida de desempenho, dada pela razao entre o tempo de
   execucao sequencial e o tempo de execucao paralelo. Na Figura 7.7 encontramos
   os graficos de desempenho, correspondentes aos da Figura 7.6. Como podemos
   verificar, um resultado interessante e a pequena variacao de desempenho frente a
   dimensao da imagem. Embora a imagem 250x250 possua um desempenho medio
   inferior, as demais dimensoes possuem caracteristicas proximas, com um aumento
   de performance muito pequeno para as imagens de tamanho maior, indicando que
   o fator fundamental no desempenho e o tamanho do filtro. A partir do filtro de
   15x15, a implementacao paralela comeca a ser justificavel, atingindo um
   258
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   desempenho aproximado, que varia de 1,75 vezes (imagem 250x250) a 2,25 vezes
   superior (imagem 1000x1000). Para filtros maiores, o algoritmo paralelo
   implementado com 4 maquinas, atinge sua performance maxima, aproximadamente
   3,5 vezes superior a versao sequencial.
   A razao da baixa performance do algoritmo paralelo para os filtros com
   poucos elementos pode ser compreendida atraves da relacao entre o tempo de
   processamento e o tempo de transferencia dos dados. Observando a Figura 7.4
   podemos verificar que a base computacional do algoritmo pode ser dividida em
   duas partes: transmissao dos dados e processamento do operador local. Na
   transmissao de dados, temos duas etapas: a distribuicao das partes da imagem a
   serem processadas e a transmissao do resultado para a maquina mestra. A medida
   que os filtros se tornam maiores, a demanda computacional para o processamento
   do operador local aumenta, enquanto que a demanda requerida pela transmissao
   de dados continua a mesma. Como os dados envolvidos na transmissao sao
   consideraveis, essa etapa consome grande recurso computacional, especialmente
   em sistemas distribuidos, que possuem uma baixa banda de transferencia. Para
   justificar o tempo desperdicado na transmissao de dados, os recursos
   computacionais gastos com a processamento do operador local precisam ser
   maiores que estes.
   100%
   80%
   60%
   40%
   20%
   0%
   3x3
   5x5
   9x9 15x15 31x31 51x51 71x71 85x85 101x101
   mascara
   Fig. - 7.8 - Comparacao entre a porcentagem de tempo consumido entre o
   processamento e a transmissao de dados (imagem de 500x500).
   O grafico da Figura 7.8 apresenta as porcentagens de tempo de execucao
   259
PA CAPITULO 7
   em relacao ao processamento do operador local e a transmissao de dados.
   Conforme podemos observar para as mascaras com poucos elementos, o
   percentual de demanda computacional requerido pelo processamento do operador
   local e pequeno, nao justificando a implementacao paralela. No entanto a medida
   que o poder computacional exigido pelo processamento aumenta, o percentual da
   transmissao de dados diminui, aumentando a performance do sistema.
   4
   3
   Upd 2ee
   Sp
   1
   10 Mbits/s
   0
   3x3
   5x5
   9x9 15x15 31x31 51x51 71x71 85x85 101x101
   100 Mbits/s
   mascara
   Fig. - 7.9 - Comparacao entre a performance do sistema em rede de 10Mbits/s
   (ethernet) e 100Mbits/s (fast ethernet).
   Conforme vamos observar no decorrer desse capitulo, o gargalo da grande
   maioria dos sistemas distribuidos para processamento de imagens e visao se
   encontra na transmissao de dados, uma vez que o processamento dessas areas
   esta relacionado com imagens. Deste modo, uma maneira de aumentar a
   performance dos sistemas e utilizar redes mais rapidas ou sistemas de memoria
   compartilhada.
   Na Figura 7.9 temos a comparacao entre o nosso experimento executado
   em uma rede de 10 e 100 Mbits/s (imagem 500x500). Uma rede mais veloz fez com
   que a performance dos filtros menores (3x3, 5x5, 9x9 e 15x15) aumentasse
   consideravelmente, permanecendo entretanto com desempenhos proximos nos
   filtros de dimensao maior. Comparando este resultado com o grafico da Figura 7.8,
   podemos justificar essa diferenca de aumento de performance, ja que a medida que
   os filtros aumentam, torna-se menor o gargalo constituido pela transmissao de
   dados. Diferente do convencional, na arquitetura apresentada nesta secao, as
   aplicacoes que envolvem grandes mascaras nao justificam a utilizacao de redes de
   alto desempenho.
   260
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   7.3 - CANAIS CROMATICOS
   A cor e percebida pelos primatas atraves da composicao da percepcao de
   tres diferentes fotorreceptores, que possuem absorcoes maximas de onda em
   diferentes faixas do espectro (vermelho, verde e azul). Nos sistemas
   computacionais, a cor e igualmente formada pela composicao de contribuicoes das
   diferentes faixas do espectro. No entanto, ao inves de funcoes continuas como
   ocorre nos sistemas de visao natural, as representacoes numericas da cor sao
   quantizadas atraves de funcoes discretas que, em geral, possuem 256 valores.
   Existem diversas representacoes cromaticas em sistemas computacionais,
   cujo principio baseia-se na formacao de um espaco de cores, que quantificam os
   estimulos cromaticos. Dentre os espacos de cores, existem os que combinam matiz
PA com brilho, iluminacao e contraste, ao inves de combinar as cores diretamente,
   como e o caso dos sistemas YIQ, YUV, HSI e HSV entre outros [Moreira, 1999]
   [Pratt, 1984]. As representacoes mais comuns e mais utilizadas sao aquelas que,
   assim como no modelo biologico, combinam as faixas do espectro. Dentro dessa
   classe temos o sistema RGB, o mais difundido de todos, que e analogo ao sistema
   tricromatico biologico, sendo formado da combinacao das matizes vermelho, verde
   e azul. Embora a grande maioria das representacoes sejam compostas por tres
   canais, existem tambem aquelas que nao seguem esse padrao, como e o caso do
   sistema CMYK, sistema de representacao cromatica baseada na absorcao e
   combinacao de tintas na formacao de cores, largamente utilizado em aplicacoes
   envolvendo impressoes graficas, cuja combinacao e formada com matizes azul
   claro - Cyan, vermelho claro - Margenta, amarelo e preto.
   Os canais de combinacao dos sistemas de representacoes cromaticos
   podem ser considerados como planos ou imagens independentes. Tomemos por
   exemplo o sistema RGB, no qual as imagens cromaticas sao formadas por tres
   imagens em niveis de cinza, representando cada um dos planos de contribuicao
   (azul, verde e vermelho), de forma que cada um dos planos possa ser processado
   com as tecnicas convencionais de processamento de imagens em tons de cinza.
   Uma vez que cada plano pode conter informacoes diferenciadas, relativas as
   variadas absorcoes de espectro dos componentes da imagem, o processamento
   individual de cada plano possibilita a revelacao de detalhes obtidos apenas na
   analise de um dos componentes.
   Do ponto de vista do paralelismo, os planos podem ser tratados de modo
   261
   CAPITULO 7
   isolado uma vez que nao existe dependencia de dados. Isto simplifica a
   implementacao de algoritmos cromaticos que utilizam essa abordagem. Vamos
   apresentar como exemplo do paralelismo explorando os canais cromaticos um
   detector de retas em imagens cromaticas, cujo objetivo e mais didatico do que
   pratico. Partindo da ideia que informacoes diferentes podem estar concentradas
   nos diferentes planos da imagem cromatica, esse algoritmo explora os planos
   individualmente na expectativa de encontrar retas nao detectaveis na versao
   monocromatica da imagem.
   Para cada plano cromatico o algoritmo efetua a extracao das bordas da
   imagem atraves do popular filtro Sobel [Sobel, 1970], e no resultado dessa
   operacao e realizada a transformada de Hough com parametrizacao normal,
   responsavel pela deteccao das retas.
   Implementamos o sistema distribuido utilizando 3 maquinas conectadas por
   rede, uma mestra e duas escravas, conforme apresentado na Figura 7.10. A
   maquina mestra e responsavel pela aquisicao da imagem cromatica e pela divisao
   dos 3 planos e a distribuicao de dois destes para as maquinas escravas. Apos a
   distribuicao dos planos e realizado o processamento dos algoritmos Sobel e Hough,
   simultaneamente nas tres maquinas. Finalmente o resultado e retornado a maquina
   mestra, onde pode ser combinado com operadores logicos.
   Fig. - 7.10 - Diagrama ilustrando as trocas de mensagem e o balanceamento
   de carga do sistema. M - maquina mestra; S1 e S2 - maquinas escravas.
   Para compararmos a performance do sistema em situacoes distintas,
   implementamos tres configuracoes diferentes: sequencial, paralelo com duas
   maquinas e paralelo com tres maquinas, conforme mostra a Figura 7.11. O
   experimento foi realizado em tres redes homogeneas de computadores com tres
PA maquinas, incluindo: uma formada por computadores com processadores 486dx4
   com frequencia interna de 100 MHz, outra com processadores Pentium MMX de
   225 MHz e a ultima com processadores AMD K6 II de 375 MHz. Todas as redes
   262
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   foram implementadas usando placas ethernet NE2000 de 10Mbits/s. Deste modo
   podemos comparar o desempenho do sistema paralelo versus sua versao
   sequencial, frente a sistemas com diferentes performances, permitindo assim,
   avalia-lo perante a evolucao dos microprocessadores.
   (a)
   (b)
   (c)
   Aq - Aquisicao da imagem
   GC - Canal Verde
   CS - Divisao dos Canais
   RC - Canal Vermelho
   S - Processamento Sobel
   BC - Canal Azul
   H - Processamento Hough
   GE - Resultado Verde
   ER - Receber Resultado
   RE - Resultado Vermelho
   LC - Combinacao Logica
   BE - Resultado Azul
   Fig. - 7.11 - Configuracoes do sistema: (a) sequencial, (b) paralelo com 2
   maquinas e (c) paralelo com 3 maquinas.
   A Figura 7.12 (a) apresenta uma comparacao entre a performance para a
   implementacao paralela e a versao sequencial. Nela e apresentado um grafico do
   tempo de execucao de cada uma das situacoes contra o numero de pixels da
   imagem processada. Na Figura 7.12 (b) e apresentado um grafico do tempo de
   execucao em funcao do numero de maquinas utilizadas, parametrizado pelo
   tamanho da imagem dado em pixels. O desempenho ou speed-up do sistema e
   aproximadamente uniforme para os diferentes tamanhos de imagem, ficando em
   263
   CAPITULO 7
   torno de 2,5 vezes superior, para o sistema rodando em tres maquinas e 1,4 vezes
   superior para duas maquinas, conforme podemos verificar na Figura 7.13 (a).
   sequencial
   (s)
   (s)
   po
   po
   m
   m
   te
   te
   paralelo
   (a)
   (b)
   Fig. 7.12 - Tempo de execucao (maquinas 486dx4-100): (a) Em relacao ao
PA numero de pixels, comparacao entre as versoes sequencial e paralela com 3
   maquinas e (b) Em relacao ao numero de processadores (P) parametrizado
   pelo numero de pixels.
   Os resultados do experimento realizado em redes homogeneas com
   diferentes microprocessadores apresentam a queda de performance da versao
   paralela frente a sequencial. Isso pode ser observado atraves speed-up ou medida
   de desempenho das tres diferentes situacoes, atraves dos graficos da Figura 7.13,
   (a) 486dx4 100MHz, (b) Pentium MMX 225MHz e (c) AMD K6-II 375MHz. Enquanto
   os microprocessadores apresentam performance diferentes, a taxa de transferencia
   da rede continua a mesma, caracterizando-a como gargalo para os processadores
   mais velozes. Podemos observar na Figura 7.13 (b e c) uma taxa de crescimento
   de performance a medida que o tamanho da imagem aumenta. Assim, embora esta
   arquitetura paralela tenha se tornado inviavel para as imagens utilizadas no
   experimento, deve atingir uma performance aceitavel para imagens de grandes
   dimensoes, ja que nessa situacao a carga de processamento tornara maior que a
   de transferencia. Observamos ainda que a performance do sistema em 486dx4
   permanece constante para os diferentes tamanhos de imagem, indicando uma
   demanda superior para carga de processamento frente a transferencia dos dados
   atingindo equilibrio.
   264
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   3.0
   486dx4-100MHz
   3 maquinas
   2.5
   p
   2.0
   (a)
   eed USp
   1.5
   2 maquinas
   1.0
   5000
   10000
   15000
   20000
   25000
   30000
   pixels
   Pentium 225MHz
   K6-II 375MHz
   2.30
   1.55
   2.25
   1.50
   1.45
   2.20
   p
   p 1.40
   2.15
PA eed U
   eed U
   Sp
   Sp 1.35
   2.10
   1.30
   (b)
   (c)
   2.05
   1.25
   2.00
   5000
   10000
   15000
   20000
   25000
   30000
   5000
   10000
   15000
   20000
   25000
   30000
   pixels
   pixels
   Fig. 7.13 - Graficos de desempenho em funcao do numero do tamanho da
   imagem. As redes sao homogeneas e sao baseadas em ethernet NE2000 com
   taxa de 10Mbits/s. (a) rede formada por maquinas 486dx4-100MHz, (b) Pentium
   225MHz e (c) K6II 375MHz.
   A Figura 14 apresenta um diagrama ilustrativo, que compara os tempos de
   execucao das versoes paralelas (3 maquinas) em cada uma das plataformas em
   que foi realizado o experimento. Atraves dele podemos observar a diminuicao
   crescente do tempo de execucao frente ao tempo de transferencia de dados,
   justificando assim a razao pelo decrescimo de desempenho do sistema em
   plataformas com microprocessadores mais velozes, caracterizando a troca de
   mensagens como o gargalo do sistema. Como alternativas para eliminar o gargalo
   podemos citar: (i) Utilizacao de redes mais velozes. O sistema foi implementado
   utilizando rede ethernet NE2000 com taxa de transferencia de 10 Mbits/s, se a rede
   for substituida por uma solucao com taxa de transferencia superior, o tempo de
   transferencia pode ser reduzido diminuindo o gargalo. (i ) Utilizar imagens com
   265
   CAPITULO 7
   dimensoes bem maiores que as empregadas no experimento, aumentando o tempo
   proporcional de processamento (caixa preta da Figura 7.14) frente ao tempo de
   transferencia (caixa com barras diagonais, Figura 7.14). (i i) Implementar o sistema
   com arquitetura de memoria compartilhada. Essa solucao possibilita uma grande
   reducao do gargalo, devido a performance superior de transferencia de dados entre
   os processos. Uma das desvantagens de sua adocao, no entanto, e a limitacao de
   processadores nos modelos comerciais. Atualmente os sistemas de hardware
   (tecnologia PC) possuem um numero limitado de processadores, sendo indicados,
PA do ponto de vista da computacao cientifica, para solucoes com poucos processos
   paralelos, como e o caso especial do sistema apresentado nesta secao.
   K6-2
   Envia dados
   375 MHz
   Sobel + Hough
   Pentium
   Recebe dados
   225 MHz
   486 dx4
   100 MHz
   0
   20
   40
   60
   80
   Tempo (s)
   Fig. 7.14 - Comparacao entre o tempo de execucao do experimento em tres
   diferentes sistemas homogeneos, em uma imagem de 30000 pixels.
   7.4 - TRANSFORMADA DE FOURIER
   Nesta secao vamos comentar a implementacao paralela da transformada de
   Fourier rapida (FFT) de duas dimensoes baseada no CVMP. A transformada de
   Fourier dispensa apresentacoes. Ela tem sido utilizada ha muitos anos em
   processamento de sinais e imagens, tanto na teoria quanto nas aplicacoes,
   podendo ser caracterizada como uma das bases classicas do processamento de
   sinais e imagens.
   A transformada de Fourier e sua inversa em sua forma analitica, sao dadas
   pelas equacoes 7.4 e 7.5 respectivamente, enquanto que sua forma discreta podem
   ser encontradas nas equacoes 7.6 e 7.7. Observando a transformada de Fourier
   discreta ( TFD - Transformada de Fourier Discreta), podemos avaliar a grande carga
   computacional requerida para seu processamento, devido ao grande numero de
   266
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   multiplicacoes e exponenciacoes. Para diminuir essa enorme carga foi elaborada a
   transformada de Fourier rapida (FFT - Fast Fourier Transform), um algoritmo
   baseado em alguns artificios matematicos capaz de diminuir o numero de
   operacoes e agilizar o processamento [Brigham, 1988]. Embora o resultado da FFT
   seja uma aproximacao da transformada de Fourier, e tambem seja limitada a
   vetores (ou sinais), cuja dimensao seja geralmente uma potencia de 2, sua grande
   performance justifica sua utilizacao.
   F u
   ( ) =
   f ( x) exp[ j 2 ux dx
   ]
   (7.4)
   f ( x) =
   F u
   ( ) exp[ j 2 ux du
   ]
   (7.5)
PA N 1
   1
   F( u) =
   f ( x)exp[ j 2 ux / N]
   (7.6)
   N x=0
   N 1
   f ( x) =
   F( u)exp[ j 2 ux / N ]
   (7.7)
   x=0
   7.4.1 - TRANSFORMADA DE FOURIER 2D
   A transformada de Fourier em duas dimensoes e dada pela equacao:
   F u
   ( , v) =
   f ( x, y)exp[ j 2 ux
   (
   + vy dxdy
   )]
   (7.8)
   que, quando transposta para sua forma discreta (TFD - Transformada de Fourier
   Discreta) resulta:
   N
   M
   1
   F u
   ( , v) =
   ux
   f ( x, y) exp
   j 2
   + vy
   (7.9)
   MN x=0 y=0
   N
   M
   que pode ser escrita como:
   267
   CAPITULO 7
   M
   N
   1
   1
   F u
   ( , v) =
   ux
   vy
   f ( x, y) exp
   j 2
   exp
   j 2
PA (7.10)
   M y=0 N x=0
   N
   M
   possibilitando a separacao de um dos nucleos da equacao resultando em:
   M
   1
   F u
   ( , v) =
   vy
   F u
   ( , y) exp
   j 2
   (7.11)
   M y=0
   M
   Esse resultado demonstra que podemos obter a TFD 2D a partir da TFD 1D,
   valendo o mesmo para a transformada discreta inversa, que basicamente possui
   como diferenca apenas o sinal do expoente da exponencial. Para isso, deve-se
   calcular a TFD 1D de cada uma das linhas da imagem f(x,y), obtendo F(x,v) e
   depois calcular a TFD 1D de todas as colunas de F(x,v), obtendo finalmente F(u,v)
   [Brigham, 1988] [Castleman, 1996] [Gonzalez & Woods, 1993] [Oppenheim &
   Schafer, 1975]. A decomposicao da TFD 2D em 1D pode ser expandida tambem
   para a FFT, neste caso, ao inves de calcular a TFD 1D de cada passo deve ser
   calculada a FFT [Brigham, 1988].
   Classicamente a implementacao do algoritmo paralelo da FFT 2D consiste
   nas combinacoes horizontais e verticais da FFT 1D, conforme apresentamos
   anteriormente. A Figura 7.15 apresenta um diagrama ilustrativo da implementacao
   realizada a partir do CVMP, nela o mestre divide a imagem horizontalmente e envia
   cada uma das partes para os processos escravos, ficando com uma parte. Com
   isso, cada um dos processos realiza a FFT 1D de cada uma das linhas horizontais
   da sua porcao de imagem e, ao final deste procedimento transmitem a parte real e
   imaginaria do resultado para o mestre, que agora, divide os resultados
   verticalmente e distribui-os novamente. E entao disparado o processamento
   vertical, em cada uma das maquinas, que consiste na FFT 1D das linhas verticais
   das matrizes complexas (parte real e imaginaria). Finalmente os resultados (que
   consistem em uma matriz real e uma imaginaria) sao enviados para o mestre, onde
   sao combinados formando as matrizes real e imaginaria resultantes da FFT 2D da
   imagem. Esta e outras estrategias de paralelismo da FFT 2D podem ser
   encontradas em detalhes em [Chu & George, 1999] e [Morante et al., 1999].
   268
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   Linhas horizontais
   Linhas verticais
   Resultado real
   Resultados
   e imaginario
   horizontais
   Imagem
   (horizontal)
PA divididos
   FFT
   original
   verticalmente
   resultado
   FFT 1D
   FFT 1D
   algoritmo
   1
   1
   algoritmo
   2
   2
   1 2 3 4
   1 2 3 4
   3
   3
   4
   4
   Escravo A
   Escravo A
   2
   2
   2
   2
   Mestre
   3
   Escravo B
   3
   Mestre
   Mestre
   3
   Escravo B
   3
   Mestre
   4
   4
   4
   4
   Escravo C
   Escravo C
   1
   Mestre
   1
   1
   Mestre
   1
   Fig. 7.15 - Estrategia de paralelismo da FFT 2D. Exemplo para 4 processos
   (maquinas ou processadores).
   Como podemos verificar, o fluxo de dados e bastante intenso,
PA especialmente devido a combinacao dos resultados do processamento horizontal e
   a combinacao para o processamento vertical. Entretanto, alem da intensidade de
   trocas da estrategia de paralelizacao, devido a natureza dos dados, o volume
   transmitido aumenta demasiadamente, tornando-se um enorme gargalo no sistema.
   O aumento do volume dos dados ocorre devida a duas circunstancias: (i) alteracao
   de tipo de dado e (ii) as matrizes da transformada sao complexas (uma matriz real e
   uma matriz imaginaria).
   No primeiro fator, caso estejamos aplicando a transformada de Fourier a
   uma imagem, e sendo a imagem de 256 niveis de cinza (usualmente utilizada em
   processamento de imagens), cada elemento da matriz imagem e constituida por um
   byte. Vamos tomar como exemplo uma imagem de 1024x1024 pixels com 256
   niveis de cinza. Neste caso, o espaco de memoria ocupado para armazenar a
   imagem e de 1 megabyte, uma vez que cada elemento da matriz imagem, e
   constituido por um byte (256 = 28). A quantidade de memoria e determinada pela
   area da imagem em pixels. Entretanto, o algoritmo da transformada oferece maior
   precisao em ponto flutuante. A Tabela 7.1 apresenta o espaco em bytes ocupada
   pelos principais tipos de variaveis presentes no Object Pascal do Delphi versao 4,
   como podemos ver, os espacos ocupados pelos elementos da matriz sao
   multiplicados por 4 ou na pior das hipoteses, caso exista a necessidade de uma
   maior precisao, por 8, uma vez que os tipos de variaveis que permitem
   269
   CAPITULO 7
   armazenamento de ponto flutuante ocupam 4 bytes (single) ou 8 bytes (real e
   double). Assim, a matriz imagem 1024x1024, quando convertida para ponto
   flutuante, passa a ocupar 4 megabytes se for atribuida com o tipo single e 8
   megabyte para os tipos real e double.
   Tipo
   bytes utilizados
   byte
   1 byte
   integer
   4 bytes
   real
   8 bytes
   single
   4 bytes
   double
   8 bytes
   Tabela 7.1 - Tipos de variaveis do Object Pascal (Delphi 4) e a memoria
   utilizada.
   No segundo caso, temos que considerar que a transformada de Fourier e
   baseada em numeros complexos. Deste modo, somos obrigados a duplicar os
   dados para constituir uma matriz complexa, atraves da utilizacao de uma matriz
   ponto flutuante para representar a parte real e outra para a parte imaginaria. Assim,
   tomando o exemplo anterior, caso tivessemos optado pelos dados do tipo single,
   teriamos que manipular com 8 megabytes, e 16 megabytes se tivessemos optado
   pelo tipo real ou double.
   Dentro da estrategia de paralelismo utilizada, temos basicamente quatro
   conjuntos de trocas de mensagens: (i) correspondentes a distribuicao da imagem
   ou matriz de entrada, (ii) retorno do resultado do processamento horizontal para o
PA mestre, (i i) redistribuicao das porcoes verticais e (iv) envio do resultado final para o
   mestre. Se o algoritmo for utilizado para imagens, parte das mensagens pode ser
   constituida de fragmentos da imagem, diminuindo desta maneira o fluxo de dados.
   Com o grande volume de dados, envolvido nesses processos, o tempo de
   processamento gasto com as operacoes relacionadas a essas transferencias de
   dados (processos de leitura, conversoes e comunicacao em rede) acaba sendo
   maior do que o tempo gasto com o processamento matematico, tornando a
   implementacao dessa estrategia inviavel em sistemas distribuidos com redes
   possuindo taxas de transmissao de 10 ou 100 Mbit/s.
   O sistema foi implementado com 4 maquinas conectadas em rede ethernet
   270
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   de 10 megabits/s. As maquinas utilizadas possuiam processadores AMD k6 II - 375
   MHz, caracterizando o sistema como homogeneo. A Figura 7.16 apresenta um
   diagrama ilustrativo de uma implementacao utilizando quatro maquinas em sistema
   distribuido com rede de 10 megabits/s, mostrando o tempo estimado das trocas de
   mensagem e do processamento matematico, onde podemos observar o gargalo
   formado pelos processos envolvidos com as trocas de mensagens.
   Fig. 7.16 - Estrategia de paralelismo da FFT 2D. Exemplo para 4 processos
   (maquinas ou processadores).
   Como alternativa para a reducao do grande volume de dados envolvidos nos
   processos de transferencia, utilizamos o algoritmo LZW [Nelson, 1989] de
   compactacao de memoria. Dessa maneira, antes dos dados serem transmitidos via
   rede, efetuamos sua compactacao na maquina local. A fim de estudar o
   comportamento do sistema sob diferentes situacoes e na tentativa de otimizar os
   mecanismos de troca de mensagem e consequentemente aumentar a performance
   da versao paralela, o sistema foi implementado de 4 diferentes maneiras:
   Utilizando a memoria de massa (disco rigido) para armazenar todos os dados a
   serem transmitidos via rede.
   Utilizando memoria de massa como em (i), com compactacao de dados antes da
   transmissao.
   Utilizando a memoria RAM para armazenar todos os dados a serem transmitidos
   via rede.
   Idem a anterior, com compactacao dos dados antes da transmissao.
   A Figura 7.17 apresenta os tempos de execucao das diferentes
   implementacoes paralelas frente a versao sequencial em 5 tamanhos diferentes de
   imagens (128x128, 256x256, 512x512, 1024x1024 e 2048x2048). Nela podemos
   271
   CAPITULO 7
   observar a melhora de performance provocada pela compactacao de dados antes
   da transmissao, que embora possua gastos computacionais nos processos de
   compactacao e descompactacao justifica sua utilizacao pela taxa de compactacao,
   que reduziu o tamanho dos dados em cerca de 90% a 99%.
   400
   1000
   4000
   300
   s)
   s)
   800
PA s) 3000
   (m
   (m
   o 200
   o
   600
   p
   p
   o (mp 2000
   m
   tem
   400
   tem
   te
   100
   1000
   200
   0
   0
   0
   1
   2
   3
   4
   5
   1
   2
   3
   4
   5
   1
   2
   3
   4
   5
   128 x 128
   256 x 256
   512 x 512
   70000
   15000
   (1) - Sequencial
   60000
   (2) Paralelo - disco rigido
   s)
   s) 50000
   m
   (3) Paralelo - disco rigido
   10000
   o (
   40000
PA p
   o (m
   + compactacao LZW
   p
   m
   30000
   m
   (4) Paralelo -
   te
   5000
   te 20000
   armazenamento RAM
   10000
   (5) Paralelo -
   0
   armazenamento RAM
   1
   2
   3
   4
   5
   0
   1
   2
   3
   4
   5
   1024 x 1024
   + compactacao LZW
   2048 x 2048
   Fig. 7.17 - Tempos de execucao do sistema sequencial (1) e modalidades
   paralelas (2, 3, 4 e 5) para diferentes tamanhos de imagem. As modalidades
   paralelas foram implementadas em sistemas distribuidos de 4 maquinas.
   A Figura 7.18 apresenta a porcentagem entre o tempo gasto com o
   processamento matematico e o gasto com os procedimentos relacionados com as
   trocas de mensagens (leitura, gravacao, rede, compactacao e conversoes). Nela
   podemos observar como o consumo dos recursos computacionais e maior para os
   processos envolvidos com a troca de mensagens do que com o envolvido com o
   processamento matematico, justificando uma baixa performance dessa arquitetura
   para sistemas distribuidos.
   A Figura 7.19 apresenta a taxa de desempenho ou speed-up, dos sistemas
   paralelos frente ao sequencial. Conforme podemos observar, embora a taxa de
   desempenho aumente gradativamente a medida que aumentam as dimensoes das
   imagens, ela nao atinge um patamar de desempenho satisfatorio ate a dimensao de
   2048x2048. A baixa performance nao justifica a utilizacao desta implementacao
   paralela da FFT 2D, uma vez que com quatro maquinas, o sistema ficou na maioria
   dos casos mais lento que a versao sequencial e atingiu um desempenho maximo
   pouco maior que esta.
   272
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
PA 100
   100
   100
   al
   al
   n
   n
   al
   80
   80
   n 80
   tacio
   tacio
   u
   u
   tacio
   60
   60
   p
   u 60
   mp
   m
   pm
   co 40
   co 40
   40
   co
   rso
   rso
   rso
   cu 20
   cu 20
   20
   e
   e
   cu
   R
   R
   eR
   %
   0
   %
   0
   0
   1
   2
   3
   4
   1
   2
PA 3
   4
   %
   1
   2
   3
   4
   128 x 128
   256 x 256
   512 x 512
   100
   100
   al
   al
   n
   n
   (1) Paralelo - disco rigido
   80
   80
   (2) Paralelo - disco rigido
   tacio
   tacio
   u 60
   u 60
   + compactacao LZW
   mp
   mp
   (3) Paralelo -
   co 40
   co 40
   armazenamento RAM
   rso
   rso
   (4) Paralelo -
   cu 20
   cu 20
   e
   e
   R
   R
   armazenamento RAM
   %
   0
   %
   0
   + compactacao LZW
   1
   2
   3
   4
PA 1
   2
   3
   4
   1024 x 1024
   2048 x 2048
   Processamento matematico
   Proc. relacionado a transf. de dados
   Fig. 7.18 - Porcentagem da utilizacao de recursos computacionais entre o
   processamento matematico e os processos relacionados com as
   transferencias de dados.
   1.5
   1.5
   1.5
   1.5
   p 1.0
   p
   p
   p
   U
   1.0
   U
   1.0
   U
   1.0
   U
   ed
   ed
   ed
   ed
   e
   e
   e
   e
   Sp 0.5
   Sp 0.5
   Sp 0.5
   Sp 0.5
   0.0
   0.0
   0.0
   0.0
   128
   256
   512
   1024 2048
   128
   256
   512
   1024 2048
PA 128
   256
   512
   1024 2048
   128
   256
   512
   1024 2048
   1
   2
   3
   4
   Fig. 7.19 - Graficos da taxa de desempenho ou speed up em funcao do
   tamanho da imagem (dado pelo lado da imagem quadrada). Grafico: (1) disco
   rigido, (2) disco rigido + compactacao LZW, (3) RAM e (4) RAM + compactacao
   LZW.
   Uma vez que o gargalo do sistema esta situado no grande fluxo de
   transferencia de dados, a arquitetura paralela proposta, embora nao seja
   promissora para sistemas distribuidos com rede convencionais, pode ser
   satisfatoria em sistemas de memoria compartilhada, uma vez que esses possuem
   uma velocidade muito maior na troca de mensagens. Para verificarmos sua
   performance em arquitetura com memoria compartilhada, implementamos uma
   versao experimental do sistema com o CVMP memoria compartilhada. Uma vez
   273
   CAPITULO 7
   que nao dispunhamos de uma maquina com multiplos processadores, realizamos a
   simulacao utilizando a caracteristica de multitarefa do sistema operacional. As
   medidas foram feitas com cautela, para nao beneficiar a arquitetura compartilhada.
   Em algumas situacoes optamos para que a simulacao nao se beneficiasse de
   algumas vantagens dessa arquitetura, concluindo portanto que num sistema real
   podemos realizar uma implementacao com algumas otimizacoes.
   4.0
   (a)
   (b)
   6
   3.5
   3.0
   5
   p
   2.5
   Up
   4
   Ud
   2.0
   ed
   3
   ee
   1.5
   Spe
   Sp 2
PA 1.0
   0.5
   1
   0.0
   0
   128x128
   256x256
   512x512
   1024x1024 2048x2048
   128x128
   256x256
   512x512
   1024x1024 2048x2048
   Fig. 7.20 - Graficos da taxa de desempenho ou speed-up em funcao do
   tamanho da imagem. Simulacao de uma arquitetura de memoria
   compartilhada de 4 processadores equivalentes a AMD K6-2 375 MHz. (a)
   Desempenho memoria compartilhada frente a versao sequencial. (b)
   Desempenho da memoria compartilhada frente ao melhor caso da arquitetura
   distribuida (RAM + LZW).
   A Figura 7.20 apresenta os resultados da simulacao. Nela temos o grafico
   da taxa de desempenho ou speed up do sistema paralelo com quatro
   processadores de 375 MHz e memoria compartilhada. Como podemos constatar,
   eliminando a transferencia de dados via rede e o custo dos algoritmos de
   compactacao de dados (LZW), o sistema obteve uma grande melhora de
   performance. No grafico 7.20a temos a taxa de desempenho da arquitetura
   compartilhada em funcao da versao sequencial. A performance foi muito superior
   aos sistemas distribuidos, chegando a quase 3.5 de speed up, o que viabiliza a
   utilizacao da versao paralela. O grafico 7.20b mostra a taxa de desempenho da
   arquitetura compartilhada frente ao melhor caso da arquitetura distribuida, ou seja o
   caso iv (RAM + LZW), nele podemos observar que a implementacao paralela em
   arquitetura compartilhada ficou entre 2,5 a 6 vezes mais rapida que a
   implementacao em sistema distribuido.
   274
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   7.5 - TRANSFORMADA DE HOUGH
   Inicialmente elaborada para calcular a trajetoria de particulas em camaras
   de bolhas [Hough. 1959], a transformada de Hough se tornou uma ferramenta
   tradicional em analise de imagens para o reconhecimento de padroes globais. A
   ideia basica da tecnica consiste em encontrar curvas que podem ser
   parametrizadas, tais como segmentos de reta, polinomios, circulos, elipses e etc.,
   em um espaco de parametros (arranjo acumulador). Embora possa ser utilizada em
   dimensoes maiores, sua principal utilizacao consiste na localizacao de padroes em
   duas dimensoes [Schalkoff, 1989] [Duda & Hart, 1972].
   Dentre os padroes globais disponiveis para a transformada de Hough, o
   mais amplamente difundido e utilizado e o segmento de reta (provavelmente devido
   a importancia dessa modalidade em visao e processamento de imagens), sendo
   muitas vezes generalizada a transformada de Hough como uma tecnica de
   deteccao de retas. Nesta secao vamos nos concentrar apenas nessa modalidade
   da transformada de Hough.
   Os segmentos de reta encontrados em uma imagem podem ser
PA parametrizados como:
   = x cos + y sen
   (7.12)
   onde e a distancia perpendicular ate a origem e o angulo com sua normal
   (Figura 7.21). Deste modo, os pontos co-lineares (xi,yi), onde i varia de 1 a N, sao
   transformados em N curvas senoidais
   = x cos + y sen
   (7.12)
   i
   i
   no plano ( , ), que se intersecionam no ponto ( , ), conforme podemos observar
   na Figura 7.21.
   275
   CAPITULO 7
   (a)
   (b)
   Fig. 7.21 - Demonstracao dos principais elementos envolvidos na
   parametrizacao de retas para a transformada de Hough. (a) Espaco de
   coordenadas original. (b) Espaco de Hough.
   O plano ( , ), e parametrizado em uma estrutura conhecida como arranjo
   acumulador. Trata-se de uma matriz cujas linhas e colunas sao parametrizadas em
   funcao de e , onde para cada ponto do plano original sao incrementados os
   elementos correspondentes a curva senoidal dada por (7.12). Assim, as retas ou os
   pontos colineares da imagem, se apresentam na forma de picos no arranjo
   acumulador, sendo caracterizados como maximos locais. A Figura 7.22 apresenta
   uma imagem com o seu respectivo espaco de Hough.
   (a)
   (c)
   (b)
   Fig. 7.22 - Deteccao de retas atraves da transformada de Hough. (a) Imagem
   original, (b) Arranjo acumulador (espaco de Hough) e (c) Retas detectadas
   (com backmapping ).
   Cada ponto da imagem, corresponde a uma curva senoidal no espaco de
   Hough, que parametrizada incrementa o espaco acumulador, permitindo na tecnica,
   ser processado isoladamente. Deste modo, a transformada de Hough pode ser
   entendida como uma serie de operacoes locais, ja que nao ocorre dependencia de
   276
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   dados entre os elementos da imagem. Baseado nisso, podemos paralelizar o
   algoritmo atraves da divisao da imagem original, ficando cada elemento de
   processamento responsavel por um fragmento, onde no final do processamento o
   arranjo acumulador de cada unidade de processamento devera ser somado
   constituindo o arranjo acumulador resultante da transformada. Informacoes
   adicionais sobre estrategias de paralelismo na transformada de Hough podem ser
   encontrados em [Guil & Zapata, 1997] e [Thazhuthaveetil & Shah, 1991].
   A Figura 7.23 exibe um diagrama que ilustra essa arquitetura para quatro
   unidades de processamento, onde a imagem e dividida em 4 e enviada para cada
   processador. Cada fragmento da imagem e entao processado, gerando o seu
   respectivo espaco de Hough, parametrizado em um arranjo acumulador. No final,
   os elementos dos arranjos acumulador correspondentes a cada porcao da imagem
PA sao somados, gerando o resultado final.
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   I
   II
   III
   IV
   V
   VI
   Fig. - 7.23 - Estrategia de paralelismo para a transformada de Hough. As
   etapas I, II, III, IV, V e VI representam respectivamente: a imagem original,
   divisao da imagem e sua distribuicao, processamento de cada fragmento da
   imagem, arranjos acumulador resultante do processamento de cada
   fragmento, somatorio dos elementos dos arranjos acumulador e arranjo
   acumulador resultante.
   Implementamos versoes do sistema, com 2, 3 e 4 unidades de
   processamento diferentes. A Figura 7.24 mostra um exemplo do diagrama de fluxo
   de dados e execucao para a versao com quatro processadores, nela temos um
   277
   CAPITULO 7
   processo mestre e quatro escravos, onde cada processo esta alojado em uma
   unidade de processamento distinta. O mestre e responsavel pela divisao da
   imagem principal, e sua distribuicao para as maquinas escravas, que juntamente
   com o mestre irao processar um dos fragmentos da imagem. Apos o termino da
   execucao os arranjos acumuladores, resultantes do processamento, sao enviados a
   maquina mestra, que realizara o somatorio dos elementos de cada arranjo,
   constituindo desse modo a resultado final.
   Adotamos os arranjos acumuladores com dimensoes equivalentes as
   imagens. Desta maneira, eles foram parametrizados de forma a possuir um numero
   de elementos muito proximo ao numero de pixels da imagem. Usualmente a
   transformada de Hough e aplicada sobre imagens binarias resultantes de deteccoes
   de bordas, portanto empregamos imagens de 1 bit de profundidade como entrada
   do sistema, diminuindo assim o trafego de mensagens. Para as matrizes que
   armazenam os arranjos acumulador, adotamos o tipo de variavel word, que
   apresenta dois bytes para o armazenamento, de modo que o arranjo acumulador
   ocupa uma memoria de cerca de 16 vezes o tamanho das imagens
   correspondentes.
   Alem de versoes para diferentes quantidades de elementos de
   processamento, vamos apresentar o desempenho para diferentes modalidades de
   arquitetura que obedecem a mesma estrategia de paralelizacao: (i) sistema
   distribuido com rede ethernet de 10 Mb/s, (i ) sistema distribuido com rede fast
   ethernet de 100 Mb/s e (i i) sistema memoria compartilhada.
   Todas as modalidades de sistemas foram implementadas utilizando
   processadores AMD K6 II com 375 MHz. O sistema de memoria compartilhada foi
   simulado.
   Fig. - 7.24 - Diagrama ilustrando as trocas de mensagem e o balanceamento
   de carga do sistema.
PA 278
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   A Figura 7.25 apresenta tres graficos, com os tempos de execucao dos
   sistemas em funcao do numero de processadores. Cada um dos graficos e
   referente a um tamanho de imagem utilizada no experimento (250x250, 500x500 e
   750x750 pixels). Diferente do que seria previsivel, o tempo de execucao da
   modalidade sistema distribuido de 10 Mb/s, ao inves de diminuir aumenta, a medida
   que o sistema e acrescido de unidades de processamento. Isso pode ser observado
   nos graficos referentes as imagens de 250x250 e 500x500 pixels, ao passo que
   essa situacao nao ocorre nas imagens de 750x750 pixels. Esse fato e explicado
   pelo gargalo da transferencia de dados. Conforme e apresentado na Figura 7.23,
   enquanto a imagem e dividida e distribuida para as unidades de processamento, o
   mesmo nao ocorre com o arranjo acumulador. Embora as maquinas processem
   apenas um fragmento da imagem, o resultado obtido e um arranjo acumulador nao
   fragmentado, ou seja, com a mesma dimensao da versao sequencial. Com isso, as
   mensagens a serem retornadas para a maquina mestra, aumentam
   proporcionalmente ao numero de processadores escravos, uma vez que nao se
   fragmentam.
   250x250
   500x500
   750x750
   1200
   5000
   50000
   1000
   4000
   40000
   s)
   s)
   s)
   800
   (m
   (m 3000
   30000
   o
   (m
   600
   p
   o
   po
   p
   m
   2000
   m 20000
   te 400
   tem
   te
   200
   1000
   10000
PA 0
   0
   0
   1
   2
   3
   4
   1
   2
   3
   4
   1
   2
   3
   4
   n. de processadores
   n. de processadores
   n. de processadores
   Sequencial
   Sistema distribuido (rede 10 Mb/s)
   Sistema distribuido (rede 100 Mb/s)
   Memoria compartilhada
   Fig. - 7.25 - Graficos do tempo de execucao em funcao do numero de
   processadores, com suas respectivas modalidades de implementacao. Cada
   grafico e definido mediante um tamanho de imagem.
   Embora ocorra uma situacao semelhante com as outras modalidades, essa
   situacao nao e observada de forma tao nitida, devido ao fato do gargalo de
   transferencia estar reduzido em relacao ao sistema distribuido de 10 Mb/s. O
   mesmo fato ocorre nesse sistema no processamento de imagens de 750x750
   pixels, uma que o tempo de processamento aumenta consideravelmente em
   279
   CAPITULO 7
   relacao ao tempo de transferencia, fazendo com que o gargalo diminua.
   100
   100
   l
   100
   80
   80
   ciona
   80
   putacional
   putacional
   m 60
   puta 60
   m
   m 60
   40
   40
   40
PA recurso co 20
   20
   recurso co
   recurso co 20
   250x250
   %
   %
   %
   0
   0
   0
   a
   b
   c
   a
   b
   c
   a
   b
   c
   100
   l 100
   l 100
   80
   80
   80
   putacional
   putaciona
   putaciona
   m 60
   60
   60
   40
   40
   rso com
   40
   rso com
   recurso co 20
   recu 20
   recu 20
   %
   %
   %
   500x500
   0
   0
   0
   a
   b
   c
PA a
   b
   c
   a
   b
   c
   l
   l 100
   100
   100
   80
   80
   80
   taciona
   putaciona
   pu
   putacional
   60
   60
   m
   m 60
   40
   40
   rso com
   40
   rso co
   20
   recu 20
   recu
   recurso co 20
   750x750
   %
   %
   %
   0
   0
   0
   a
   b
   c
   a
   b
   c
   a
   b
   c
   2
   3
   4
   a Sistema distribuido (rede 10 Mb/s)
PA Proc. relacionado a transf. de dados
   b Sistema distribuido (rede 100 Mb/s)
   c Memoria compartilhada
   Processamento Hough
   Fig. - 7.26 - Porcentagem da utilizacao de recursos computacionais entre o
   processamento da tecnica e os processos relacionados com as
   transferencias de dados. As linhas horizontais contem os graficos
   relacionados ao tamanho da imagem, enquanto que as linhas verticais os
   numeros de processadores.
   A Figura 7.26 apresenta a porcentagem entre o tempo gasto com o
   processamento da tecnica e com os procedimentos relacionados com as trocas de
   mensagens. Nela podemos observar a situacao descrita anteriormente, que fica
   bem nitida com os sistemas distribuidos de 10Mb/s. Como podemos observar a
   porcentagem relativa ao tempo gasto com a troca de mensagem se torna maior a
   medida que aumentam os processadores. Com isso podemos concluir que essa
   arquitetura nao favorece a utilizacao de sistemas massivamente paralelos, ja que o
   aumento no numero de processadores resulta igualmente num aumento do volume
   de mensagens, que devera atingir um limite nos sistemas distribuidos de 100 Mb/s
   280
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   semelhante ao dos sistemas de 10 Mb/s a partir de um determinado numero de
   processadores.
   As taxas de desempenho ou speed-up dos sistemas sao mostradas nos
   graficos da Figura 7.27. Atraves deles sao determinadas as performances de cada
   modalidade frente a versao sequencial. Conforme podemos observar, a arquitetura
   apresentou um bom desempenho para diferentes quantidades de unidades de
   processamento, com excecao dos sistemas distribuidos baseados em redes de
   ethernet de 10 Mb/s, que apresentaram uma performance pequena para as
   imagens de 250x250 e 500x500 pixels, especialmente com 3 ou 4 processadores.
   250x250
   500x500
   750x750
   4.0
   4.0
   4.0
   3.5
   3.5
   3.5
   3.0
   3.0
   3.0
   Up 2.5
   up 2.5
   up 2.5
   d 2.0
   d 2.0
   d 2.0
   ee
   ee
   ee
PA 1.5
   Sp
   1.5
   Sp
   1.5
   Sp
   1.0
   1.0
   1.0
   0.5
   0.5
   0.5
   0.0
   0.0
   0.0
   2
   3
   4
   2
   3
   4
   2
   3
   4
   n. de processadores
   n. de processadores
   n. de processadores
   Sistema distribuido (rede 10 Mb/s)
   Sistema distribuido (rede 100 Mb/s)
   Memoria compartilhada
   Fig. - 7.27 - Graficos da taxa de desempenho ou speed up em funcao do
   numero de processadores. Os graficos apresentam as tres modalidades
   implementadas no experimento. Cada grafico e correspondente a um tamanho
   de imagem.
   Devido as baixas performances obtidas com os sistemas distribuidos
   baseados em ethernet, decidimos explorar alguns mecanismos que possibilitassem
   a diminuicao da carga de mensagens e consequentemente a ampliacao do gargalo,
   de modo a aumentar o desempenho. O maior gargalo encontrado no sistema, se
   encontra na transferencia dos arranjos acumuladores dos processos escravos,
   resultantes do processamento de cada fragmento de imagem para o processo
   mestre, portanto a solucao estaria na reducao do tamanho dos arranjos
   acumulador. Na tentativa de reduzir o tamanho dos arranjos acumulador, adotamos
   duas estrategias: (i) compactacao LZW e (ii) lista de picos.
   Na primeira estrategia, utilizamos o algoritmo de compactacao de dados
   para diminuir o volume dos dados do arranjo antes de ser transmitido para o
   281
   CAPITULO 7
   processo mestre. Deste modo, embora seja acrescida uma carga computacional,
   devido ao processamento do algoritmo LZW [Nelson, 1989], esperamos que seu
   tempo de execucao seja menor que o tempo de transferencia do arranjo sem
PA compactacao.
   Como sabemos, muitas das informacoes contidas no arranjo acumulador
   nao sao utilizadas pelas maiorias das aplicacoes (deteccao de retas), deste modo,
   os interesses estao concentrados nos picos, que caracterizam os maiores conjuntos
   de pontos colineares, ou seja, as retas da imagem. Considerando essa abordagem,
   elaboramos a segunda estrategia, que consiste na criacao de uma lista ou vetor
   contendo as coordenadas do plano de Hough e seu conteudo apenas as celulas
   que ultrapassam um determinado valor (limiar). Nao exploramos as heuristicas para
   a determinacao do limiar, no entanto este foi definido como a decima quinta parte
   do maior elemento do arranjo.
   A Figura 7.28 apresenta comparacoes entre as duas estrategias frente a
   versao experimentada nesta secao. Nela temos o tempo de execucao da versao de
   4 maquinas conectadas via ethernet. Como podemos observar, as duas alternativas
   que utilizamos para a reducao dos gargalos tiveram um bom resultado, aumentando
   consideravelmente a performance comprometida da transformada de Hough
   distribuida em rede ethernet 10 Mb/s.
   250x250
   500x500
   750x750
   20000
   1000
   4000
   800
   s)
   3000
   s)
   15000
   s)
   m
   m
   ( 600
   (
   o
   (m
   o
   p
   op 2000
   10000
   p
   m 400
   m
   m
   te
   te
   te
   1000
   5000
   200
   0
   0
PA 0
   a
   b
   c
   a
   b
   c
   a
   b
   c
   Convencional
   Compactacao - LZW
   Lista de picos
   Fig. - 7.28 - Graficos apresentando o tempo de execucao relacionados com o
   tamanho da imagem, apresentando uma comparacao entre as diferentes
   versoes de implementacao paralela para os sistemas distribuidos com rede
   ethernet 10 Mb/s.
   282
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   250x250
   500x500
   750x750
   l
   l
   l
   a 100
   a 100
   a 100
   90
   90
   90
   80
   tacion
   80
   tacion
   80
   tacion
   u 70
   u 70
   u 70
   mp 60
   mp 60
   mp 60
   o
   o
   o
   50
   50
   50
   40
PA 40
   40
   30
   30
   30
   ecurso c 20
   ecurso c 20
   ecurso c 20
   % r 10
   % r 10
   % r 10
   0
   0
   0
   a
   b
   c
   a
   b
   c
   a
   b
   c
   Processamento Hough
   Proc. relacionado a transf. de dados
   Fig. - 7.29 - Porcentagem da utilizacao de recursos computacionais entre o
   processamento da tecnica e os processos relacionados com as
   transferencias de dados (e afins: compactacao e lista de picos). (a) Sistema
   distribuido 10 Mb/s, (b) Sistema distribuido com compactacao e (c) Sistema
   distribuido com lista de picos.
   O aumento de performance e explicado pela reducao no volume dos dados
   a serem transferidos, como mostra a Figura 7.29. Embora as duas alternativas (i) e
   (ii) reduzam o volume dos arranjos acumulador com uma taxa proxima
   (aproximadamente 85% do tamanho original), a compactacao por LZW (i) e
   computacionalmente mais custosa e a lista de picos (i ) apresentou um melhor
   desempenho do sistema distribuido. A Figura 7.30 apresenta as taxas de
   desempenho ou speed-up, comparando as implementacoes paralelas.
   Embora a lista de picos (i ) tenha apresentado um resultado melhor na
   eliminacao dos gargalos, e consequentemente na performance, devido a reducao
   dos dados do arranjo acumulador; essa alternativa nao pode ser utilizada pela
   totalidade das aplicacoes da transformada, uma vez que algumas destas podem
   envolver uma exploracao maior dos dados presentes no arranjo acumulador. A
   compactacao por LZW, entretanto, nao altera o conteudo do arranjo acumulador,
   permitindo portanto sua utilizacao em toda a gama de aplicacoes, uma vez que
   apresenta resultado identico ao da transformada de Hough.
   Apresentamos nesta secao algumas estrategias e implementacoes para a
   transformada de Hough paralela enfocando a deteccao de retas. No entanto, estas
   podem ser estendidas para outras curvas parametrizadas no espaco de Hough,
   mediante algumas adaptacoes.
   283
PA CAPITULO 7
   250x250
   500x500
   750x750
   4
   4
   4
   3
   3
   3
   p
   p
   d u
   d u
   2
   2
   2
   eed up
   ee
   ee
   p
   p
   Sp
   S
   S
   1
   1
   1
   0
   0
   0
   a
   b
   c
   a
   b
   c
   a
   b
   c
   Convencional
   Compactacao - LZW
   Lista de picos
   Fig. - 7.30 - Graficos da taxa de desempenho ou speed up. Cada grafico e
   correspondente a um tamanho de imagem.
   7.5.1 - RASTREAMENTO DO ARRANJO ACUMULADOR
   (BACKMAPPING)
   Um grande problema na transformada de Hough se encontra na localizacao
   dos picos do arranjo acumulador, uma vez que estes correspondem as curvas as
   quais a tecnica espera detectar realmente. A grande dificuldade reside na
PA caracteristica local de cada pico, sendo este um problema ainda nao resolvido por
   completo pela ciencia. Devido as limitacoes no processo de localizacao dos picos
   locais, como resultado da transformada podem ser apresentadas diversas falsas
   curvas, provocadas pela interferencia de pontos colineares entre diferentes curvas,
   entre segmentos com poucos pixels e ate mesmo o ruido presente na imagem.
   Um avanco na direcao da solucao desse problema foi publicado em 1986
   por Gerig e Klein [Gerig & Klein, 1986], que introduziram um passo adicional a
   transformada de Hough, denominado de backmapping (rastreamento). A tecnica de
   backmapping consiste na criacao de um novo arranjo acumulador, onde a
   transformada e novamente calculada para cada ponto da imagem. Para este novo
   espaco, contudo, somente sao computadas as celulas que correspondem aos
   valores maximos de cada uma das senoides do arranjo original. Deste modo, essa
   abordagem corresponde a um reforco aplicado a transformada de Hough, na
   tentativa de localizar os picos locais e reduzir os picos causados pelos pontos
   284
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   colineares de curvas distintas, ruidos, interferencia entre objetos e segmentos com
   poucos pontos.
   Devido ao novo calculo da transformada aliado a buscas continuas de
   pontos maximos para as curvas do espaco de Hough, correspondentes a cada
   ponto da imagem, essa tecnica e bastante dispendiosa, consumindo grande poder
   computacional, motivando portanto seu paralelismo.
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   ( , )
   backmapping
   ( , )
   ( , )
   ( , )
   I
   II
   III
   IV
   Fig. - 7.31 - Estrategia de paralelismo para a tecnica de rastreamento
   (backmapping) , para quatro unidades de processamento. I - Divisao da
   imagem e distribuicao dos fragmentos, II - Distribuicao do arranjo acumulador
   resultante da transformada de Hough, III - Processamento do backmapping a
   partir dos dados dos fragmentos da imagem e do arranjo acumulador , IV -
   transmissao do arranjo acumulador gerado pelo rastreamento para o
   processo mestre, onde os elementos de cada arranjo serao somados
   constituindo o resultado da tecnica.
   Atraves de algumas adaptacoes a estrategia de paralelismo apresentada na
PA Figura 7.23, desenvolvemos uma estrategia para paralelizar o algoritmo de
   rastreamento ( backmapping). Podendo ou nao ser utilizada em conjunto com a
   versao paralela da transformada de Hough, descrita em 7.5, o paralelismo da
   tecnica de rastreamento consiste basicamente na distribuicao do arranjo
   acumulador, obtido na transformada de Hough para os processos envolvidos na
   computacao, e na fragmentacao da imagem original, e sua distribuicao, ou no caso
   da transformada de Hough paralela, na utilizacao dos fragmentos da imagem
   original ja processada. A Figura 7.31 exibe um diagrama contendo as definicoes
   285
   CAPITULO 7
   para paralelizacao da tecnica para quatro elementos de processamento, que pode
   ser expandida facilmente. Apos serem distribuidos os fragmentos da imagem (fig.
   31 - I) e distribuidos os resultados da transformada de Hough para os elementos de
   processamento, sao entao realizadas o processamento do rastreamento
   simultaneamente para cada um dos fragmentos da imagem, produzindo um novo
   arranjo acumulador. Assim como na versao paralela da transformada de Hough, os
   arranjos sao transmitidos para a unidade mestre, atraves do somatorio deste
   constituira o resultado final.
   Implementamos a versao paralela da tecnica utilizando sistema distribuido
   em rede ethernet de 10 Mb/s, com quatro maquinas possuindo processadores
   semelhantes AMD K6 II - 375 MHz. A Figura 7.32 apresenta o tempo de
   processamento da versao sequencial e das paralelas para dois tamanhos de
   imagem diferentes (250x250 e 500x500 pixels).
   250x250
   500x500
   25000
   100000
   20000
   s)
   s) 80000
   (m 15000
   (m
   po
   60000
   po
   10000
   tem
   tem 40000
   5000
   20000
   0
   0
   1
   2
   3
   4
   1
   2
   3
   4
PA n. de processadores
   n. de processadores
   Fig. - 7.32 - Graficos do tempo de execucao em funcao do numero de
   processadores.
   Na Figura 7.33 temos os graficos da porcentagem de utilizacao de recursos
   computacionais entre o processamento referente a tecnica backmapping e aos
   processos relacionados com as transferencias de dados. Embora possua um fluxo
   de dados muito maior do que a transformada de Hough, a porcentagem de recursos
   gastos com a transferencia dos dados e menor. Ja a tecnica de backmapping e
   mais dispendiosa que a transformada de Hough, uma vez que alem de conter os
   mesmos calculos necessarios da transformada, sao realizados operacoes para
   obtencao dos pontos de maximo valor do arranjo acumulador para cada ponto
   analisado da imagem. Devido ao grande poder computacional requerido pelos
   calculos, a transferencia de dados nao se torna um gargalo critico para as versoes
   paralelas.
   286
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   250x250
   500x500
   l 100
   l 100
   ciona 80
   ciona
   ta
   80
   ta
   pu
   pu
   m 60
   m 60
   co
   co
   o 40
   o
   rs
   40
   rs
   recu 20
   recu 20
   %
   %
   0
   0
   2
   3
   4
   2
   3
   4
   n. de processadores
PA n. de processadores
   Proc. tecnica Backmapping
   Proc. relacionado a transf. de dados
   Fig. - 7.33 - Porcentagem da utilizacao de recursos computacionais entre o
   processamento da tecnica e os processos relacionados com as
   transferencias de dados.
   A porcentagem de recursos gastos com a transferencia de dados,
   entretanto, vai aumentando proporcionalmente com o numero de processos
   (processadores), uma vez que os arranjos acumuladores nao sao fragmentados.
   Com isso, embora a performance aumente com o acrescimo de elementos de
   processamento no sistema, aumenta tambem o gargalo, de modo que a razao entre
   o numero de processadores e o ganho de performance diminua. Na Figura 7.34 sao
   apresentados os graficos de taxa de desempenho ou speed-up em funcao do
   numero de processadores.
   250x250
   500x500
   4.0
   4.0
   3.5
   3.5
   3.0
   3.0
   up 2.5
   up 2.5
   d
   d
   2.0
   ee
   2.0
   ee
   1.5
   Sp
   1.5
   Sp
   1.0
   1.0
   0.5
   0.5
   0.0
   0.0
   2
   3
   4
   2
   3
   4
   n. de processadores
   n. de processadores
   Fig. - 7.34 - Taxa de desempenho em funcao do numero de processadores.
   .
PA 287
   CAPITULO 7
   7.6 - RESTAURACAO DE IMAGENS BASEADO EM
   CAMPOS RANDOMICOS MARKOVIANOS
   Uma aplicacao bastante comum em processamento de imagens e a
   eliminacao de ruidos de uma imagem. Diversos fatores, tais como interferencia em
   sistemas de aquisicao de imagem, ruido em sistemas de comunicacao, sistemas de
   imagem por satelite, sistema de aquisicao de imagens medicas (ultra-som), etc.,
   podem ocasionar a adicao de ruidos a imagem, de forma a polui-la. Os algoritmos
   de restauracao de imagens sao tecnicas que permitem a reducao do ruido ou em
   alguns casos ate mesmo sua completa eliminacao.
   Nesta secao vamos apresentar a paralelizacao do algoritmo de restauracao
   de imagens baseado em campos aleatorios de Markov, desenvolvido no decorrer
   deste doutorado. A nova tecnica [Bruno & Costa, 2000] consiste em uma
   modificacao dos campos aleatorios de Gibbs operando no modo condicional
   iterativo (ICM) [Chellappa & Jain, 1993].
   A primeira abordagem da tecnica classifica o campo aleatorio de Markov
   como um caso especifico da teoria da regularizacao [Poggio et al., 1985]. A
   regularizacao de um problema "il -posed" pode ser compreendida em termos da
   equacao Az=y, onde z e a solucao procurada, y e o dado original, e A e o operador linear. Uma possivel solucao consiste em achar z que minimiza ( z) na Equacao
   7.12, onde ||P z|| e o estabilizador funcional.
   ( z) = Az y 2 + Pz 2
   (7.12)
   Enquanto o primeiro termo da Equacao 7.12 expressa a discrepancia entre
   os dados originais e a solucao, o segundo termo indica o sucesso da solucao z no
   criterio de regularizacao expresso pelo operador P. Atraves de variacoes no
   parametro e possivel controlar o grau de similaridade do dado original e do
   resultado do processo de regularizacao. Para a tecnica de restauracao de imagem
   P e considerado linear. Aplicando o conceito em termos praticos, a Equacao 7.13
   ilustra essa situacao com respeito a dois termos funcionais, onde f (x,y) e a imagem
   original e g(x,y) e a solucao procurada. O primeiro termo forca a similaridade entre
   a imagem original e a imagem modificada, o segundo termo conhecido como
   "membrana", impoe um certo grau de "borramento", controlado pelo parametro ,
   288
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   sobre a solucao esperada g(x,y).
   2
   F ( x, y)=
   f ( x, y) g( x, y)2 + 2. r g( x, y) dxdy (7.13)
   image
   Embora o conceito dos campos aleatorios de Markov (MRF) nao seja novo,
   sua aplicacao em processamento de imagem e visao computacional foi apenas
   recentemente explorada [Bruno & Costa, 2000]. Basicamente, os campos aleatorios
   de Markov, sao extensoes de grandes dimensoes da classica abordagem da cadeia
   de Markov. Deste modo, ele assume que o valor de um dado ponto da imagem e
   influenciado somente pelo seu vizinho imediato. Pelo estabelecimento de uma
   conexao entre os campos aleatorios de Markov (locais) e a distribuicao de Gibbs
   (global) dada pela mecanica estatistica, o teorema de Hammersley-Clifford permitiu
   um significado essencial para o calculo das probabilidades das possiveis
   configuracoes em MRF [Li, 1995] [Kindermann and Snell, 1980] [Chellappa & Jain,
PA 1993]. Mais especificamente, a probabilidade de uma dada configuracao (dentro de
   um conjunto finito de valores quantificados), frequentemente parametrizados pelo
   decrescimo de temperatura, e fornecida pela probabilidade da densidade de massa
   da distribuicao de Gibbs [Geman & Geman, 1984], que e determinada pela
   temperatura e pela energia definida pelos potenciais de cliques. Embora grandes
   vizinhancas sejam possiveis, aplicacoes em analise e processamento de imagem,
   tipicamente consideram cliques com conexoes de 4 ou 8 vizinhos em torno do pixel.
   A abordagem MRF permite muitas possibilidades na incorporacao de contextos ao
   processamento de imagens, provavelmente uma das mais tipicas seja na
   restauracao de imagens.
   Considerando que unir as distribuicoes em um MRF e uma tarefa
   particularmente complicada, uma abordagem alternativa denominada de modo
   condicional iterativo (ICM) foi proposta por Besag [Besag, 1986]. Duas hipoteses
   sao assumidas no ICM: (i) as observacoes di sao independentes e cada observacao
   possui a mesma densidade condicional conhecida p(di|f i), que depende somente de
   f i; e (i ) cada rotulo depende somente de um rotulo vizinho. A Equacao 7.14
   apresenta um criterio simplificado de classificacao que consiste na maximizacao da
   probabilidade, onde S e o conjunto de sitios e N i sao as vizinhancas no sitio i [Li,
   1995].
   289
   CAPITULO 7
   P( f | d, f
   p d | f . P f | f
   (7.14)
   i
   S i )
   ( i i) ( i N )
   { }
   i
   A tecnica assume que as imagens binarias foram corrompidas por ruido
   Gaussiano, com um parametro conhecido. Somente dois valores de cliques sao
   considerados, com pesos iguais, de forma a favorecer a uniformidade. Assim, a
   Equacao 7.14 produz o seguinte criterio de classificacao:
   0
   p( d | f = 0 / p d | f = 1
   P f = 1| f
   / P f = 0 | f
   (7.15)
   i
   i
   ) ( i i )
   ( i
   N )
   ( i
   )
   i
   Ni
   <1
   Como pode ser verificado, os primeiros termos da condicao de 7.15,
   refletem o modelo da imagem e o modelo do ruido, e o segundo termo expressa a
PA influencia contextual do vizinho com adjacencia imediata, que sao similares ao
   primeiro e segundo termos da Equacao 7.13.
   Uma versao mais flexivel do criterio descrito anteriormente e obtida por
   pesos adicionais, na forma de parametros , conforme podemos observar a seguir:
   0
   [ p( d | f = 0 p d f
   P f
   f
   P f
   f
   (7.16)
   i
   i
   )/ ( | =
   i
   i
   )1(.1 )+ ]
   [1 ( =1|
   i
   N )/
   ( = 0|
   i
   )(.1 )]
   <
   i
   Ni
   1
   Agora, as influencias relativas do modelo imagem/ruido e a coacao
   contextual podem ser continuamente variadas em termos do parametro . A Tabela
   7.2 ilustra alguns criterios que sao obtidos em funcao de diferentes valores de .
   Enquanto para
   =0 a condicao e exclusivamente governada pelo modelo
   imagem/ruido, para =1 somente a coacao contextual e refletida. A condicao
   original dada por 7.15 e obtida para =0,5. Diferentes influencias sao obtidas para
   valores de [0,1]. Alguns resultados experimentais sao apresentados na Figura
   7.35, que claramente apresentam a flexibilidade permitida pela tecnica.
   290
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   Criterio
   0.00
   0
   p( d | f = 0 p d f
   i
   i
   )/ ( | =
   i
   i
   )1
   1
   <1
PA 0.25
   0
   ( .075). p( d | f = 0 p d f
   P f
   f
   P f
   f
   i
   i
   )/ ( | =
   i
   i
   )1
   ( .025). ( =1|
   i
   N )/
   ( = 0|
   i
   )+0 5.
   <
   i
   Ni
   1
   0.50
   0
   p( d | f = 0 / p d | f = 1
   P f = 1| f
   / P f = 0 | f
   i
   i
   ) ( i i )
   ( i
   N )
   ( i
   )
   i
   Ni
   <1
   0.75
   0
   ( .025). p( d | f = 0 / p d | f =1 + 0 5.
   0 75
   .
   . P f = 1| f
   / P f = 0 | f
   i
   i
   ) ( i i )
   (
   ) ( i
PA N )
   ( i
   )
   i
   Ni
   <1
   1.00
   0
   1
   P( f =1| f / P f = 0 | f
   i
   N )
   ( i
   )
   i
   Ni
   <1
   Tabela 7.2 - Exemplos de criterios obtidos em termos de .
   (a)
   (b)
   (c)
   (d)
   (e)
   Fig. - 7.35 - Resultados da tecnica de restauracao - (a) Imagem original
   100x100 corrompida por um ruido gaussiano com 2=0,5. Os resultados sao
   respectivos a =0,3 (b), =0,5 (c), =0,7 (d) e =0,9 (e).
   7.6.1 - ESTRATEGIA DE PARALELISMO
   Diferente das tecnicas apresentadas anteriormente neste capitulo, o
   algoritmo de restauracao de imagens baseado em campos aleatorios de Markov e
   um metodo iterativo, que se repete continuamente ate que ocorra a convergencia
   numerica. Do ponto de vista do paralelismo, esse fato acrescenta uma
   complexidade a estrategia, uma vez que a troca de mensagens entre os processos
   ocorre diversas vezes de forma a atualizar os dados a cada iteracao, o que torna o
   291
   CAPITULO 7
   problema bastante interessante.
   A Figura 7.36 apresenta as bases da estrategia de paralelizacao para quatro
   elementos de processamento, onde a imagem e dividida pelo processo mestre, que
   distribui cada parte desta para os processos escravos, ficando com um fragmento.
   Apos a distribuicao, cada processo executa o algoritmo MRF, que consiste de uma
   serie de iteracoes, envolvendo troca de mensagens e atualizacao de dados, que
   serao discutidos adiante. Uma vez tendo convergido a tecnica, os resultados sao
   enviados para o mestre, que une os fragmentos, formando o resultado sobre a
   imagem original.
   Imagem - aquisicao
   divisao e distribuicao
   MRF algoritmo
   Recebe e une o
   resultado
   Escravo A - MRF
PA 2
   2
   1 2
   1 2
   Mestre
   3
   Escravo B - MRF
   3
   Mestre
   3 4
   3 4
   imagem
   4
   4
   resultado
   Escravo C - MRF
   1
   Mestre - MRF
   1
   Fig. - 7.36 - Estrategia basica de paralelismo da tecnica MRF.
   Nesta tecnica (MRF), cada elemento e calculado considerando os cliques
   envolvendo a vizinhanca dos 8 pontos em torno de cada pixel. Embora distancias
   maiores sejam tambem verificadas, essa situacao ocorre ao longo do tempo
   (iteracoes) atraves de propagacao entre os elementos vizinhos. Deste modo, para
   cada iteracao ocorre a dependencia de dados entre os limites da divisao da
   imagem. Para solucionar essa dependencia de dados e atualizar as porcoes de
   imagem em cada elemento de processamento, permitindo assim a propagacao de
   informacoes ao longo de toda a imagem, foram implementadas tres estruturas de
   atualizacao de dados, duas na forma de vetores e a ultima sendo um unico ponto. A
   Figura 7.37 apresenta a configuracao das estruturas de atualizacao para a parte 1
   da imagem. Como podemos observar, o vetor vertical e composto pelos pixels da
   borda da parte 3, ocorrendo o mesmo com o vetor horizontal, que e associado a
   parte 2. A pequena estrutura de atualizacao, caracterizada como um ponto, e
   292
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   composta pelo pixel do canto superior esquerdo da parte 4.
   Parte 1
   Parte 3
   da
   da
   Imagem
   Imagem
   Parte 2
   Parte 4
   da
   da
   Imagem
   Imagem
   Fig. - 7.37 - Estrategia basica de paralelismo da tecnica MRF.
   A incorporacao das estruturas de atualizacao permite que todas as iteracoes
PA sejam calculadas em concorrencia, resolvendo a questao da dependencia de dados
   e permitindo a convergencia da tecnica e a propagacao dos dados atraves das
   vizinhancas. Para tanto, os modulos paralelos devem trocar as informacoes
   contidas nas estruturas de atualizacao apos cada iteracao do algoritmo MRF. A
   Figura 7.38 ilustra a troca de informacoes atraves das estruturas de atualizacao,
   nela sao apresentados quatro modulos, representados pelas caixas numeradas,
   com suas respectivas estruturas de atualizacao, representadas pelas caixas
   preenchidas. Diferente da Figura 7.36, aqui nao ha distincao entre os processos
   mestre e escravo.
   Fig. - 7.38 - Diagrama de transferencia das estruturas de atualizacao.
   Nesta arquitetura, o balanceamento de carga e definido pela quantidade de
   pontos a serem processados. Neste caso, em sistemas heterogeneos, ou seja,
   293
   CAPITULO 7
   aqueles em que as unidades de processamento possuem diferentes poderes
   computacionais, devem ser atribuidas porcoes de imagem proporcionais a
   performance de cada uma das unidades de processamento do sistema. Embora a
   Figura 7.38 apresente um diagrama limitado em apenas quatro unidades de
   processamento, sem a preocupacao com o balanceamento de carga, a arquitetura
   permite um conjunto virtualmente infinito de configuracoes.
   A Figura 7.39 apresenta algumas possibilidades de configuracoes da
   arquitetura para 6 e 9 unidades de processamento, que demonstram que a
   arquitetura pode ser estendida facilmente para qualquer numero de elementos de
   processamento. O balanceamento de carga do sistema pode ser realizado alojando
   mais de um modulo da imagem em uma unica unidade de processamento. Essa
   abordagem e mostrada na Figura 7.40, onde sao apresentados tres exemplos
   envolvendo balanceamento de carga em sistemas heterogeneos. Os modulos
   agrupados em caixas estao alojados em um unico elemento de processamento,
   permitindo desse modo uma distribuicao irregular da carga computacional ao longo
   do sistema.
   (a)
   (b)
   Fig. - 7.39 - Diagrama de transferencia das estruturas de atualizacao para 6 (a)
   e 9 (b) elementos de processamento.
   294
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   (a)
   (b)
   (c)
   Fig. - 7.40 - Exemplos de balanceamento de carga, com 3 elementos de
   processamento heterogeneos.
   Nesta tecnica, o numero de iteracoes depende do nivel de ruido e da
   estrutura da imagem. Em alguns casos a convergencia nao e garantida. Assim, o
   processamento pode ser finalizado pelos eventos seguintes: (a) nao ocorrendo
   modificacao em nenhum dos modulos (convergencia); ou (b) o numero de iteracoes
   ultrapassa um limiar pre-estabelecido. Devemos observar tambem que cada
   modulo envia suas tres estruturas de atualizacao para os outros modulos e essas
   estruturas sao necessarias para a proxima iteracao. Quando um modulo e
   finalizado, ele fica inativo ate a proxima iteracao. Se algum dado foi alterado
   (atraves das estruturas de atualizacao), entao o modulo inicia outra iteracao; caso
PA contrario, envia sua estrutura e aguarda os proximos dados.
   295
   CAPITULO 7
   MRF
   MRF
   MRF
   i1
   i2
   i3
   Classificacao Bayeseana
   Mestre
   MRF
   Recebe estruturas
   Escravo 1
   Envia estrutura e continua
   Envia estrutura e para
   Escravo 2
   Confere as estruturas
   Envia os resultados
   Escravo 3
   Agrupa os resultados
   Fig. - 7.41 - Diagrama de execucao do algoritmo MRF paralelo, para quatro
   elementos de processamento.
   A Figura 7.41 apresenta um diagrama que representa a arquitetura em
   execucao para quatro elementos de processamento. O primeiro passo da tecnica e
   a classificacao Bayeseana realizada pelo mestre, que e entao distribuida. A partir
   destes dados sao iniciadas as iteracoes do MRF. O numero de iteracoes do
   algoritmo MRF e variavel, e devido a sua natureza estocastica nao existe uma
   maneira de prever com precisao como sera executado. Cada modulo pode parar
   em tempos diferentes, como pode ser observado, os modulos escravos 1 e 3
   terminam na primeira iteracao e o modulo 2 termina na segunda iteracao. No
   entanto, a qualquer iteracao, um modulo parado pode voltar a ativa mediante
   alteracoes na estrutura de atualizacao. Isto pode ser observado no modulo escravo
   3, que recebe um dado diferenciado na iteracao 2, sendo forcado a processar mais
   uma iteracao. A tarefa de verificar o fim do algoritmo fica a cargo do mestre, que ao
   final de cada iteracao recebe uma mensagem do estado de cada modulo,
   finalizando o processamento quando todos os modulos tiverem convergido. Apos a
   finalizacao do algoritmo, todos os resultados sao enviados para o mestre, que os
   combina formando o resultado final.
   7.6.2 - IMPLEMENTACAO E RESULTADOS
   A estrategia de paralelismo para o algoritmo de restauracao de imagens
   baseado em campos randomicos markovianos desenvolvida durante este
   doutorado foi implementada em sistemas distribuidos atraves do CVMP. Nesta
   296
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   secao vamos apresentar os resultados experimentais da implementacao paralela da
   tecnica em quatro maquinas conectadas por rede ethernet de 10 mb/s. No primeiro
   experimento, utilizamos maquinas com diferentes performances, que resultam em
   um sistema nao balanceado. Deste modo, as maquinas mais velozes precisam
   esperar pelas mais lentas para continuar o processamento. Embora essa
PA abordagem leve a uma performance baixa, ela e ainda interessante para ilustrar
   algumas caracteristicas do sistema. Utilizamos no primeiro experimento uma
   imagem binaria de 200 x 200 pixels.
   A Figura 7.42 apresenta um diagrama caracterizando a execucao do
   sistema, enquanto que a Figura 7.43 mostra um diagrama correspondente a
   transferencia de dados. As maquinas utilizadas no experimento foram: uma
   Pentium de 150 MHz como mestre, um Pentium de 90 MHz como escravo A, um
   Pentium 133 MHz como escravo B e um Pentium 150 MHz como escravo C. O
   grande numero de bolhas encontrado no diagrama da Figura 7.42 e devido
   especialmente as maquinas mais velozes, que tiveram que esperar pela vagarosa
   maquina de 90 MHz.
   Fig. - 7.42 - Diagrama de execucao do algoritmo MRF paralelo em um sistema
   heterogeneo.
   297
   CAPITULO 7
   Fig. - 7.43 - Diagrama da troca de mensagens.
   Observando ainda os diagramas das Figuras 7.42 e 7.43 podemos verificar
   a dificuldade de estabelecer a performance real do sistema, uma vez que o sistema
   nao e previsivel quanto ao numero de iteracoes. No experimento apresentado o
   mestre e o escravo C tiveram 3 iteracoes, enquanto os escravos A e B apenas
   duas.
   Para extrairmos medidas de desempenho mais consistentes, escolhemos
   situacoes em que tanto a versao sequencial quanto a paralela tiveram quatro
   iteracoes. Realizamos esse experimento em sistema distribuido homogeneo com
   quatro maquinas Pentium 133 Mhz conectadas com rede padrao ethernet de 10
   mb/s. A Figura 7.44a apresenta o grafico de tempo de execucao das versoes
   sequencial e paralela para quatro maquinas. Conforme pode ser observado, a
   performance do sistema paralelo aumenta a medida que aumenta o tamanho da
   imagem, tornando-se 3,5 vezes mais rapido que a versao sequencial nas imagens
   de 700x700 pixels (ver Figura 7.44b).
   298
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   4
   3
   p
   d u 2ee
   Sp
   1
   0 200x200 300x300 400x400 500x500 600x600 700x700
   Tamanho da imagem (pixels)
   (a)
   (b)
   Fig. - 7.44 - Comparacoes de performance entre a versao paralela e
   sequencial. (a) Grafico do tempo de execucao em funcao do tamanho de
   imagem. (b) Grafico da taxa de desempenho em funcao do tamanho de
   imagem.
   7.7 - DIMENSAO FRACTAL
   Muitas formas na natureza sao tao complexas e irregulares que sao dificeis
   e ate mesmo impossiveis de serem expressas e analisadas pela geometria
   euclideana. Atraves de estudos sobre a auto-similaridade e irregularidade,
PA Mandelbrot [Mandelbrot, 1977] introduziu a geometria fractal, que apresentou uma
   nova maneira de considerar tais formas. Atraves da geometria fractal, um grande
   numero de objetos naturais, que vao de neuronios a nuvens, pode ser modelado e
   melhor compreendido. A Figura 7.45 apresenta dois exemplos de fractais, onde o
   primeiro e o triangulo de Sierpinski [Stanley, 1986] e o segundo uma forma de
   Mandrelbrot [Mandelbrot, 1983].
   A ideia de dimensao fractal surgiu na tentativa de se determinar uma medida
   de complexidade para formas como as da Figura 7.45. Embora inicialmente
   dedicado a geometria fractal, o conceito da dimensao fractal rapidamente se
   espalhou, permitindo sua aplicacoes em diversas areas tais como: ciencia dos
   materiais, geologia, visao computacional [Biswas et al., 1998], neuromorfologia
   [Costa,1996][Coelho, 1998], etc.
   Diversas tecnicas para estimar a dimensao fractal foram descritas na
   literatura [Caserta et al., 1995] [Clark, 1986] [Kaye, 1989] [Kaye, 1994] [Smith et al.,
   1996], das quais a mais popular para processamento de imagens e provavelmente
   299
   CAPITULO 7
   tambem a mais simples e a de contagem de caixas [Peitgen & Saupe, 1988]
   [Falconer, 1990].
   (a)
   (b)
   Fig. - 7.45 - Dois exemplos de fractais, triangulo de Sierpinski (a) e Mandelbrot
   (b).
   Vamos nos limitar ao metodo de salsichas de Minkowski [Tricot, 1995]. O
   metodo para calculo da dimensao fractal conhecido como de salsichas de
   Minkowski, produz uma estimativa da dimensao de Bouligand-Minkowski [Coelho,
   1998]. A tecnica essencialmente se baseia na convolucao de circulos com
   diferentes raios r na imagem. Com o resultado da convolucao de cada circulo,
   calcula-se a area A ocupada pelos pixels significantes (nao nulos). Projetam-se
   entao os pontos obtidos pelos pares r e Ar em um grafico log(r) x log(A).
   Usualmente os pontos irao caracterizar uma reta, que pode ser determinada
   atraves de regressao linear. A dimensao fractal e obtida pela inclinacao desta reta.
   A paralelizacao da tecnica e bastante simples, uma vez que nao ocorre a
   dependencia de dados durante a concorrencia, e pode ser implementado
   diretamente com o componente Processor Farm do CVMP, simplificando muito a
   sua implementacao (ver 6.8). Deste modo, atraves do CVMP, define-se uma
   arquitetura Processor Farm. O processo mestre distribui uma copia da imagem para
   todos os escravos, e a seguir distribui para cada processo escravo uma tarefa,
   enviando um determinado valor de raio r. A tarefa se constitui na convolucao de um
   circulo de raio r (determinado pelo mestre) e na determinacao da area do resultado
   Ar, que e enviada para o mestre assim que calculada. O mestre supervisiona o
   conjunto de escravos e, a medida que as tarefas vao sendo executadas, novas sao
   300
   ESTUDOS DE ALGORITMOS PARALELOS PARA VISAO
   atribuidas aos escravos desocupados, ate que sejam calculados todos os Ar,
   definidos pelo numero de raios determinados pelo mestre. Assim que todos os
   resultados sao obtidos, o mestre realiza a regressao linear dos pontos ( r,Ar) em
   log(r) x log (A) e inclinacao da reta obtida finalmente determina a dimensao fractal
   da imagem.
   Uma das vantagens da utilizacao dessa abordagem e o balanceamento de
PA carga automatico, possibilitando a utilizacao de um conjunto heterogeneo de
   elementos de processamento sem a necessidade de realizar qualquer alteracao na
   implementacao. Para explorar essa versatilidade, implementamos a tecnica em um
   sistema distribuido em rede de padrao ethernet de 10 Mb/s, com 4 maquinas
   baseadas no processador AMD K6 II com frequencias distintas: 200, 250, 300 e 375
   MHz. Na maquina mais veloz 375 MHz, foi alojado o processo mestre e um
   escravo.
   Utilizamos como metodo para a convolucao, a multiplicacao do disco com a
   imagem no dominio da frequencia de Fourier [Brigham, 1988]. Deste modo, o
   processo de convolucao se caracteriza basicamente pela FFT da imagem e do
   disco, o produto complexo de seus dominios complexos, e sua FFT inversa,
   constituindo o resultado da operacao de convolucao.
   Realizamos o experimento para uma imagem binaria de 512x512 pixels. O
   numero de discos utilizados foi de 32, com raios variando em 2. A Figura 7.46
   apresenta o diagrama de execucao, obtido atraves das ferramentas de estatistica
   do CVMP. Devido ao pequeno fluxo de dados nas trocas de mensagens em rede, o
   sistema possui uma otima performance (observe a pequena quantidade de bolhas).
   Uma prova da excelente performance esta no fato de que o sistema paralelo com
   quatro maquinas heterogeneas (200 MHz, 250 MHz, 300 MHz e 375 MHz) e
   aproximadamente 2,7 vezes mais rapido que a versao sequencial executada na
   maquina mais veloz (375Mhz).
   301
   CAPITULO 7
   Fig. - 7.46 - Diagrama de execucao para 4 maquinas.
   O CVMP Processor Farm pode ser utilizado em muitas outras aplicacoes de
   processamento de imagens e visao computacional. Os problemas de multi-escala
   [Cesar, 1997], especificamente os bidimensionais, possuem uma metodologia de
   implementacao identica a dimensao fractal de Minkowski descrita nesta secao,
   bastando apenas substituir no processo de convolucao os discos de raio variado
   por gaussianas com diferentes desvios padrao.
   302
   CAPITULO
   8
   APLICACOES PARALELAS
   EM VISAO
   "Never trust a computer you can't throw out a window."
   Steve Wozniak
   303
   CAPITULO 8
   304
   APLICACOES PARALELAS EM VISAO
   CAPITULO 8 - APLICACOES PARALELAS
   EM VISAO
   8.1 - INTRODUCAO
   No capitulo anterior vimos algumas estrategias de paralelismo e
   implementacoes de metodos para visao computacional e processamento de
   imagens. Neste capitulo iremos apresentar 3 aplicacoes ineditas desenvolvidas no
   CVRG. A primeira a ser discutida e um prototipo do Cyvis-1, que utiliza o
   paralelismo como ferramenta de integracao de informacoes, neste caso os atributos
   visuais cor e estereo. Como segunda aplicacao temos um experimento do projeto
PA ynergos, na qual, atraves de psicofisica, e desenvolvido um modelo matematico
   para complexidade de imagens, baseado no padrao da percepcao humana.
   Finalizamos o capitulo apresentando o projeto TreeVis, um sistema paralelo de
   reconhecimento de plantas arboreas.
   8.2 - INTEGRACAO DE COR E ESTEREO NO PROJETO
   CYVIS-1
   Podemos caracterizar a computacao paralela como uma ciencia cujo
   objetivo fundamental, senao unico, e a performance. Deste modo, seu emprego
   dentro da tematica da visao artificial seria o desenvolvimento de estrategias e
   arquiteturas para reduzir o tempo de execucao dos algoritmos e metodos
   envolvidos nesta atividade. A natureza, entretanto, adota o paralelismo de modo
   versatil. Conforme discutimos no Capitulo 4, alem de ser fundamental para o
   desempenho do processamento de informacoes nos sistemas biologicos, realizado
   por um conjunto de estrategias de paralelizacao de massa e multinivel (4.7), a
   natureza encontrou tambem no paralelismo a chave vital para seus mecanismos de
   integracao de informacoes, atraves da qual desenvolve um papel fundamental na
   integracao dos atributos visuais, modularizados no cortex visual [Zeki, 1993].
   Uma das bases do sistema de visao artificial Cyvis-1, apresentado no
   305
   CAPITULO 8
   Capitulo 5, e o modelo de especializacao funcional do cortex visual dos primatas,
   proposto por Zeki e Ship [Zeki & Shipp, 1988]. Segundo este modelo, o sistema
   visual e organizado em modulos independentes, onde cada modulo e responsavel
   pelo processamento especializado de um atributo visual. Durante o processamento
   das informacoes, cada modulo pode permutar informacoes com outros modulos,
   ocorrendo a colaboracao entre os diferentes atributos visuais. Esta abordagem
   caracteriza a integracao de multiplos estagios (Secao 5.2.1.8), que conta como
   principio basico a integracao dos atributos visuais.
   Diferentemente de todas as abordagens de paralelismo apresentadas nesta
   tese, onde, de forma tradicional, o paralelismo atuou como uma ferramenta de
   performance, iremos apresentar nesta secao uma proposta de integracao entre
   atributos visuais, na qual o CVMP e utilizado para exercer a integracao, atraves da
   troca de informacoes. A forma como os atributos visuais distintos podem cooperar
   para atingir um determinado objetivo, embora ainda seja uma lacuna dentro da
   visao artificial, constitui uma das colunas fundamentais do projeto Cyvis-1. Deste
   modo estaremos apresentando o primeiro passo desse projeto, onde temos um
   sistema de visao artificial baseado na integracao das informacoes provenientes de
   atributos visuais distintos, no caso: cor e estereo.
   Os atributos sao especificados no sistema como modulos ou subsistemas,
   possuindo cada um sua propria meta de resultados. O modulo cor e responsavel
   pela segmentacao das imagens adquiridas pelo sistema, fornecendo informacoes
   referentes as regioes e suas bordas, enquanto o modulo estereo utiliza as
   informacoes providas pelo atributo cor para determinar uma representacao mais
   abstrata da cena. Assim, o sistema representa os objetos nao apenas a partir das
   informacoes de regioes e bordas (2D), mas tambem da informacao de
   profundidade, caracterizando a reproducao da estrutura dos objetos de forma
   tridimensional.
   O sistema proposto foi desenvolvido com o intuito de realizar o
   reconhecimento de objetos poliedricos. Um dos modulos do sistema e responsavel
   pela identificacao dos objetos (cubos e piramides).
PA Conforme ja comentamos, uma das caracteristicas do projeto Cyvis-1 e o
   trabalho cooperativo entre diversos pesquisadores. Alem de prover o paralelismo de
   forma simples, eliminando a restricao de que somente especialistas em
   computacao paralela sejam capazes de desenvolver aplicacoes paralelas, permite
   que os demais pesquisadores tambem possam implementar sistemas paralelos,
   306
   APLICACOES PARALELAS EM VISAO
   mesmo que sejam complexos. O CVMP atua, ainda, como uma ferramenta de
   integracao entre os pesquisadores, que podem desenvolver modulos em maquinas
   individuais que se conectam e integram formando o sistema como um todo.
   Podendo ser definido como o primeiro prototipo do Cvyis-1, o sistema de
   integracao entre cor e estereo apresentado neste capitulo foi desenvolvido pelo
   trabalho cooperativo de tres doutorandos do Grupo de Visao Cibernetica. Alan
   Salvany Felinto [Moreira et al., 1999] foi responsavel pela implementacao do
   modulo de estereo e Jander Moreira [Moreira, 1999] pelo modulo de cor. A
   participacao do autor, alem do CVMP, base de desenvolvimento paralelo do
   sistema, envolveu a colaboracao no planejamento e estruturacao do sistema.
   8.2.1 - ESTRUTURACAO DO SISTEMA
   Embora, o projeto Cyvis-1 incorpore diversos atributos visuais, assim como
   uma serie de sofisticados recursos de visao (conforme discutido no Capitulo 5), seu
   primeiro prototipo e bastante limitado, baseando-se essencialmente na integracao
   entre os atributos de cor e estereo. A integracao entre os atributos conforme
   idealizada no Cyvis-1, requer a colaboracao em diversos niveis hierarquicos de
   processamento, alem de permitir tambem que o processamento percorra o caminho
   de execucao em ambos os sentidos ( top-down e botton-up) de forma a permitir a
   utilizacao de informacoes de alto nivel. A integracao entre os atributos e uma tarefa
   dificil e pouco explorada. Deste modo, o primeiro prototipo, embora apresente a
   execucao em apenas um unico sentido ( botton-up) e um limitado mecanismo de
   integracao, que ocorre em apenas uma etapa hierarquica, constitui um importante
   passo para os estudos dos mecanismos de integracao entre os atributos e,
   consequentemente, para o projeto Cyvis-1.
   O sistema cor/estereo, cuja estrutura basica e mostrada pelo diagrama de
   blocos da Figura 8.1, e composto por seis modulos, ou subsistemas: aquisicao de
   imagens, segmentacao por cor, analise de formas, reconhecimento de objetos e
   controle geral. O sistema foi implementado com padroes distribuidos, utilizado de
   forma que cada um dos modulos pode ser alojado em uma maquina distinta. O
   CVMP e responsavel pela conexao e troca de mensagens entre os modulos.
   307
   CAPITULO 8
   Cor
   Estereo
   Aquisicao
   Controle geral
   Base de dados
   dos modelos
   Analise de
   Reconhecimento
   formas
   de objetos
   Fig. - 8.1 - Sistema de integracao entre cor e estereo, segundo sua estrutura
PA modular [Moreira, 1999].
   8.2.1.1 - MODULO DE AQUISICAO
   A aquisicao de imagens e realizada atraves de duas cameras digitais (CCD).
   As imagens sao adquiridas em pares, com as cameras posicionadas a uma
   distancia conhecida, sem convergencia, ou seja, os eixos de captura sao paralelos.
   O modulo de aquisicao e independente e autonomo, alojado em uma maquina que
   possui dispositivo para aquisicao de imagens.
   Quanto ao seu funcionamento, o modulo fica aguardando mensagens de
   outros modulos, solicitando servicos. Toda vez que o modulo recebe uma
   solicitacao, e realizada a aquisicao das imagens, transmitidas para o modulo
   solicitante na forma de mapas de bits. Ao final do processo, o modulo envia uma
   mensagem indicando ao modulo solicitante que o servico foi efetuado com exito e
   volta ao estado de espera.
   8.2.1.2 - MODULO DE COR
   O modulo de cor e responsavel pela segmentacao de uma das imagens do
   par estereo. A tecnica utilizada e conhecida como mapa auto-organizavel. Trata-se
   de uma tecnica baseada em redes neurais, consistindo na segmentacao das
   imagens atraves de regioes, formadas por agrupamentos de pixels. A tecnica e
   descrita em detalhes por Moreira em sua tese de doutorado [Moreira, 1999]. No
   sistema as duas imagens (esquerda e direita do par estereo) sao utilizadas para o
   treinamento do mapa auto-organizavel. Apos a convergencia da tecnica, sao
   308
   APLICACOES PARALELAS EM VISAO
   obtidas as classes identificadas, que segmentam a imagem em regioes. Com base
   nas regioes, sao determinadas as fronteiras, gerando seu mapa de bordas. A
   segmentacao ocorre em apenas uma das imagens, uma vez que as informacoes
   detectaveis nesse nivel sao irrelevantes para o modulo de estereo.
   8.2.1.3 - ANALISE DE FORMAS
   A analise de formas e baseada na deteccao das retas do mapa de bordas,
   uma vez que os objetos poliedricos podem ser modelados a partir das retas que
   constituem suas arestas. A deteccao de retas e feita a partir da transformada de
   Hough, discutida na Secao 7.5. A partir dela, sao encontradas as retas que passam
   sobre os pontos colineares da imagem. Conforme vimos nas Secoes 7.5 e 7.5.1, na
   transformada de Hough as retas detectadas sao representadas como picos no
   espaco de Hough. No entanto, os pontos colineares e ruidos na imagem geram um
   grande numero picos, tornando praticamente impossivel a obtencao somente das
   retas de interesse. Para solucionar este problema, foi introduzido o backmapping ou
   rastreamento, uma tecnica complementar para solucionar esse problema.
   Atraves da combinacao entre a transformada de Hough e do backmapping,
   o modulo de analise obtem as retas da imagem, na tentativa de localizar as arestas
   dos objetos. Entretanto, o modulo analise de formas necessita nao apenas
   conhecer a equacao das retas da imagem, mas tambem determinar seus
   segmentos, ou seja, a posicao onde as retas comecam e terminam. Para
   determinar os segmentos de retas, foi utilizada uma tecnica proposta por Costa &
   Sandler [Costa & Sandler, 1993], a qual permitem obter os segmentos de reta
   mediante o resultado do backmapping, e eliminar as retas consecutivas e
   coincidentes. Assim e realizada a analise de formas, que consiste na determinacao
   dos segmentos de retas contidos no mapa de bordas.
   8.2.1.4 - ESTEREO
   O modulo de estereo efetua o calculo de profundidade para cada uma das
PA extremidades dos segmentos de retas determinados pelo modulo de analise de
   formas. O calculo de profundidade e realizado a partir das disparidades localizadas
   entre os dois pares de imagem adquiridos pelo sistema. A disparidade e
   determinada a partir dos pontos conjugados ou de correspondencia. Os pontos
   309
   CAPITULO 8
   conjugados sao pares de coordenadas (uma coordenada para cada imagem do par
   estereo) relacionadas ao mesmo ponto fisico da cena na qual foi realizada a
   aquisicao pelo par de cameras [Shirai, 1987].
   Dentre os diversos metodos para determinar os pontos conjugados
   (correlacao, diferencas quadraticas minimas, transformadas de Gabor, entre outros
   [Theimer & Mallot, 1994] [Faugeras, 1996] [Qian, 1997]), foi adotado para a
   implementacao do modulo de estereo o metodo das janelas quadradas. Nessa
   abordagem, dado um ponto em uma imagem, e centrada uma janela quadrada com
   um tamanho determinado. A busca do ponto conjugado consiste na localizacao da
   janela correspondente, a outra imagem do par estereo. A similaridade e
   determinada pelo conteudo das janelas. Para solucionar algumas ambiguidades, e
   realizada a mudanca sistematica do tamanho das janelas, conforme indicado por
   Shirai [Shirai, 1987]. A comparacao entre as janelas e realizada apenas nas regioes
   determinadas pela linha epipolar, calculada atraves da geometria das cameras,
   determina a regiao provavel do ponto conjugado. A calibracao das cameras do
   sistema foi realizada mediante os procedimentos propostos por Tsai [Tsai, 1987].
   8.2.1.5 - RECONHECIMENTO DE OBJETOS
   O universo de objetos para qual o sistema foi proposto e constituido de 3
   entidades: cubo, tetraedro e prisma (ver Figura 8.2). Cada um dos objetos e
   construido em aluminio, apresentando dimensoes conhecidas, onde cada face
   possui uma cor uniforme distinta, que permite a segmentacao por regiao cromatica.
   O sistema foi idealizado a fim de identificar os objetos tridimensionais, sob qualquer
   posicao na cena, sendo tolerante a rotacao e translacao dos objetos no espaco.
   Fig. - 8.2 - Modelo de arestas dos objetos que constituem o universo de
   reconhecimento do sistema (cubo, tetraedro e prisma).
   O modulo de reconhecimento faz uso de uma base de dados contendo os
   modelos dos objetos, que correspondem a um conjunto de segmentos de retas
   310
   APLICACOES PARALELAS EM VISAO
   contendo extremidades especificadas por coordenadas tridimensionais. O sistema
   de busca e reconhecimento e realizado mediante a comparacao dos modelos da
   base de dados frente as informacoes extraidas da cena. A identificacao do objeto
   se faz atraves de uma verificacao exaustiva, que visa emparelhar o modelo da cena
   com o da base de dados. As escalas das descricoes dos objetos nao sao
   consideradas, uma vez que ocorre a normalizacao dos segmentos antes do inicio
   da comparacao. O emparelhamento e realizado mediante rotacoes e translacoes do
   modelo da base, a fim de possibilitar a identificacao dos objetos tridimensionais
   para qualquer posicionamento espacial. Para cada emparelhamento, um erro geral
   e calculado, o qual sera descrito na Secao 8.2.3. Com base nesse calculo e
   realizado o reconhecimento do objeto.
   Fig. - 8.3 - Exemplos de cenas reais, nas quais o sistema realizou a
   identificacao dos objetos [Moreira, 1999].
   A cena na qual os objetos sao posicionados e real, contendo em muitas
   situacoes um grande numero de segmentos de retas detectaveis que nao
PA pertencem aos objetos (fundo de cena), ou ainda pertencentes a outros objetos
   posicionados na cena, que nao fazem parte do universo de reconhecimento. Podem
   ocorrer ainda situacoes em que surgem alguns segmentos de retas pertencentes
   aos objetos de reconhecimento, que nao satisfazem o modelo de reconhecimento
   poliedrico. Atraves de comparacoes com o modelo e limites de erro, o sistema
   elimina as informacoes indesejaveis, desconsiderando-as, permitindo assim a
   criacao de um modelo poliedrico e o reconhecimento de objetos em cenas reais e
   complexas. A Figura 8.3 apresenta algumas imagens adquiridas pelo sistema, na
   311
   CAPITULO 8
   qual podemos observar a complexidade da cena.
   8.2.1.6 - CONTROLE GERAL
   O modulo controle geral e responsavel pela supervisao dos demais
   modulos, assim como pelo controle do fluxo de informacoes. Toda a comunicacao
   entre modulos e realizada pelo controle central. Conforme podemos observar na
   Figura 8.1, nao existe conexao entre modulos que nao passem pelo controle
   central. Todas as decisoes, sequencias de operacoes, ciclo de execucao e controle
   de dependencia de dados do sistema sao realizados sob a sua determinacao, de
   modo que os demais modulos podem ser considerados como escravos ao seu
   comando. Deste modo o controle central promove a hierarquia e integracao dos
   modulos que compoem o sistema.
   8.2.2 - CRITERIO DE AVALIACAO
   Nesta secao vamos descrever o criterio de avaliacao utilizado para a
   realizacao do reconhecimento dos objetos. Implementado no modulo de
   reconhecimento, o criterio de avaliacao realiza a comparacao entre o modelo do
   objeto, ou seja, o modelo retirado das imagens adquiridas pelos sistemas e o
   modelo da base de dados. O reconhecimento ocorre quando a discrepancia entre
   os modelos, determinada pelo calculo de erro, e a menor dentre as comparacoes
   com os modelos da base ou ainda se o erro for menor que um determinado limite
   pre-estipulado. O calculo do erro e estabelecido pelo erro medio quadratico entre as
   distancias das extremidades correspondentes de todos os segmentos
   emparelhados do modelo do objeto da imagem e da base de dados. A Equacao 8.1
   apresenta o calculo de erro, onde N indica o numero de extremidades de
   segmentos, moi e mbi representam os pontos conjugados no espaco do modelo
   objeto da imagem e do modelo da base, respectivamente, e D( ) e a funcao de
   distancia euclidiana.
   N
   1
   =
   D( mo , mb 2
   )
   (8.1)
   q
   [
   i
   i ]
   N i=1
   Embora o calculo do erro estabeleca uma metodologia objetiva de
   comparacao entre os modelos, existem algumas situacoes em que o calculo do erro
   312
PA APLICACOES PARALELAS EM VISAO
   nao e capaz de reconhecer os objetos com precisao, sendo necessario adicionar
   outras consideracoes ao criterio de avaliacao. Uma dessas situacoes ocorre devido
   a similaridade entre os objetos do universo de classificacao. Como podemos
   observar na Figura 8.2, tanto o tetraedro como o prisma podem ser consideradas
   como objetos poliedricos formados a partir de cortes planares em cubos. Se
   tomarmos um cubo e fizermos um corte por um plano que passa por arestas
   opostas, teremos como resultado um prisma, assim como se o plano passar por
   tres vertices nao compartilhados pela mesma face e que nao contenha uma
   diagonal, teremos um tetraedro.
   Deste modo se o analisador de formas detectar somente tres segmentos de
   reta, conforme apresentado na Figura 8.4, e se utilizarmos esse modelo
   diretamente no emparelhamento e testarmos a seguir o criterio de avaliacao atraves
   do calculo de erro, podem ocorrer falsos reconhecimentos devido a similaridade
   entre os vertices. Nesta situacao, o erro medio quadratico q seria muito proximo,
   praticamente identico, impossibilitando um reconhecimento eficaz.
   Fig. - 8.4 - Modelo de arestas dos objetos que constituem o universo de
   reconhecimento do sistema (cubo, tetraedro e prisma).
   Para solucionar este problema, foi introduzida uma semantica na qual e
   ponderado o numero de segmentos detectados como peso adicional ao criterio de
   avaliacao. Deste modo, e considerado o numero total de arestas visiveis ao inves
   do total de arestas. O numero total de arestas visiveis para os poliedros que
   constituem o universo de reconhecimento e de 9, 6 e 8 respectivamente para o
   cubo, tetraedro e prisma.
   N
   N
   v
   o
   = k
   (8.2)
   e
   Nv
   Com base nesse novo contexto, foi introduzido o erro relativo ao
   313
   CAPITULO 8
   emparelhamento de bordas, conforme indicado na Equacao 8.2, onde Nv e No
   indicam, respectivamente, o numero de arestas visiveis do modelo e o numero de
   arestas (segmentos) da imagem que foram emparelhados. O fator k e um fator de
   correcao da magnitude do erro, para que tenha a mesma variacao maxima que o
   erro quadratico medio q. O erro e estabelece a razao entre a falha no
   emparelhamento esperado (numero de arestas visiveis nao relacionadas a arestas
   da imagem) e a expectativa inicial (numero de arestas visiveis).
   = h + 1
   (
   h)
   (8.3)
   q
   e
   O erro total, definido pela Equacao 8.3, consiste na ponderacao entre os
   erros q e e, atraves do parametro h. O erro permite a distincao entre os modelos
PA de objetos da base de dados e o modelo do objeto das imagens a ser reconhecido,
   caracterizando desse modo o criterio de avaliacao do modulo de reconhecimento
   de objetos.
   8.2.3 - FUNCIONAMENTO GERAL E RESULTADOS
   O sistema e constituido de 6 modulos autonomos e independentes,
   distribuidos pelas maquinas que compoe a rede. Usualmente, uma maquina aloja
   mais de um modulo. Nos experimentos realizados no laboratorio utilizou-se
   geralmente tres maquinas compor o sistema. Nesta configuracao uma das
   maquinas aloja somente o modulo de aquisicao, o qual necessita de hardware
   especial (aquisicao de imagens), enquanto que os modulos de cor, forma e controle
   partilham a segunda maquina e os demais modulos, ou seja, estereo e
   reconhecimento, utilizam a maquina restante.
   Embora o sistema apresente arquitetura e estrutura paralela, havendo
   autonomia e independencia entre os modulos que o compoe, o paralelismo foi
   utilizado para integracao, nao tendo sido especificamente exploradas as
   possibilidades de aumento de performance. Deste modo, o sistema apresenta uma
   cadeia de execucao sequencial. Supervisionados pelo controle geral, os modulos
   vao sendo executados um apos o outro seguindo um determinado fluxo de
   314
   APLICACOES PARALELAS EM VISAO
   execucao. O ciclo inicia-se com a aquisicao dos pares de imagem. Para isso o
   modulo de controle solicita ao modulo de aquisicao que cumpra sua tarefa
   preestabelecida, ou seja, efetuar a aquisicao do par de imagens atraves das duas
   cameras do sistema.
   Uma vez realizada a aquisicao das imagens, o controle central solicita ao
   modulo cor que realize a segmentacao de uma das imagens do par estereo. Como
   resultado da segmentacao por cor e produzido um mapa de bordas da imagem,
   atraves da classificacao da imagem pelo metodo dos mapas auto-organizaveis
   [Moreira, 1999]. Para as configuracoes dos mapas auto-organizaveis foi adotado:
   mapas de dimensoes 32x32, vizinhanca circular inicial com raio de 25,6
   (equivalente a 80% da dimensao do mapa), taxa de aprendizado inicial de 60%,
   taxas de decaimento de 0,05% para o aprendizado e para o raio da vizinhanca e foi
   adotado um erro de 10-4 estipulado para a verificacao da convergencia [Moreira,
   1999]. A Figura 8.5 apresenta os resultados de segmentacao do modulo cor, em
   comparacao com classico metodo de gradiente Sobel [Sobel, 1970], nela temos
   uma das imagens do par estereo, adquirido pelo sistema (esquerda), com o
   respectivo resultado de segmentacao pelo metodo dos mapas auto-organizaveis
   (centro) e Sobel (direita).
   (a)
   (b)
   (c)
   Fig. - 8.5 - Exemplos de segmentacao do modulo cor. (a) Imagem direita do
   par estereo, adquirida pelo modulo de aquisicao. (b) Resultado da
   segmentacao do modulo cor (Mapas auto-organizaveis). (c) Segmentacao por
   Sobel com finalidade comparativa.
   Uma vez gerado o mapa de bordas pela segmentacao do modulo de cor, o
   315
   CAPITULO 8
   modulo de controle envia uma mensagem para o modulo de analise de formas,
   para este que o processe. Baseado na transformada de Hough e backmapping, o
PA modulo de analise de formas tem como funcao extrair os segmentos de retas da
   imagem. A Figura 8.6 contem os segmentos detectados para uma mesma cena,
   sob diferentes pontos de vista.
   Fig. - 8.6 - Segmentos de retas detectados em diferentes pontos de vistas de
   uma mesma cena (figura a esquerda).
   A proxima etapa do ciclo de execucao do sistema e a tarefa do modulo
   estereo. Finalizada a analise de formas, o modulo de controle geral solicita que o
   modulo estereo inicie o processamento, que consiste basicamente na determinacao
   da profundidade das extremidades dos segmentos de reta detectados. Atraves das
   coordenadas das extremidades dos segmentos de retas, o modulo estereo localiza
   o conjugado e pelo calculo de disparidade e determinada sua profundidade. A
   determinacao da profundidade, entretanto, nao e sempre possivel, devido a fatores
   como as diferencas de perspectiva, que causam oclusoes parciais, ou introduzem
   reflexos diferenciados e a imprecisao dos segmentos, alem de reflexos nas cores e
   determinadas sombras, que acarretam em imprecisoes no mapa de bordas.
   Estas situacoes fazem com que as bordas e os segmentos detectados nao
   fiquem precisamente localizados nas posicoes reais dos objetos. Desse modo, as
   coordenadas das extremidades dos segmentos podem coincidir com o a base ou
   com o fundo da cena. Deste modo o valor da profundidade calculado se torna
   relativo ao fundo da cena ou sua base, deturpando as dimensoes e posicoes dos
   objetos de interesse. Para evitar modelos incorretos, se os pontos conjugados de
   uma das extremidades do segmento de reta nao for determinado de modo
   adequado, o segmento e excluido do modelo do objeto.
   Alem da exclusao pela falta de determinacao correta do conjugado, ocorrem
   situacoes em que os segmentos nao sao emparelhados com o modelo da base,
   sendo nestes casos tambem eliminados. Os segmentos desconsiderados dessa
   316
   APLICACOES PARALELAS EM VISAO
   forma pertenciam ao fundo da imagem, reflexos, sombras, ou outros objetos da
   imagem.
   (a)
   (b)
   (c)
   Fig. - 8.7 - Exemplos de reconhecimento de objetos. Na coluna esquerda e
   apresentada a imagem direita do par estereo e na coluna direita, o modelo
   obtido do objeto sobreposto ao modelo reconhecido do banco de dados.
   Finalizado o processamento do modulo estereo, o controle central determina
   a execucao da ultima etapa do processamento, tarefa realizada pelo modulo de
   reconhecimento, o qual compara o modelo do objeto da imagem com os modelos
   da base de dados, identificando a comparacao que apresente o menor erro
   (definido na Equacao 8.3). A Figura 8.7 apresenta tres resultados do processo de
   reconhecimento, ilustrando cada um dos objetos do universo de reconhecimento.
   Na coluna esquerda temos as imagens adquiridas pela camera direita e na coluna
   direita seus respectivos modelos (sobreposicao objeto e banco de dados).
   Para o primeiro experimento (Figura 8.7 a), o objeto utilizado foi um cubo,
   reconhecido atraves da identificacao de 6 arestas, com um erro = 7,0x10-3. No
   segundo experimento (Figura 8.7 b), o prisma foi reconhecido com um erro =
   7,4x10-3. E finalmente o tetraedro (Figura 8.7 c) foi identificado com um erro =
   317
   CAPITULO 8
PA 1,2x10-2. Experimentos similares foram realizados em cerca de 20 cenas, com
   diversas condicoes de iluminacao, fundo e quantidade de objetos diferentes, que
   diagnosticando que o sistema ainda possui um indice consideravel de
   reconhecimentos incorretos. Nos casos onde o sistema reconheceu os objetos
   corretamente, os erros apresentados oscilaram em valores proximos aos da Figura
   8.7. Maiores detalhes sobre o funcionamento do sistema, tecnicas utilizadas e
   resultados podem ser obtidos na tese de doutorado de Moreira [Moreira, 1999].
   8.2.4 - SISTEMA DISTRIBUIDO E PARALELISMO
   O sistema foi implementado em arquitetura distribuida, sobre a plataforma
   Windows/Delphi e com a ferramenta de paralelismo CVMP. Gracas a sua
   arquitetura distribuida, todos os modulos que compoe o sistema sao
   independentes, podendo ser dispostos em maquinas diferentes (conectadas por
   redes) ou ainda na mesma maquina (multitarefa). Conforme comentamos
   anteriormente, embora possua todos os requintes da arquitetura paralela, na qual
   os modulos do sistema sao autonomos, separados e independentes, o fluxo de
   execucao ocorre de forma sequencial, uma vez que o objetivo do sistema prima a
   integracao.
   Quanto ao controle, os modulos do sistema podem ser divididos em dois
   grupos: supervisor e escravos. O grupo dos escravos, e composto por todos os
   modulos com excecao do modulo de controle central. Basicamente, os modulos
   escravos podem ser considerados como sistemas independentes, que ficam
   aguardando o recebimento de ordens, atraves de troca de mensagens (CVMP).
   Uma vez recebida a tarefa, o modulo a executa de forma autonoma e
   independente, retornando o resultado do processamento, e voltando ao estado de
   vigilia, ao qual permanece ate que seja requisitada uma nova tarefa.
   O modulo supervisor do sistema e o modulo controle geral. Sua finalidade e
   supervisionar e controlar todos os demais modulos, atribuindo tarefas aos escravos,
   atraves de trocas de mensagens, recebendo as respostas e coordenando o ciclo de
   execucao do sistema. Embora essa estrutura paralela permita a execucao
   simultanea entre modulos, a concorrencia nao ocorre, parcialmente devido a
   dependencia de dados entre modulos e tambem pelo esforco generalizado do
   projeto na integracao.
   Mesmo tendo uma forte dependencia de dados entre os modulos, que
   318
   APLICACOES PARALELAS EM VISAO
   impossibilita a execucao simultanea, devido a sua arquitetura paralela e distribuida,
   pode ser facilmente incorporado ao sistema diversos aspectos de paralelismo, que
   proporcionam concorrencia e consequentemente melhoram a performance. Essas
   estrategias de paralelismo, que nao implicam grandes modificacoes no sistema,
   podem ser divididas em duas abordagens: (i) Paralelizar o processamento interno
   de cada modulo e (ii) Adaptar o sistema para processamento intermitente, e
   adicionar mecanismos de paralelismo temporal ("pipeline") entre os modulos.
   Na primeira situacao (i), os modulos do sistema, responsaveis por
   processamento de cor, estereo e analise de formas, podem ser substituidos por
   uma versao paralela. Deste modo, visto a independencia entre os modulos e sua
   autonomia, os modulos de processamento poderiam ser paralelos, possuindo dessa
   forma sub-modulos. Estes seriam alojados em diferentes maquinas, no caso do
   modelo distribuido ou em diferentes processadores, no caso de maquinas
   multiprocessadas. No caso especifico, do modulo de analise formas, a
   paralelizacao dos processamentos referentes a transformada de Hough e
PA backmapping, foram implementados via CVMP nesse trabalho, e encontram-se
   exemplificados nas Secoes 7.5 e 7.51.
   Reconhecimento
   Reconhecimento
   Estereo
   Estereo
   Estereo
   Forma
   Forma
   Forma
   Forma
   Cor
   Cor
   Cor
   Cor
   Cor
   Aquisicao
   Aquisicao
   Aquisicao
   Aquisicao
   Aquisicao
   tempo
   Fig. - 8.8 - Exemplo de pipeline de 5 estagios entre os modulos do sistema
   (aquisicao, cor, forma, estereo e reconhecimento).
   Na segunda abordagem (ii) e proposta a adicao de paralelismo temporal ao
   sistema, na forma de pipeline entre os modulos. Para essa abordagem o sistema
   deveria funcionar em intermitencia, ou seja, estar sempre adquirindo, processando
   e analisando as imagens provenientes das cameras. Nesse caso, conforme mostra
   a Figura 8.8, o sistema seria baseado em estrutura pipeline de 5 estagios, e
   enquanto a sequencia de execucao de uma cena (aquisicao do par de imagens,
   processamento de cor, processamento de formas, processamento estereo e
   reconhecimento de padroes) estivesse sendo realizada, novas sequencias ja
   319
   CAPITULO 8
   iniciariam o processamento simultaneamente.
   8.2.5 - INTEGRACAO ENTRE PESQUISADORES
   O primeiro prototipo do Cyvis-1 consolidou o CVMP como uma plataforma
   amigavel e versatil, atraves da qual pesquisadores do Grupo de Pesquisa em Visao
   Cibernetica puderam tornar paralelas suas aplicacoes, promovendo uma maior
   performance e a possibilidade de visao em tempo real. Alem de permitir a adicao ao
   contexto da visao artificial, toda a filosofia de integracao, modularidade e
   independencia, exigida pelos modelos mais complexos do cortex, em especial a
   especializacao funcional proposta por Zeki e Ship [Zeki & Shipp, 1988],
   possibilitando novos estudos cientificos nessa area.
   Neste prototipo tivemos a oportunidade e a satisfacao de trabalhar
   juntamente com dois pesquisadores do grupo, especialistas em visao e
   processamento de imagens: Jander Moreira, na epoca do projeto, doutorando
   especialista em cor, e Alan Salvany Felinto, doutorando especialista em estereo.
   Alem do desenvolvimento do primeiro prototipo do Cyvis-1, a colaboracao dos dois
   colegas foi fundamental para estudos do CVMP, tais como simplicidade de
PA utilizacao, validacao e tambem as caracteristicas de heranca (OOP) da ferramenta,
   que foram validadas atraves do desenvolvimento de um objeto herdado do Tcvmp,
   para utilizacao especifica no prototipo (ver Secao 6.6.2).
   Esse trabalho, em especial, ilustrou uma nova forma de integracao entre os
   pesquisadores no desenvolvimento de sistemas de visao, atraves da ferramenta
   CVMP. A integracao e propiciada devido a independencia e autonomia entre os
   diferentes modulos do sistema, presentes nos sistemas distribuidos ou paralelos.
   Gracas a estas caracteristicas, cada modulo se comporta como uma caixa preta,
   seguindo a mesma filosofia do conceito de programacao orientada a objetos [Cox,
   1986]. Nesse caso, os pesquisadores nao precisam conhecer os detalhes sobre a
   tecnica ou implementacao dos modulos, uma vez que basta enviar uma mensagem
   e aguardar a resposta do processamento do modulo.
   Essa abordagem facilita muito o trabalho cooperativo, uma vez que
   concentra os esforcos de cada individuo no desenvolvimento de uma parte
   especifica do sistema. A independencia e autonomia modular, aliadas ao
   alojamento distribuido de cada modulo, propiciou um ambiente de desenvolvimento
   bastante interessante no nosso laboratorio, em que cada pesquisador ficou
   320
   APLICACOES PARALELAS EM VISAO
   responsavel por uma maquina, na qual estava alojado um modulo especifico do
   sistema. Com isso, os colaboradores do projeto puderam trabalhar
   simultaneamente em maquinas distintas e, a qualquer momento, testar a integracao
   de sua parte com todo o sistema. Para isso, enquanto trabalhavam no
   desenvolvimento, os pesquisadores disponibilizaram uma versao do modulo, sendo
   executado em multitarefa em suas maquinas. Assim, tanto o modulo quanto a
   maquina poderiam ser utilizados para testes pelos outros modulos, ao mesmo
   tempo em que a maquina estava sendo utilizada para o desenvolvimento de novas
   versoes do seu respectivo modulo.
   Gracas ao ambiente de desenvolvimento e teste distribuido, foi possivel o
   trabalho cooperativo e simultaneo para a implementacao do primeiro prototipo do
   projeto Cyvis-1, que exemplificou nao apenas a utilizacao do paralelismo para a
   integracao de atributos visuais em sistemas de visao artificial, mas tambem a
   integracao e harmonizacao do trabalho de pesquisa de pesquisadores do Grupo de
   Pesquisa em Visao Cibernetica.
   8.3 - YNERGOS - INVESTIGACAO DA PERCEPCAO
   HUMANA NA COMPLEXIDADE DAS FORMAS
   No Capitulo 5 discutimos o projeto ynergos, um sistema baseado na
   sinergia, conceito atraves do qual a associacao simultanea de diversos fatores
   contribuem para uma acao coordenada, cujo objetivo fundamental e a
   implementacao de um poderoso e versatil laboratorio de visao computacional, para
   auxiliar o desenvolvimento e a validacao de tecnicas, sistemas e experimentos em
   visao. Nesta secao, vamos apresentar um experimento psicofisico realizado atraves
   do projeto ynergos, no qual diversos paradigmas, em especial Internet, sistemas
   distribuidos, computacao paralela, inteligencia artificial e visao biologica, sao
   utilizados de forma integrada para investigar a percepcao humana na complexidade
   das formas e com base nessa investigacao, desenvolver um modelo
   matematico/computacional dessa sensacao humana [Bruno et al., 2000].
   8.3.1 - O EXPERIMENTO PSICOFISICO
   A percepcao visual humana envolve processos altamente complexos e nao
   321
PA CAPITULO 8
   lineares, organizados em uma estrutura hierarquica [Marr, 1982] [Zeki, 1993], se
   inicia com a conversao do sinal fisico (luz) em estimulo nervoso e termina com sua
   completa caracterizacao e descricao (sensacao do estimulo). Deste modo, para
   cada estimulo fisico em uma dada modalidade sensitiva, sera criada uma
   percepcao correspondente, a qual na maioria das vezes obedece a uma
   dependencia nao linear. Em psicofisica, esse tipo de correspondencia pode ser
   caracterizado e modelado em termos da lei de Fechner, dada pela Equacao 8.4,
   onde c e uma constante proporcional, P e a intensidade do estimulo fisico e S e a
   magnitude subjetiva [Barlow & Mol om, 1982].
   S = c Log P
   (8.4)
   Para investigar como os parametros da lei de Fechner podem se relacionar
   com a percepcao humana na complexidade das formas, planejamos um
   experimento que consiste em apresentar uma serie de imagens para um individuo,
   que avaliara a imagem atribuindo-lhe uma nota de 1 a 10. Para que o experimento
   se torne estatisticamente representativo, um grande numero de imagens deve ser
   considerado, com a natureza mais divergente possivel (ex: fotografia de um
   escritorio, fotografia de um elefante, etc.).
   Uma fonte de imagens vasta e bastante variada e a propria Internet. Atraves
   do modulo de Internet e do WebWorm, que sera discutido mais adiante, o ynergos
   e capaz de montar uma base de dados de imagens variadas, que sao organizadas
   e apresentadas ao espectador para a realizacao do experimento. Os resultados
   obtidos podem ser entao comparados com funcoes definidas por valores medidos.
   Nesse trabalho optou-se por duas funcoes: (i) combinacoes lineares das
   caracteristicas, dada pela Equacao 8.5 e (i ) combinacoes lineares do logaritmo das
   caracteristicas (devido a lei de Fechner), expressa na Equacao 8.6. O fator de
   influencia, determinado pelo parametro bias e necessario para possibilitar eventuais
   deslocamentos do hiperplano definido pela funcao de suas coordenadas de origem,
   caso seja preciso.
   N f
   S
   =
   a f + bias
   (8.5)
   C 1
   ,
   i i
   i=1
   N f
   S
   =
   a log
   +
   (8.6)
   C,2
   i
   ( fi ) bias
   i=1
   322
PA APLICACOES PARALELAS EM VISAO
   Os resultados obtidos pela analise humana sao entao relacionados com os
   resultados obtidos atraves da analise de complexidade de alguns metodos
   computacionais, os quais serao discutidos a seguir. Desta forma, e determinada a
   combinacao linear, que ditara o modelo computacional mais proximo do
   comportamento humano.
   Em termos computacionais, boas aproximacoes para as combinacoes
   lineares sao aquelas que apresentem o menor numero de fatores possivel. Uma
   aplicacao direta para essa consideracao seria a possibilidade de utilizacao dos
   modelos em tempo real, onde, quanto menor o numero de fatores considerados,
   menores serao os recursos computacionais requeridos e consequentemente, mais
   rapido sera o sistema.
   8.3.2 - WEBWORM
   A construcao do banco de imagens e realizada atraves de uma coleta de
   imagens dos mais variados assuntos, extraidas da Internet. Deste modo, coletando
   imagens ao acaso pela Internet estaremos garantindo que as imagens
   apresentadas no experimento psicofisico possuirao natureza amplamente variada,
   nao apresentando caracteristicas em comum (que poderiam ocorrer caso as
   imagens fossem recolhidas de algum banco de dados especifico e obtidas por
   alguma pessoa ou grupo de pessoas). Para permitir a aquisicao das imagens foi
   desenvolvido um aplicativo, incorporado ao modulo Internet do ynergos, o qual
   denominamos de WebWorm, cujo funcionamento basico consiste em acessar
   paginas HTML e trazer as imagens.
   O WebWorm e uma aplicacao desenvolvida em Delphi, que atraves de
   sockets (winsock) [Dumas, 1995], se conecta com o porto 80 (servidor Web)
   atraves das maquinas pela Internet, estabelecendo comunicacao com os servidores
   WWW. O WebWorm opera um navegador Netscape, atraves do mecanismo
   sendkey do Windows, fazendo com que o Netscape abra as paginas HTML
   requisitadas.
   323
   CAPITULO 8
   INTERNET
   Netscape
   Web Worm
   ynergos
   Netscape
   Cache
   Fig. - 8.9 - Diagrama apresentado as interacoes do WebWorm.
   A Figura 8.9 apresenta um diagrama esquematico contendo sua estrutura de
   funcionamento. Apos carregar uma pagina HTML, o WebWorm analisa o codigo e
   monta duas listas, a primeira, denominada de lista de espera, contendo os
   ponteiros para outras paginas HTML e a outra com as imagens do documento
   HTML. Feito isso, o aplicativo apaga todos os arquivos do diretorio cache do
   Netscape e solicita a este que a pagina em questao seja carregada. Uma vez que a
   pagina e todas as suas imagens (arquivos GIF, JPEG, BMP e etc.) sao carregadas,
   o WebWorm, transfere as imagens (.JPG) do diretorio cache do Netscape para um
   diretorio de entrada de imagens do ynergos.
   O processo e repetido para todas as paginas na lista de espera, de modo
   que o WebWorm e capaz de percorrer automaticamente todas as paginas
   apontadas por um determinado sitio ( site), podendo deste modo percorrer milhares
PA de paginas. Esse processo e encerrado quando um determinado nivel de
   profundidade de acesso foi alcancado. A Figura 8.10 ilustra um exemplo do
   processo de navegacao. Nesse caso a pagina inicial apresenta tres ponteiros
   ( hyperlinks) para tres outras paginas, que por sua vez, sao conectadas a quatro,
   tres e uma paginas respectivamente. Se o WebWorm for instruido para percorrer
   apenas um nivel de profundidade, serao carregadas apenas as imagens da pagina
   inicial; para dois niveis, as imagens das paginas correspondentes ao primeiro e
   segundo nivel e assim sucessivamente.
   Nessa abordagem nos assumimos que o WebWorm realiza uma busca cega
   na Internet, iniciada a partir de uma determinada pagina. Assim, para que se torne
   mais interessante, iniciamos a busca a partir da pagina resultante de determinada
   324
   APLICACOES PARALELAS EM VISAO
   pesquisa em um mecanismo de busca como o AltaVista ou Yahoo (com as chaves
   " photo" e " pictures").
   Pagina
   Primeiro nivel
   inicial
   Segundo nivel
   Terceiro nivel
   Fig. - 8.10 - Exemplo de navegacao do WebWorm.
   A vasta maioria das imagens utilizadas na Internet utiliza dois formatos de
   imagens: JPEG e GIF. Uma vez que as imagens GIF nao apresentam canais de
   cores reais (RGB) devido ao mecanismo de paleta (cores indexadas) incorporado
   ao formato, consideramos apenas as imagens JPEG, que em geral apresentam
   canais de cores reais (24bits - RGB), transferindo somente imagens com a
   terminacao JPG para o diretorio de entrada do ynergos. Sendo todas as imagens
   das paginas com formato JPEG consideradas, temos uma grande variedade de
   figuras utilizadas na Internet, tais como botoes, banners, texto em formato grafico,
   propaganda e outros. A tarefa de separar imagens especificas e realizada pelo
   ynergos, que analisa cada uma das imagens do diretorio de entrada, considerando
   sua dimensao, complexidade, e estrutura do histograma (imagens sinteticas sao
   caracterizadas por apresentar histogramas bem definidos), a fim de filtrar apenas as
   imagens desejadas, no caso do experimento, imagens fotograficas.
   8.3.3 - METODOS CONSIDERADOS
   Conforme mencionamos, os dados extraidos do experimento psicofisico
   deverao ser correlacionados com modelos matematicos para analisar e medir a
   complexidade das imagens. Nesse trabalho, escolhemos 4 metodos para obtencao
   de medidas de complexidade: (i) Entropia dos niveis de cinza [Gonzalez & Woods,
   1993], (ii) Tempo de decaimento multi-escala da variancia da distribuicao dos niveis
   de cinza da imagem (variancia do histograma) [Bruno et al., 2000], (iii) circularidade
   325
   CAPITULO 8
   [Bruno et al.,2000] e (iv) dimensao fractal por salsicha de Minkowski [Tricot, 1995].
   O estudo desses metodos como medidas de complexidade foi realizado atraves de
   diversos experimentos conduzidos pelo Grupo de Pesquisa em Visao Cibernetica,
   voltados particularmente para a analise morfologica de neuronios, onde a
   complexidade tem sido considerada por neurocientistas como uma importante
   caracteristica para classificar neuronios [Cesar & Costa, 1998] [Costa & Velte,
   1999] [Costa, 1996] [Coelho, 1998].
PA O conceito entropia usualmente empregado em processamento de imagens
   [Gonzalez & Woods, 1993] e baseado na distribuicao de probabilidade dos niveis
   de cinza da imagem (histograma). Dentro deste contexto, a entropia e uma medida
   de desorganizacao ou incerteza sobre a distribuicao, podendo ser empregada como
   uma forma de caracterizacao da complexidade da imagem. A natureza do metodo,
   entretanto, enfoca a complexidade sobre o ponto de vista da variacao de brilho na
   imagem, uma vez que e analisada apenas a frequencia de cada nivel de cinza e a
   distribuicao espacial dos pontos ao longo da imagem nao influencia o calculo da
   entropia.
   O tempo de decaimento da variancia multi-escala da distribuicao dos niveis
   de cinza foi escolhido devido ao seu potencial de refletir a estrutura espacial da
   imagem. Embora, assim como a medida de entropia, a variancia tambem seja
   determinada a partir da distribuicao da frequencia dos niveis de cinza da imagem, a
   condicao multi-escala engajada no tempo de decaimento faz com que seja
   incorporada a natureza da estrutura e complexidade espacial da medida.
   Uma outra medida importante, na tentativa de quantificar a complexidade de
   imagens, e a circularidade, determinada pela razao do quadrado do perimetro da
   forma por sua area. Deste modo, estima-se a circunferencia como a forma mais
   simples, e por complexas as formas que apresentam irregularidade, especialmente
   a concavidade. Finalmente a dimensao fractal, calculada nesse experimento pelo
   metodo da salsichas de Minkowski (ver Secao 7.7), tambem se caracteriza como
   uma forma classica para a quantificacao da complexidade.
   8.3.4 - O EXPERIMENTO VIA WEB
   O experimento foi disponibilizado na Internet de modo que qualquer pessoa
   do planeta possa realiza-lo. A primeira pagina do experimento do ynergos contem
   as instrucoes basicas para a sua operacao e um formulario solicitando os dados do
   326
   APLICACOES PARALELAS EM VISAO
   usuario (nome, e-mail, profissao e grau de instrucao), assim como um botao
   prosseguir. Assim que o usuario pressiona o botao o experimento e inicializado,
   conforme vamos narrar. Cada imagem do experimento e apresentada na porcao
   central da janela por um periodo fixo de tempo. Apos o seu desaparecimento e
   exibida uma janela solicitando ao usuario uma nota de 0 a 10 (atraves de uma
   interface "combo box") para indicar o seu grau de complexidade (nenhuma
   informacao sobre o conceito de complexidade e dada). Uma vez que todas as
   imagens tenham sido apresentadas e avaliadas pelo individuo, a pagina do
   experimento, que foi implementada em HTML e JavaScript, envia o resultado para
   um cgi-bin (Commom gateway interface) especial armazenado no servidor
   (experimento), que disponibiliza os dados do experimento para o ynergos. No
   mesmo instante, os dados do individuo, sua avaliacao e a media de sua avaliacao
   em relacao aos outros experimentos e apresentada.
   8.3.5 - ALGORITMO GENETICO PARALELO - ANALISE E
   MODELAGEM DOS DADOS EXPERIMENTAIS
   Os dados coletados dos experimentos psicofisicos podem ser processados
   a qualquer momento pelo ynergos, a fim de se obter um modelo matematico-
   computacional da percepcao humana da complexidade de imagens. Os resultados
   apresentados a seguir foram obtidos a partir do experimento psicofisico realizado
   por nove pessoas atraves da Internet. Para obter os coeficientes da combinacao
   linear e logaritmica das caracteristicas de complexidade extraidas das imagens
   (Subsecao 8.3.3) correlacionadas a percepcao humana, foi utilizada uma versao
PA distribuida do algoritmo genetico [Goldberg, 1989] [Bruno et al., 2000], o qual
   comentaremos a seguir.
   A computacao evolucionaria, da qual se destaca o algoritmo genetico, tem
   se tornado uma interessante alternativa para a otimizacao de problemas
   combinatorios e complexos. Os algoritmos geneticos codificam as solucoes
   potenciais de um problema especifico em uma estrutura de dados inspirada em
   cromossomos. A partir de regras de evolucao genetica inspiradas na natureza, tais
   como reproducao, mutacao, crossover, adaptacao e outras, e definido o melhor
   conjunto de parametros (individuos) que mais se adaptam (mais otimizados) a um
   determinado problema. Do ponto de vista computacional, o algoritmo genetico e
   uma tecnica custosa que, entretanto, apresenta um bom potencial de
   327
   CAPITULO 8
   implementacao paralela. Sua inspiracao se encontra na propria natureza, onde
   alem dos individuos coexistirem em paralelo, ocorre o mesmo com diversos
   ambientes e nichos.
   A versao paralela do algoritmo genetico foi implementada atraves de CVMP
   para plataforma distribuida. Devido a natureza do problema, foi adotada a
   estrategia de paralelismo processor farm. Conforme vimos no Capitulo 6, a
   estrategia processor farm, e amplamente utilizada em diversas situacoes e o CVMP
   possui um conjunto de ferramentas especificas para essa arquitetura, provendo sua
   programacao de forma visual, simplificando bastante a sua implementacao.
   Nesta concepcao, o sistema e constituido de dois conjuntos de processos:
   Mestre e Escravo. O processo mestre, e responsavel por coletar e redistribuir as
   populacoes durante a execucao, alem de gerar as populacoes iniciais e
   supervisionar os processos escravos. Ja os processos escravos sao responsaveis
   pelo processamento da evolucao das populacoes. Na abordagem adotada, o
   mestre gera uma populacao atraves de parametros aleatorios, e a distribui para os
   processos escravos. No final de um determinado numero pre-fixado de geracoes
   (especificados por um parametro de controle), sao selecionados os individuos mais
   adaptados, resultantes do processamento evolutivo de cada escravo e enviados
   para o mestre, que promove uma nova populacao baseada nesses individuos e
   redistribui para os escravos. Esse ciclo se mantem ate que a convergencia pre-
   estipulada seja atingida. A Figura 8.11 apresenta um diagrama ilustrativo sobre a
   estrategia basica de funcionamento do algoritmo genetico paralelo utilizado. Nela
   temos o processo mestre e o conjunto de processos escravos. As tarefas que o
   mestre atribui aos escravos disponiveis sao populacoes a serem evoluidas por um
   determinado numero de geracoes, o escravo retorna ao mestre um determinado
   numero de individuos melhor adaptados.
   328
   APLICACOES PARALELAS EM VISAO
   Individuos
   melhor adaptados
   apos n geracoes
   Escravo n
   Mestre
   Escravo 1
   Populacao total a
   ser evoluida
   Fig. - 8.11 - Diagrama ilustrativo da estrategia de paralelismo do algoritmo
PA genetico distribuido com arquitetura CVMP processor farm .
   Na implementacao do algoritmo genetico foi gerada uma populacao inicial
   de 200 individuos, criados de forma aleatoria e ordenados em ordem crescente
   mediante a sua adaptacao ( fitness), dada pela distancia euclidiana entre os
   parametros de complexidade definida pelos metodos matematicos e o valor da
   funcao determinada pela analise humana. A cada geracao, os 100 individuos com
   as melhores taxas de adaptacao sao submetidos ao cross-over e a mutacao, a fim
   de produzir outros 100 individuos e compor a populacao total. Os 20 individuos com
   a menor adaptacao, sao tambem mantidos para garantir a diversidade. Maiores
   detalhes sobre o algoritmo utilizado no experimento podem ser obtidas em [Bruno
   et al., 2000].
   (a) (b)
   Fig. - 8.12 - Resultados da correlacao do algoritmo genetico para os modelos
   de complexidade utilizados. Referente a combinacao linear (a) e logaritmica
   (b).
   329
   CAPITULO 8
   A Figura 8.12 apresenta os resultados do algoritmo genetico mostrando o
   melhor ajuste das caracteristicas dos modelos matematicos utilizados em funcao da
   analise humana, onde a Figura 8.12a corresponde ao ajuste para o modelo de
   combinacao linear (Equacao 8.5) e a Figura 8.12b ao modelo logaritmo (Equacao
   8.6). A taxa de adaptacao foi normalizada no intervalo [-1;1]. Somente os
   coeficientes maiores do que 0,5 foram considerados no algoritmo genetico de modo
   a reduzir o numero de caracteristicas do modelo final [Bruno et al., 2000].
   Uma vez definido os coeficientes validos (maiores que 0,5 ou menores que -
   0,5), podemos analisar a otimizacao realizada pelo algoritmo genetico e chegar ao
   modelo de caracteristicas atraves da Figura 8.12. Dos 71 coeficientes extraidos
   originalmente (18 entropia, 18 tempo de decaimento, 18 circularidade e 17
   Minkowski), os modelos finais reduziram esse numero para 22 (Figura 8.12a) e 8
   (Figura 8.12b), respectivamente para a combinacao linear e logaritmica, o que
   indica que o modelo logaritmico demonstrou ser mais efetivo. Das 8 caracteristicas
   resultantes do modelo, 4 sao de entropia (3 positivas e uma negativa), 2 sao de
   tempo de decaimento da variancia (uma positiva e uma negativa) e 2 de Minkowski
   (uma positiva e uma negativa). Curiosamente, nenhum coeficiente de circularidade
   foi definido no modelo logaritmico, o que pode indicar uma predominancia de
   textura maior que a forma na percepcao de complexidade humana. O modelo
   obtido pode ser utilizado em analises de imagens e aplicacoes em visao
   computacional, onde sao necessarios obter medidas de complexidade aproximadas
   a percepcao humana.
   8.3.6 - EFICIENCIA DA IMPLEMENTACAO PARALELA
   Do ponto de vista do paralelismo e do CVMP, a implementacao paralela do
   algoritmo genetico possibilitou a comprovacao da eficacia e dos beneficios da
   utilizacao do CVMP processor farm. Basicamente, encontramos cinco pontos que
   consolidaram a utilizacao do CVMP processor farm, demonstrados atraves da
   implementacao do algoritmo genetico paralelo: (i) simplicidade de utilizacao, (ii)
   estrategias de paralelismo prontas para uso, (i i) utilizacao generica, (iv)
   balanceamento de carga automatico e (v) alta performance.
   A Figura 8.13 apresenta tres graficos contendo o tempo de execucao do
   algoritmo genetico paralelo. Nos graficos, cada um dos blocos representam as
   tarefas realizadas pelos processos escravos, que consistem em executar um
PA 330
   APLICACOES PARALELAS EM VISAO
   determinado numero de geracoes (8.13a e 8.13c - 20 geracoes ; 8.13b - 50
   geracoes). Em todos os exemplos, o sistema distribuido foi constituido de maquinas
   heterogeneas, com diferentes performances, o que coloca a prova seu
   balanceamento de carga. Nos graficos (a) e (b) foram utilizadas quatro maquinas
   conectadas com rede ethernet 10 Mb/s. Em cada uma das maquinas foi executado
   um processo escravo, e na maquina mais veloz foi tambem incorporado o processo
   mestre, executado em concorrencia atraves de multitarefa. No grafico (c) foram
   utilizadas tres maquinas conectadas atraves de fast ethernet 100 Mb/s. O tempo
   despendido com a troca de mensagens entre os processos e muito pequeno,
   comparado com o tempo de processamento de cada uma das tarefas, de modo
   que, a diferenca de velocidade entre os sistemas de rede e praticamente
   desconsiderada.
   (a)
   (b)
   (c)
   Fig. - 8.13 - Graficos apresentando o tempo de execucao da implementacao
   paralela do algoritmo genetico.
   331
   CAPITULO 8
   A eficiencia do balanceamento de cargas do sistema pode ser observada
   pela ausencia de bolhas, demonstrando uma otima utilizacao do hardware
   (eficiencia), acarretando diretamente em boa performance. Embora a determinacao
   precisa da performance do sistema seja dificultada devido a natureza aleatoria,
   tanto na configuracao inicial quanto na execucao do algoritmo genetico, ela pode
   ser estipulada de forma aproximada pela qualidade do balanceamento de cargas e
   pela baixa demanda computacional requerida pelas trocas de mensagens. Deste
   modo, se as maquinas utilizadas no sistema forem homogeneas, a taxa de
   desempenho vai estar muito proxima ao numero de maquinas utilizadas.
   8.3.7 - GERACAO AUTOMATICA DE RELATORIOS NA
   WEB
   Usualmente os experimentos conduzidos no ynergos produzem um grande
   conjunto de graficos, dados numericos e texto [Bruno et al., 1998] [Bruno et al.,
   2000]. Uma das funcoes do modulo Internet do ynergos e a producao de relatorios
   automaticos dos resultados obtidos nos experimentos, de modo a auxiliar a
   organizacao, a apresentacao e visualizacao dos dados. Os resultados sao gerados
   em HTML, possibilitando sua utilizacao em um grande numero de aplicativos, assim
   como sua publicacao direta na Internet.
   8.4 - TREEVIS - UM SISTEMA PARALELO DE VISAO
   PARA ANALISE E RECONHECIMENTO ARBOREO
   O levantamento de especies arboreas em florestas, alem de ser um dos
   alicerces para o estudo e pesquisa cientifica em diversas areas da ciencia
   associadas a botanica, apresenta ainda importancia vital para a manutencao e
   preservacao ecologica, assim como para a economia florestal (cultivo,
   explorativismo, materia prima para remedios, etc.). Sua importancia se acentua nas
   florestas tropicais e equatoriais, que se caracterizam pela grande divergencia de
   familias e especies de arvores, muitas das quais ainda nao foram exploradas e se
   mantem objetos de pesquisa cientifica.
   Nesta secao sera introduzida a proposta TreeVis, atraves da qual e proposto
PA um sistema para o reconhecimento automatico de especies arboreas baseado na
   332
   APLICACOES PARALELAS EM VISAO
   analise sistematica de suas folhas. Alem de prover o reconhecimento automatico, o
   TreeVis, conta com um banco de dados, que armazena o modelo matematico do
   especime e tambem sua descricao fotografica, oferecendo uma alternativa aos
   herbarios tradicionais. Tambem sera descrito o primeiro prototipo do sistema
   TreeVis, implementado neste trabalho, o qual conta com uma arquitetura paralela
   para melhorar a performance do reconhecimento automatico. A secao sera
   finalizada com alguns dados experimentais de reconhecimento arboreo de algumas
   especies vegetais brasileiras (mata atlantica e cerrado) realizadas a partir do
   prototipo TreeVis.
   8.4.1 - LEVANTAMENTO ARBOREO E OS HERBAREOS
   A exploracao desenfreada dos recursos naturais, a destruicao dos habitats e
   a extincao de inumeras especies animais e vegetais, vem acontecendo nos ultimos
   seculos sem a preocupacao real da humanidade. Neste final de seculo entretanto,
   uma vez que estamos proximos de um ponto critico, esses temas vem atraindo a
   atencao de diversos segmentos da sociedade, nao sendo mais apenas um mero
   debate cientifico a respeito de um futuro distante. Toda essa atencao ao desgaste
   incontrolavel da biosfera e a perda dos recursos geneticos nela presente, nos
   mostra que um dos grandes desafios de nosso tempo converge para o estudo e a
   compreensao da biodiversidade, para que alem de conhecermos, possamos ainda
   resgatar, preservar e manejar alguns desses recursos, garantindo sua continuidade
   para o deleite das geracoes futuras.
   As florestas tropicais e equatoriais sao as regioes que apresentam a maior e
   mais exuberante diversidade biologica do planeta. Coincidentemente estao
   presentes em paises emergentes, sem planos consistentes de preservacao
   ecologica ou de levantamento sistematico da vegetacao, distribuidos na America
   Latina, Africa e sudeste asiatico. Dentre esses paises podemos destacar o Brasil,
   que possui a flora arborea mais diversificada do mundo, cuja falta de
   direcionamento tecnico e conscientizacao ecologica na exploracao dos recursos
   florestais vem acarretando danos irreparaveis, onde muitas especies ainda
   desconhecidas ou pouco estudadas correm serio risco de desaparecer.
   As bases para o estudo da biodiversidade, sobretudo no reino vegetal,
   consistem na taxonomia e no inventario. A taxonomia vegetal e uma ciencia que
   encontra um ponto fundamental em botanica, sendo responsavel pela sintese,
   333
   CAPITULO 8
   organizacao, classificacao, identificacao e nomenclatura das plantas. E baseada
   fundamentalmente na Morfologia e na Anatomia, e recebe informacoes adicionais,
   enriquecendo seus processos de classificacao, obtidas atraves do desenvolvimento
   de pesquisas em outras areas, entre elas podemos destacar a Citologia, Fisiologia,
   Ecologia, Fitogeografia, Paleobotanica, Fitoquimica e a Genetica. [Joly, 1993]
   [Stace, 1984] [Stuessy, 1990] [Lorenzi, 1992].
   Simultaneamente a classificacao, surge a necessidade de realizar o
   inventario das especies, atraves do qual e possivel efetuar o reconhecimento de
   especies catalogadas. O inventario botanico e realizado essencialmente atraves
   dos herbarios. Os herbarios se caracterizam por uma colecao cientifica de
   exemplares de ramos ferteis (galhos com folhas, podendo possuir flores ou frutos
   caracteristicos), coletados na natureza, prensados, dessecados e montados sobre
PA papel cartao. Associados a cada exemplar existe uma ficha padronizada, contendo
   todas as informacoes sobre o especime, com o rigor da taxonomia. Nos herbarios
   podem ser armazenados grande quantidade de especimes, que deverao ser
   alojadas em locais adequados a sua preservacao, permitindo sua conservacao por
   longo periodo de tempo (da ordem de seculos). Os exemplares devem ser
   arranjados segundo o criterio botanico, a fim de auxiliar a localizacao e estudos
   [Peixoto & Barbosa, 1998].
   Deste modo, os herbarios constituem a mais importante ferramenta de
   trabalho do botanico, atraves dos quais podem ser examinados e estudados,
   especimes procedentes de diferentes locais e ecossistemas. Atraves de seu auxilio,
   o botanico pode comparar um exemplar na natureza com centenas de especimes
   classificadas por especialistas e deste modo realizar sua identificacao. Atraves da
   pesquisa de campo e da utilizacao de ferramentas como o herbario, e realizado o
   levantamento arboreo de uma regiao, que consiste na especificacao e na
   identificacao das especimes de arvores ali encontradas. O levantamento arboreo e
   de importancia vital para o estudo dos habitats e ecossistemas, assim como para a
   eventual descoberta de novas especimes, auxiliando o desenvolvimento da
   pesquisa cientifica.
   8.4.1.1 - COLETA E TRATAMENTO DAS AMOSTRAS
   O levantamento arboreo e uma ardua tarefa, na qual todas as fases devem
   ser realizadas atraves de trabalho manual. A primeira etapa do processo consiste
   na pesquisa de campo. Nessa fase e realizada a coleta dos exemplares que serao
   334
   APLICACOES PARALELAS EM VISAO
   identificados. Como exemplares, sao coletados ramos ferteis, ou seja, galhos com
   folhas e, caso estejam presentes flores e frutos. Coletado o material, esse deve ser
   preparado para que se conserve ate a proxima etapa da pesquisa, que consiste na
   comparacao e identificacao desses especimes com o material do herbario, uma vez
   que essas etapas sao separadas por dias e as vezes ate mesmo por meses
   [Fernandes, 1997] [Lorenzi, 1992].
   O material coletado, recebe um tratamento similar aquele executado para a
   formacao do herbario, ou seja, os ramos sao prensados e dessecados. Alem da
   conservacao, o tratamento tambem pode auxiliar na identificacao do material, uma
   vez que este tera aspecto semelhante aos especimes do herbario [Peixoto &
   Barbosa, 1998].
   8.4.1.2 - CLASSIFICACAO ATRAVES DE HERBARIOS
   De posse do material coletado em campo, e realizada a identificacao atraves
   do herbario. Nessa fase tambem o trabalho e exercido de forma manual. Caso o
   botanico tenha alguma pista a respeito da familia ou da especie do exemplar, a
   pesquisa e direcionada e a comparacao e realizada com as pranchas previamente
   escolhidas para este fim. No entanto em muitas situacoes, especialmente se o
   botanico nao for um profundo conhecedor de determinada especie ou regiao, a
   busca devera ser realizada atraves de comparacoes com um universo muito maior
   de pranchas.
   A comparacao consiste em colocar o material coletado ao lado da prancha
   do herbario e realizar a identificacao visual das semelhancas e diferencas entre
   ambas. Uma vez localizada a prancha que apresenta a maior semelhanca com o
   especime coletado, e realizada a identificacao. Esse processo, alem de trabalhoso
   e demorado, requer um vasto treinamento ao botanico, de forma a minimizar os
   erros decorrentes de falsas identificacoes.
PA 8.4.2 - OS HERBARIOS BRASILEIROS
   Os herbarios sao repositorios de material cientifico, contendo a
   documentacao floristica de um pais. Suas informacoes constituem a fonte primaria
   para a botanica, atraves das quais podem ser realizados trabalhos taxonomicos,
   evolutivos, ecologicos, biogeograficos, etnobotanicos e estudos de biodiversidade,
   sendo ainda uma importante ferramenta e fonte de dados para o planejamento do
   335
   CAPITULO 8
   desenvolvimento sustentavel [Peixoto & Barbosa, 1998].
   Os paises desenvolvidos possuem herbarios praticamente completos,
   atraves dos quais sao preparadas listas de especies ameacadas de extincao, de
   valor medicinal, ornamental, produtoras de frutos comestiveis e muitas outras.
   Entretanto, eles nao contam com uma rica flora tropical e uma exuberante
   biodiversidade, como e a situacao de alguns paises em desenvolvimento, em
   especial o Brasil, que nao tem feito o mesmo devido a falta de recursos,
   informacoes e pela complexidade da tarefa.
   Inumeros estudos realizados sobre especies brasileiras promissoras
   certificam o valor da flora nativa, sobre diferentes aspectos, e trazem a tona o
   quanto custa o desconhecimento do conjunto dessas especies para a sociedade
   moderna. A falta de informacoes sobre as especies nativas se da,
   predominantemente, a diversidade e riqueza da flora, ao pequeno numero de
   botanicos especializados que possam estuda-las e ao longo e trabalhoso processo
   de levantamento floristico. Esta situacao torna-se mais critica diante da rapidez com
   que esta desaparecendo a vegetacao natural e do longo periodo de treinamento
   exigido para formar um especialista em taxonomia.
   Estado
   N-o de Herbarios Exemplares
   RJ
   11
   912.632
   SP
   16
   750.765
   RS
   15
   437.230
   PR
   8
   349.537
   PA
   3
   326.778
   DF
   4
   281.474
   MG
   11
   228.143
   BA
   7
PA 210.027
   AM
   3
   206.092
   PE
   6
   184.338
   SC
   4
   111.200
   PB
   2
   31.500
   CE
   4
   23.612
   GO
   1
   22.001
   ES
   3
   21.800
   MS
   4
   18.548
   AL
   2
   16.232
   MT
   1
   14.014
   PI
   1
   9.930
   AP
   1
   8.000
   AC
   2
   7.822
   SE
   1
   6.930
   RN
   2
   5.257
   MA
   1
   2.777
   Tabela 8.1 - Herbarios brasileiros e numeros de exemplares [Peixoto &
PA Barbosa, 1998].
   336
   APLICACOES PARALELAS EM VISAO
   O Brasil conta com 113 herbarios ativos, que guardam um acervo de
   4.187.154 especimes vegetais, segundo a Sociedade Brasileira de Botanica (SBB)
   (1997) [Peixoto & Barbosa, 1998]. Embora em uma primeira instancia esse numero
   possa parecer significativo, ele reflete uma pequena fracao da biodiversividade
   floristica brasileira (sem considerar que muitas especies se repetem em diferentes
   herbarios). A Tabela 8.1 apresenta uma listagem contendo o numero de herbarios e
   as especies catalogadas em cada estado brasileiro, e a Tabela 8.2 apresenta a lista
   dos herbarios que mais detem informacoes.
   Estado
   Sigla
   Instituicao
   Exemplares
   RJ
   R
   Museu Nacional do Rio de Janeiro
   375.000
   RJ
   RB
   Jardim Botanico do Rio de Janeiro
   344.812
   SP
   SP
   Instituto de Botanica de Sao Paulo
   317.000
   PR
   MBM
   Museu Botanico Municipal de Curitiba
   255.000
   DF
   UB
   Universidade de Brasilia
   208.000
   AM
   INPA
   Instituto de Pesquisas da Amazonia
   200.000
   PA
   IAN
   EMBRAPA, Amazonia Oriental
   164.000
   PA
   MG
   Museu Paraense Emilio Goeldi
   159.778
   SP
   SPF
   Universidade de Sao Paulo
PA 142.827
   RS
   RS
   Instituto Anchietano de Pesquisas
   120.000
   RS
   ICN
   Universidade Federal do Rio Grande do Sul
   118.000
   RS
   HAS
   Fundacao Zoobotanica do Rio Grande do Sul
   108.300
   Tabela 8.2 - Os doze herbarios brasileiros que mais detem informacoes
   [Peixoto & Barbosa, 1998].
   8.4.3 - A PROPOSTA TREEVIS
   Levando em conta a importancia do levantamento arboreo e suas
   dificuldades, fomos motivados a idealizar um sistema cujo intuito e propiciar ao
   botanico taxonomista mais um recurso para auxiliar seu trabalho na identificacao
   dos especimes. Alem da busca em herbarios tradicionais ser uma tarefa bastante
   exaustiva, podemos citar alguns fatores que restringem sua utilizacao tais como: (i)
   Pequeno numero de herbarios, que em geral estao localizados em locais distantes
   do pesquisador, (ii) Dificuldade de replicacao da base cientifica de modo a
   democratizar seu acesso, uma vez que os herbarios sao constituidos de
   exemplares retirados da natureza, (iii) Perda de informacoes essenciais durante o
   tratamento dos exemplares (cor e detalhes da textura) e (iv) longo treinamento na
   formacao de especialistas realmente capazes de realizar a identificacao.
   Esta proposta nao visa a substituicao dos herbarios tradicionais, mas sim
   337
   CAPITULO 8
   adicionar mais um complemento ao conjunto de metodologias de identificacao
   vegetal, permitindo acelerar o trabalho de reconhecimento (reconhecimento
   automatico) e facilitar o acesso a informacoes, uma vez que os sistemas digitais
   sao facilmente replicaveis, podendo ser distribuidos para diversas universidades,
   laboratorios e institutos de pesquisa.
   Dentro desta motivacao surgiu a proposta do sistema TreeVis, cujo nome e
   derivado do ingles "Tree Vision System". Trata-se de um sistema capaz de
   armazenar, classificar e organizar dados cientificos e realizar a identificacao
   automatica de especies, funcionando como um herbario digital. Diferente dos
   herbarios tradicionais, onde sao colecionados ramos ferteis, o TreeVis concentra
   nas folhas todo o sistema de informacoes e identificacao dos exemplares.
   O processo de reconhecimento atraves das folhas e uma tarefa complicada
   e audaciosa, concretizando um verdadeiro desafio para um sistema de
   reconhecimento. Isso acontece devido a natureza dos vegetais. Embora conservem
   algumas caracteristicas fundamentais, as folhas apresentam uma grande variacao.
   Essas variacoes ocorrem dentro de um unico individuo, onde a maturidade ou
   mesmo a formacao das folhas, faz com que essas tenham grandes variacoes
   quanto ao tamanho, coloracao, textura, formato, etc., e tambem entre individuos
   diferentes (da mesma especie). Individuos diferentes de uma mesma especie
   localizados nas mesmas regioes podem apresentar diferencas nas suas folhas
PA (como influencia do solo) e, para dificultar ainda mais o processo, individuos de
   uma mesma especie localizados em diferentes regioes ou ecossistemas, podem
   ainda conter folhas diferentes, refletindo o resultado de refinamento genetico ou ate
   mesmo mutacoes.
   Para vencer os desafios impostos pela complexa tarefa do reconhecimento
   de folhas, a proposta TreeVis esta baseada em fundamentos que apresentam
   grande potencial para a solucao do problema: (i) exploracao sistematica das
   caracteristicas das folhas atraves de um vasto numero de atributos visuais, (i )
   sinergismo, (iii) analise estatistica e (iv) metodologia de utilizacao.
   A exploracao do maior numero possivel de informacoes (caracteristicas) (i),
   fornece um contexto maior para a identificacao. Devido ao grande universo de
   especies e as grandes variacoes dentro de uma mesma classe, surge a
   necessidade de extrair grandes quantidades de informacoes, a fim de se conseguir
   dados suficientes para realizar uma classificacao estatistica. Esta abordagem, alem
   de possuir motivacao biologica, e tambem abordada em diversos sistemas
   338
   APLICACOES PARALELAS EM VISAO
   artificiais. O sistema de visao dos primatas por exemplo, associa diversos atributos,
   e atraves de sua combinacao extrai uma incrivel quantidade de caracteristicas para
   realizar o reconhecimento. Encontramos tambem alguns sistemas de visao artificial
   com amplas bases de conhecimento que adotam essa estrategia para efetivar o
   reconhecimento de objetos, entre eles podemos citar a proposta Cyvis-1, bastante
   discutida nesta tese e o Seemore [Mel, 1997], sistema capaz de reconhecer um
   grande numero de objetos bidimensionais, tridimensionais e flexiveis (cabo de
   telefone, tecido, etc.), fundamentalmente baseado na extracao de um grande e
   variado numero de caracteristicas de diferentes atributos (cor, forma, textura,
   complexidade, etc.). Estreitamente ligado a essa estrategia encontramos o item (i ),
   onde podemos considerar que a combinacao das caracteristicas resulta em um
   sinergismo de atributos, onde a associacao destas e muito mais rica do que a soma
   individual de cada parte.
   A analise estatistica (iii) e um dos pontos fundamentais da proposta. Em
   primeiro lugar, atraves dela e realizada a classificacao e consequentemente o
   reconhecimento. Em segundo lugar, e a abordagem estatistica que ditara a
   metodologia de comparacao e identificacao. Por exemplo, atraves do bom senso
   estatistico, o sistema nao processa o reconhecimento baseado em uma unica folha
   (tanto no aprendizado quanto na busca), ao contrario disso sao processadas
   diversas folhas (cerca de 10) de um mesmo especime a fim de compensar suas
   grandes variacoes, convergindo para uma media.
   Finalmente e na metodologia de utilizacao (iv) ou seja nos procedimentos
   tecnicos realizados pelo botanico que se encontra um outro ponto fundamental do
   sistema. A ele competira a normalizacao da coleta de folhas, ou seja, as folhas
   deverao pertencer a uma media, nao podendo ser coletados exemplares que
   contradigam a media do vegetal, tanto no tamanho, coloracao ou forma. O botanico
   ainda devera levar em conta questoes como doencas ou outros aspectos que
   possam alterar as caracteristicas das folhas do vegetal, e tambem se preocupar
   com a questao da maturidade, colhendo folhas sempre com maturidade media.
   8.4.4 - PROTOTIPO TREEVIS
   Neste trabalho implementamos o primeiro prototipo do sistema TreeVis, no
   qual todos os metodos e tecnicas utilizadas para a extracao de caracteristicas das
   amostras foram ajustados e configurados especificamente para a caracterizacao de
PA 339
   CAPITULO 8
   plantas arboreas. O sistema foi implementado em Delphi para a plataforma
   Windows. Devido a grande quantidade de caracteristicas extraidas das imagens,
   assim como pela resolucao das imagens, o sistema consome consideravel recurso
   computacional. Deste modo, ele foi implementado com recursos de paralelismo,
   atraves da utilizacao de CVMP, onde foi adotada a arquitetura de computacao
   distribuida.
   A fim de avaliar, foram realizados experimentos com 59 especies reais, das
   quais a maior parte e constituida de especies de plantas arboreas nativas da Mata
   Atlantica (reconhecida como a floresta mais ameacada do planeta). Embora o
   resultado obtido tenha sido satisfatorio, muito ainda deve ser feito para obter uma
   versao operacional, ou seja, que permita a utilizacao do TreeVis como uma
   ferramenta de trabalho para os botanicos.
   Nas proximas subsecoes iremos descrever o prototipo, abordar sua
   implementacao paralela e apresentar alguns resultados obtidos.
   8.4.5 - DESCRICAO DO SISTEMA TREEVIS
   O sistema TreeVis, conforme apresentado no diagrama em blocos da Figura
   8.14, e composto por seis modulos: Extracao de caracteristicas, Controle central,
   Treinamento e identificacao, Analise estatistica, Base de dados e Estrutura de
   amostragem.
   As informacoes sao adquiridas pelo sistema atraves de um dispositivo de
   digitalizacao de imagens. Neste sistema foi adotado um "Scanner de mesa"
   comercial, que permite digitalizar imagens com ate 9600 DPI (pontos por polegada
   " dot per inch"). Uma vez que as folhas possuem diferentes informacoes em cada
   um dos lados, o sistema necessita que sejam adquiridas as imagens referentes aos
   dois lados da folha, que podem ser a grosso modo definidos, como lado de sol
   (exposto a luz solar direta) e lado de sombra (lado oposto). Deste modo cada
   amostra e representada atraves de um par de imagens. Alem dessas informacoes,
   o sistema utiliza tambem uma imagem, adquirida atraves da ampliacao de uma
   determinada regiao da folha, para a analise da textura de sua organizacao celular.
   Discutiremos sobre ela na Subsecao 8.4.5.1.1. As imagens dos dois lados da folha,
   mais a imagem para analise de textura, constituem os dados de entrada do
   sistema, denominados de amostras. E denominada de Estrutura de amostragem, a
   amostra ou o conjunto de amostras a ser analisado.
   340
   APLICACOES PARALELAS EM VISAO
   Niveis de
   Cinza
   Cor
   Imagens
   Treinamento
   Forma
   Controle
   e
   Descricoes
   Central
   Identificacao
   Listas de
   Textura e
PA caracteristicas
   Complexidade
   Histograma
   Base de Dados
   Analise
   Extracao de caracteristicas
   estatistica
   Scanner
   Estrutura de
   amostragem
   Fig. - 8.14 - Diagrama em blocos apresentando os modulos que compoe o
   sistema TreeVis, e suas respectivas conexoes.
   Nesta descricao nao abordaremos da implementacao paralela do sistema, a
   qual sera discutida na Subsecao 8.4.6, limitaremos por enquanto ao sistema na sua
   forma sequencial. A partir da estrutura de amostras, pode ser solicitada uma
   analise, e deste modo o sistema inicia sua execucao. O modulo Controle central
   envia as imagens que constituem cada uma das amostras da estrutura de
   amostragem para o modulo Extracao de caracteristicas. Este modulo e dividido em
   varios submodulos, cada um contendo uma familia de metodos e tecnicas de visao
   e processamento de imagens, responsaveis pela extracao do conjunto de
   caracteristicas da imagem (vetor de caracteristicas).
   O sistema possibilita duas modalidades de identificacao: Estatica e
   dinamica. Na identificacao estatica, o modulo Controle central aguarda ate que
   todas as caracteristicas sejam extraidas, e entao as envia para o modulo
   Treinamento e Identificacao, que atraves de busca e comparacao com a base de
   dados realiza a identificacao da amostra.
   A identificacao dinamica possibilita o reconhecimento da amostra em um
   tempo menor, aumentando a performance do sistema. Para essa modalidade o
   sistema tenta fazer o reconhecimento da amostra a medida em que e realizado o
   processamento e a extracao das caracteristicas. Uma vez que os metodos e as
   341
   CAPITULO 8
   tecnicas de processamento de imagens e extracao de caracteristicas possuem
   tempo de processamento diferentes, a medida que os mais velozes (ex: area,
   histograma, etc.), extraem as caracteristicas da imagem, estas sao enviadas para o
   modulo de controle. O modulo de controle por sua vez, envia as caracteristica
   parciais ao modulo Treinamento e identificacao, que realiza uma busca no sistema
   de base de dados, obtendo uma lista das provaveis especies, contendo a classe da
   especie provavel e o seu correspondente vetor de caracteristicas. Esta lista e
   enviada para o modulo Analise estatistica, o qual e baseado no calculo da matriz de
   covariancia, que permite determinar quais caracteristicas apresentam as melhores
   discriminacoes entre as especies da lista, podendo consequentemente classifica-las
   enquanto parte do modulo Extracao de caracteristicas executa o processamento.
   O sistema termina a execucao quando finaliza a analise e processamento de
   cada uma das amostras da Estrutura de amostragem. Conforme comentamos
   anteriormente, a estrutura de amostragem pode conter uma ou mais amostras de
   uma mesma planta arborea. A utilizacao de um maior numero de amostras, faz com
   que o sistema possa se munir de recursos adicionais no processo de classificacao,
   permitindo uma identificacao mais acurada.
   Como resultado da identificacao e apresentada ao usuario uma lista (com
PA cerca de 4 elementos) ordenada com as especies mais provaveis. Selecionando o
   item da lista, sao mostradas informacoes referentes a especie, contendo as
   imagens de uma amostra (os dois lados da folha e a ampliacao de analise de
   textura) e seus respectivos nomes popular, cientifico e familia.
   O processo de treinamento do sistema consiste basicamente na insercao de
   novos especimes a base de dados, sendo bastante similar ao do processo de
   identificacao estatica. Deve ser armazenado um grupo de amostras referente a
   especie a ser inserida. Quanto maior o numero de amostras, maior a chance de se
   obter um bom treinamento. E entao solicitado ao sistema a insercao da especie. O
   usuario deve preencher a ficha de identificacao contendo o nome cientifico e a
   familia da planta arborea, assim como escolher uma amostra para caracteriza-la no
   processo de identificacao (exibir ao usuario no resultado). Deste modo, como no
   processo de identificacao, o modulo Controle central envia as imagens do primeiro
   elemento da Estrutura de amostragem para o modulo de Extracao de
   caracteristicas, o qual realiza o processamento e a extracao das caracteristicas,
   resultando em um vetor. O vetor de caracteristicas e entao enviado para o modulo
   Treinamento e identificacao, que aguarda uma mensagem do modulo Controle
   342
   APLICACOES PARALELAS EM VISAO
   central, indicando que todas as amostras da Estrutura de amostragem foram
   processadas. Neste momento, o modulo Treinamento e identificacao, realiza o
   calculo da media dos vetores, e armazena-o no modulo Base de dados, juntamente
   com as informacoes sobre o especime fornecidas pelo usuario.
   Tanto no treinamento quanto na identificacao, a pericia tecnica do usuario e
   fundamental, sendo o responsavel pela determinacao das folhas a serem
   amostradas. Lembrando mais uma vez, o material coletado para a amostragem
   deve refletir a caracteristica media das folhas da planta arborea, especialmente no
   que se refere a cor (maturidade), forma e dimensao. A qualidade do exemplar
   tambem e outro fator importante, uma vez que folhas com pragas, ou danificadas
   por insetos, vao descaraterizar o modelo obtido atraves do sistema TreeVis.
   Nas proximas subsecoes vamos descrever com maiores detalhes cada um
   dos modulos que compoe o sistema TreeVis.
   8.4.5.1 - ESTRUTURA DE AMOSTRAGEM
   O modulo Estrutura de amostragem e responsavel pelo armazenamento das
   amostras a serem processadas. As amostras devem pertencer a uma mesma
   planta arborea, ou ser provenientes de diferentes individuos da mesma especie. O
   modulo funciona como uma estrutura de dados na forma de fila (FIFO - first in first
   out), disponibilizando as amostras para o modulo Controle central. O numero de
   amostras necessarias para o funcionamento do sistema TreeVis e variavel,
   podendo ir de uma unica amostra ate virtualmente quantas o usuario desejar
   utilizar. Diferentes amostras determinam uma media ao modelo das amostras,
   deste modo, quanto maior o numero de amostras, maior a estimativa de que o
   modelo resultante vai estar mais proximo do modelo mais representativo da media
   das folhas desta especie. Assim, a utilizacao de um numero maior de amostras e
   fundamental para o bom treinamento de uma especie.
   8.4.5.1.1 - Amostras
   As amostras sao formadas por duas imagens principais e uma imagem
   adicional, que pode ou nao ser utilizada no sistema. Uma vez que as folhas
   apresentam dois lados, com diferentes naturezas, fica bastante obvio, que o
   sistema deve explorar essa caracteristica. Portanto as imagens principais das
PA amostras sao constituidas atraves da aquisicao de cada um dos lados da folha
   (lado de sol e de sombra). O lado de sol e discriminado como lado A e o de sombra
   343
   CAPITULO 8
   de lado B.
   As imagens utilizadas no sistema sao quadradas com lado de 512 pixels
   (potencia de 2 (29 = 512)) para facilitar os metodos que utilizam a transformada
   rapida de Fourier - FFT. Esta dimensao foi escolhida por fornecer uma boa
   resolucao. Experimentos realizados com resolucoes menores, (128x128 e 256x256)
   nao apresentaram resultados satisfatorios. Embora nao tenhamos realizado testes
   detalhados, acreditamos que imagens maiores (ex: 1024x1024 ou 2048x2048)
   poderao apresentar melhores resultados, ficando como sugestao para
   experimentos e futuras versoes do TreeVis. Cada imagem (lado A ou lado B) deve
   conter apenas uma folha, a qual deve estar orientada em 900, ou seja em posicao
   vertical, com a extremidade da folha localizada na parte superior da imagem. A
   orientacao e realizada a partir da nervura principal da folha, conforme mostra a
   Figura 8.15.
   Extremidade
   da folha
   Nervura principal
   Extremidade cortada
   do caule
   Fig. - 8.15 - Exemplo do alinhamento da imagem, na qual a nervura principal
   da folha devera estar orientada na vertical.
   A aquisicao das imagens de ambos os lados da folha e realizada com cerca
   de 200 DPI (pontos por polegada - dot per inch). No entanto na grande maioria dos
   casos, a imagem deve ser reduzida, a fim de que toda a folha caiba na imagem (ver
   Figura 8.15). O fator de reducao e dado em porcentagem do tamanho original da
   imagem, e deve ser adicionado a amostra, para que com ele o sistema possa
   realizar os calculos para compensar a reducao.
   Alem das imagens principais (os dois lados da folha), e realizada tambem a
   digitalizacao de uma terceira imagem, a qual denominamos imagem ampliada de
   textura, atraves da qual e realizada analise da organizacao (textura) celular. A
   Figura 8.16 mostra o procedimento de digitalizacao desta imagem. Com o lado de
   sol da folha, orientado no Scanner, e selecionada uma pequena janela quadrada de
   344
   APLICACOES PARALELAS EM VISAO
   0,341 polegadas de lado, a qual deve ser adquirida com uma resolucao de 1500
   DPI, resultando em uma imagem de 512x512 pixels. A janela deve sempre ser
   posicionada na porcao direita da folha, entre as nervuras.
   Fig. - 8.16 - Procedimento para aquisicao da imagem ampliada de textura.
   Neste exemplo foi utilizada a folha da Hymenea courbaril (Jatoba).
   A Figura 8.17 mostra as imagens que compoe uma amostra completa, da
   Ormosia arborea (olho de cabra), apresentadas no ambiente grafico do sistema
   TreeVis.
   Fig. - 8.17 - Amostra completa da Ormosia arborea (olho de cabra), no
   ambiente grafico do sistema TreeVis. Da esquerda para a direita: lado A (sol),
   lado B (sombra) e imagem ampliada de textura.
   345
   CAPITULO 8
PA As amostras devem passar pelo processo de digitalizacao, o mais breve
   possivel apos sua coleta, a fim de nao perderem suas propriedades vitais (cor e
   textura). As folhas devem ser lavadas e mantidas em agua a fim de se manterem
   conservadas. E recomendado que algumas horas antes do processo de
   digitalizacao as folhas sejam ligeiramente prensadas, a fim de evitar que surjam
   dobras quando colocadas no Scanner.
   As amostras estao limitadas a folhas simples, tratando as plantas com folhas
   compostas ou palmadas da mesma forma, ou seja e considerado apenas um de
   seus elementos na constituicao da amostra. As plantas com folhas compostas
   como o caso do Pau-Brasil ou palmadas como a Paineira, perdem importantes
   informacoes a respeito de sua composicao, uma vez que o sistema considera
   apenas uma de suas componentes e despreza a sua estrutura. Uma sugestao para
   considerar essas estruturas e, nas futuras versoes do sistema, incorporar essas
   informacoes, como parte integrante das amostras. Neste caso, usuario entraria com
   informacoes adicionais a respeito do especime, indicando se a folha e simples,
   composta ou palmada, e no caso das palmadas, ainda poderia ser incorporado
   como caracteristica de classificacao o numero medio de elementos que as
   compoem. Com base nestas informacoes o sistema poderia eliminar grande parte
   da base de dados, no processo de identificacao, direcionado a pesquisa para as
   especies pertencentes a estes grupos.
   8.4.5.2 - BASE DE DADOS
   No modulo Base de dados sao armazenadas as informacoes referentes as
   amostras treinadas pelo TreeVis. Para cada amostra sao armazenados os dados de
   identificacao da especie, fornecidos pelo usuario, contendo seu nome cientifico e
   vulgar, e a sua familia. Uma amostra (lado A, lado B e ampliacao de textura) e
   tambem armazenada, de forma a auxiliar o usuario na confirmacao visual do
   veredicto providenciado pelo sistema. Alem das informacoes fornecidas pelo
   usuario, e armazenado tambem o vetor das caracteristicas extraidas pelo TreeVis,
   atraves do qual a especie e modelada.
   8.4.5.3 - CONTROLE CENTRAL
   No modulo Controle central reside o coracao do sistema. Nele e
   implementada a interface grafica com o usuario (GUI), permitindo que o usuario
   346
   APLICACOES PARALELAS EM VISAO
   opere o sistema, efetue a identificacao e treinamento das amostras, entre com a
   descricao das especies (treinamento), compare o resultado visualmente, e tambem
   realize a visualizacao de algumas das tecnicas e metodos de processamento de
   imagens e visao utilizadas no TreeVis. A Figura 8.18, exibe o ambiente grafico com
   o usuario do sistema TreeVis, exemplificando alguns dos recursos de visualizacao
   das tecnicas e metodos do TreeVis.
   Alem de prover a interface grafica com o usuario, a visualizacao cientifica e
   a operacao do sistema, o modulo Controle central tambem controla, gerencia e
   supervisiona todos os demais modulos.
   Fig. - 8.18 - Ambiente grafico com o usuario do TreeVis. Exemplo de
   visualizacao de tecnicas e metodos de processamento de imagens e visao.
   8.4.5.4 - EXTRACAO DE CARACTERISTICAS
   Atraves do modulo Extracao de caracteristicas o TreeVis extrai o modelo de
   representacao da amostra, que nada mais e do que um vetor de 165 elementos,
   contento todas as caracteristicas determinadas pelo sistema. Este modulo e
   347
PA CAPITULO 8
   dividido em 5 submodulos: niveis de cinza, cor, forma, textura/complexidade e
   histograma. Os submodulos agrupam as tecnicas e metodos utilizados para a
   extracao das caracteristicas, em funcao de sua natureza. O modulo Extracao de
   caracteristicas envia em tempo de execucao do elemento do modelo de
   representacao para o Controle central, possibilitando desta forma a operacao do
   sistema em carater de classificacao dinamica.
   8.4.5.4.1 - Niveis de Cinza
   Nesse modulo somente e processado o lado A da amostra, uma vez que o
   processamento aqui realizado leva somente em conta o formato da folha, a partir de
   sua binarizacao (que e o mesmo em ambos os lados). Dessa imagem sao extraidas
   tres caracteristicas: area da folha, perimetro e circularidade (razao entre a area e o
   perimetro ao quadrado).
   8.4.5.4.2 - Cor
   O modulo cor e composto por dois conjuntos de caracteristicas:
   cromaticidade e cromaticidade multiescala. No primeiro caso, e realizado o calculo
   da cromaticidade para cada componente cromatico (R, G e B) [Moreira, 1999]. Esse
   procedimento e realizado em ambos os lados da folha (lado A e B), uma vez que
   cada lado possui sua propria natureza cromatica. As Equacoes 8.7, 8.8 e 8.9
   expressam o calculo de cromaticidade para cada um dos componentes cromaticos
   da imagem, onde r, g e b e o valor do componente cromatico de cada pixel, e n e o
   numero de pontos pertencentes a folha. Devemos lembrar que somente sao
   computados nesses calculos os pixels pertencentes a folha.
   n
   ri
   +
   +
   i=
   r
   g
   b
   C( r
   i
   i
   i
   = 1
   )
   (8.7)
   n
   n
   gi
   +
   +
   i=
   r
   g
   b
   C( g
   i
   i
PA i
   = 1
   )
   (8.8)
   n
   348
   APLICACOES PARALELAS EM VISAO
   n
   bi
   +
   +
   i=
   r
   g
   b
   C b
   i
   i
   i
   ( = 1
   )
   (8.9)
   n
   Os calculos para a cromaticidade multiescala sao realizados da mesma
   maneira, sendo considerados os dois lados da imagem, que no entanto sofrem
   convolucoes com Gaussianas de diferentes desvios padrao (5 desvios-padrao ao
   todo).
   8.4.5.4.3 - Forma
   O modulo forma analisa o contorno da folha (imagem binarizada) e tambem
   seu interior, atraves das nervuras. No primeiro caso, o sistema utiliza o algoritmo de
   extracao de contorno [Cesar, 1997] (Figura 8.19b). Com base no modelo de
   contorno sao calculadas 15 caracteristicas, das quais, 3 consistem na energia de
   dobramento ( bending energy) multi-escala [Cesar, 1997] e as outras 12 nos
   descritores de Fourier 1D do contorno [Castleman, 1996] [Gonzalez & Woods,
   1993]. Uma vez que ambos os lados da folha possuem o mesmo contorno, somente
   e considerado o lado A.
   (a)
   (b)
   (c)
   Fig. - 8.19 - Visualizacao do calculo de curvatura. Contorno da folha da
   Cariniana estrellensis (Jequitiba), obtida atraves da deteccao de bordas da
   imagem binarizada. (b) Janela de controle, apresentando a projecao do
   contorno no eixo x, y e o grafico de curvatura. (c) Projecao do grafico de
   curvatura sobre o contorno (3D).
   A Figura 8.19 ilustra a visualizacao do calculo de curvatura, onde a figura (a)
   349
   CAPITULO 8
   apresenta o contorno de uma folha, obtido atraves da deteccao de borda (Sobel) da
   imagem binarizada, a figura (b) apresenta as projecoes do contorno nos eixo x e y e
   o grafico de curvatura e a figura (c) exibe a projecao do grafico de curvatura de
PA forma perpendicular sobre o contorno (visualizacao 3D).
   Para a analise das nervuras e utilizada a transformada de Hough com
   backmapping, em ambos os lados da folha (lado A e lado B), uma vez que em
   determinadas especies podem surgir diferencas entre as estruturas de cada lado. A
   nervura principal e desconsiderada no calculo, que utiliza apenas as demais
   nervuras (ver Figura 8.20b). Atraves delas sao obtidas 7 caracteristicas, sendo que
   uma e referente ao angulo de orientacao das nervuras e as 6 restantes referentes
   ao numero de retas obtidas, dentro de 6 dimensoes pre-especificadas (definidas
   pelo sistema). A Figura 8.20 ilustra a imagem da folha segmentada exibindo seu
   contorno e nervuras (a) ,as nervuras consideradas na analise (b) e um exemplo
   mostrando o angulo avaliado (c).
   (a) (b) (c)
   Fig. - 8.20 - Nervuras da folha, consideradas na transformada de Hough.
   Imagem segmentada (a), nervuras consideradas para a transformada (b) e
   referencia do angulo determinado pela analise (c).
   8.4.5.4.4 - Textura e complexidade
   No modulo Textura e complexidade sao agrupados alguns metodos para
   medir a complexidade e a textura da folha, extraindo desse modo caracteristicas.
   Como medidas de complexidade e de textura, o modulo utiliza a dimensao fractal
   (box counting), efetuada em cada um dos lados da folha, totalizando suas
   350
   APLICACOES PARALELAS EM VISAO
   caracteristicas e a contagem de pontos de cruzamento por zero da transformada de
   Marr-Hildreth para 4 diferentes desvios-padrao (multi-escala) [Gonzalez & Woods,
   1993] [Marr,1982] [Parker, 1997], totalizando 5 caracteristicas. Embora o modulo
   seja denominado Textura e complexidade, ele nao e o unico modulo a tratar deste
   atributo, uma vez que o modulo Histograma tambem apresenta medidas relativas
   que, devido a natureza dos metodos, foram agrupadas nele.
   Fig. - 8.21 - Visualizacao do dominio da frequencia (real) da imagem de
   ampliacao de textura de 4 especies diferentes, apresentando as diferencas
   que caracterizam os descritores.
   Dentre os submodulos de extracao de caracteristicas, Textura e
   complexidade e o unico a utilizar a imagem ampliada de textura. Para analisar e
   extrair as caracteristicas da imagem ampliada de textura, e utilizado os descritores
   da transformada de Fourier 2D da imagem [Gonzalez & Woods, 1993]. Os
   descritores utilizados sao os radiais, e totalizam 15 caracteristicas. A Figura 8.21
   apresenta a visualizacao do dominio (real) da frequencia de 4 especies distintas de
   plantas arboreas. Atraves delas podemos observar a variacao na forma dos
   graficos, a qual e descriminada pelos descritores, caracterizando o modelo de
   classificacao por textura.
   351
   CAPITULO 8
   8.4.5.4.5 - Histograma
   Este modulo, embora extraia caracteristicas relacionadas com a
   complexidade e a textura das folhas, recebe a denominacao de Histograma, devido
   as tecnicas utilizadas serem todas baseadas no histograma da imagem. Nele
   basicamente sao realizadas dois tipos de medidas: calculo do desvio-padrao da
   distribuicao do histograma e calculo da entropia do histograma [Gonzalez & Woods,
   1993]. Assim como no modulo Cor, somente sao considerados os pixels
   pertencentes a folha para a elaboracao do histograma. Uma vez que ambos os
PA lados da folha possuem diferentes textura, os dois sao considerados pelo modulo.
   Fig. - 8.22 - Histogramas de folhas de 4 diferentes especies, ilustrando a
   variacao presente na distribuicao dos histogramas.
   Os calculos sao realizados para niveis de cinza e para cada um dos
   componentes cromaticos (R, G e B). No primeiro caso, a imagem cromatica da
   folha e convertida para niveis de cinza atraves da media dos componentes
   cromaticos. A partir dos niveis de cinza sao computados 4 caracteristicas para o
   desvio-padrao, das quais uma e realizada para a imagem padrao e as outras tres
   para a imagem apos sofrer convolucao com Gaussianas de diferentes desvios-
   padrao (multi-escala). A mesma estrategia e realizada para o calculo da entropia,
   onde tambem, sao extraidas 4 caracteristicas.
   352
   APLICACOES PARALELAS EM VISAO
   Cada um dos componentes cromaticos e considerado como um canal ou
   plano da imagem, sendo computados para cada um deles (R, G e B) as mesmas
   caracteristicas obtidas na imagem de niveis de cinza. Deste modo, o numero total
   de caracteristicas extraidas pelo modulo e de 32 para cada lado da folha,
   totalizando 64.
   A Figura 8.22 ilustra a variacao de histograma ocorrida entre 4 diferentes
   especies de folhas. O histograma foi obtido atraves da imagem de niveis de cinza.
   8.4.5.5 - TREINAMENTO E IDENTIFICACAO
   Tanto o treinamento quanto o reconhecimento sao processos centrados no
   modulo Treinamento e identificacao com base no vetor de caracteristicas que,
   como vimos, e calculado atraves do modulo Extracao de caracteristicas.
   Para o modulo Treinamento e identificacao o processo de treinamento
   consiste em calcular o vetor medio a partir do vetor de caracteristicas de cada
   amostra processada. Para isso o modulo recebe o vetor de caracteristicas do
   Controle central apos a amostra ser processada pelo modulo de Extracao de
   caracteristicas. Ao final do processamento de todas as amostras, o modulo realiza
   a media dos vetores, obtendo o vetor de caracteristica responsavel pelo modelo da
   especie. O vetor e armazenado juntamente com as informacoes de identificacao da
   especie adicionada ao sistema, na Base de dados.
   O reconhecimento pode ser efetuado de dois modos: dinamico e estatico. A
   identificacao estatica e realizada apos serem extraidas as caracteristicas das
   amostras. Compete ao modulo de treinamento e identificacao realizar a
   comparacao entre o modelo da amostra a ser classificada e os modelos
   armazenados na Base de dados. A comparacao e realizada em duas etapas. A
   primeira seleciona uma lista de provaveis especies, e na segunda etapa, esta lista e
   refinada. Na primeira etapa, apenas 63 das 165 caracteristicas sao consideradas. O
   modelo da primeira etapa de classificacao e definido como um ponto num espaco
   de 63 dimensoes. A lista de provaveis especies e obtida atraves da distancia
   euclidiana entre os dois modelos, sendo consideradas as especies que
   apresentaram a menor distancia ao modelo analisado (sao inseridas na lista as
   especies que possuem distancia menor que o limiar estipulado pelo sistema). O
   refinamento da lista e realizado utilizando as outras 102 carateristicas. E calculada
   a distancia euclidiana (102 dimensoes) entre os modelos da lista da primeira etapa,
   efetuando seu refinamento e obtendo deste modo a lista de identificacao, que pode
   353
   CAPITULO 8
   possuir um ou mais elementos ordenados segundo a probabilidade de identificar o
PA modelo analisado.
   O processo de identificacao dinamica e uma tentativa de aumentar a
   performance do reconhecimento. Diferentemente do processo de reconhecimento
   estatico, que aguarda ate que todas as caracteristicas sejam extraidas para iniciar a
   comparacao, a identificacao dinamica, e um processo simultaneo a extracao de
   caracteristicas. Isto e permitido devido a comunicacao entre os modulos Extracao
   de caracteristicas, Controle Central e Treinamento e identificacao, que permitem que cada caracteristica extraida seja enviada para o modulo de identificacao. Com
   base nelas, o modulo realiza uma busca no banco de dados, e monta uma lista com
   que se enquadram no perfil do modelo incompleto. Esta lista e enviada entao para o
   modulo Analise estatistica, que retorna outra lista, indicando quais sao as
   caracteristicas mais importantes para classificar as especies da lista que recebeu.
   Com base nessa informacao o modulo solicita ao Controle central para que sejam
   priorizados metodos cujas caracteristicas foram destacadas. O processo de
   identificacao dinamica finaliza quando as caracteristicas extraidas, montarem um
   modelo que, mesmo incompleto, satisfaca as condicoes estabelecidas pelo sistema,
   determinando o reconhecimento.
   O processo de identificacao dinamica e um modo experimental de operacao
   do TreeVis, que em certas situacoes consegue obter uma boa performance devido
   a limitacao da extracao de caracteristicas, como por exemplo no caso das especies
   com caracteristicas marcantes, cuja identificacao e realizada mesmo no modelo
   incompleto. Apresenta tambem situacoes onde nao promove aumento de
   performance, como e o caso das especies com caracteristicas medianas, que nao
   possibilitam uma boa identificacao com modelos incompletos. A principal
   desvantagem na utilizacao do reconhecimento dinamico esta nos erros de
   identificacao que o metodo acarreta. Assim, a identificacao dinamica deve ser
   considerada pelo menos a uma primeira instancia, como uma alternativa de
   reconhecimento aberta ao estudo cientifico dentro do projeto TreeVis.
   8.4.5.6 - ANALISE ESTATISTICA
   O modulo Analise estatistica tem a exclusiva finalidade de dar suporte ao
   modulo de treinamento e identificacao, quando e realizado reconhecimento
   dinamico. Basicamente sua funcao e determinar as caracteristicas mais divergentes
   dentro de um conjunto de vetores de caracteristicas, de modo a tornar possivel a
   354
   APLICACOES PARALELAS EM VISAO
   classificacao de modelos incompletos com razoavel precisao.
   O principal mecanismo utilizado no modulo e o calculo da matriz de
   covariancia (Equacao 8.10). Atraves da covariancia, e possivel diagnosticar o grau
   de similaridade entre as caracteristicas dos modelos.
   1
   =
   x i
   ( ) x
   x i
   ( ) x
   (8.10)
   a b
   ,
   ( a
   a )( b
   b )
PA N
   Determinada a matriz de covariancia, o modulo Analise estatistica, procura
   pelos menores elementos da matriz, correlacionados com as caracteristicas ja
   extraidas pelo sistema, montando uma lista das caracteristicas que possuem a
   maior chance de caracterizar o reconhecimento do modelo. O modulo conta
   tambem com uma tabela, indicando o tempo medio de duracao para a extracao das
   caracteristicas. Com base na tabela e na lista de caracteristicas, e elaborada uma
   nova lista, a qual e ordenada atraves da divergencia da caracteristica e de seu
   tempo de processamento, visando o aumento da performance no reconhecimento.
   8.4.6 - IMPLEMENTACAO PARALELA
   Como ocorre usualmente em sistemas de visao, o TreeVis requer grande
   demanda computacional, possuindo portanto um elevado tempo de execucao
   (Pentium II 400 MHz). A fim de melhorar a performance e consequentemente
   reduzir seu tempo de execucao, foi realizada a implementacao paralela do TreeVis,
   atraves de CVMP, possibilitando sua execucao em sistemas distribuidos.
   Os modulos do sistema TreeVis possuem razoavel autonomia e
   independencia, permitindo a exploracao de paralelismo. No entanto, o gargalo do
   sistema reside no modulo Extracao de caracteristicas, uma vez que concentra as
   diversas tecnicas e metodos de processamento de imagem e visao, que sao
   inumeras vezes mais lentas que os processos localizados nos demais modulos.
   Deste modo, a estrategia de paralelismo adotada explorou a concorrencia de seus
   submodulos.
   Foram incorporadas tres estrategias de paralelismo ao sistema: (i)
   replicacao dos modulos Extracao de caracteristicas, (i ) implementacao paralela
   deste modulo e (iii) a combinacao das duas estrategias anteriores.
   No primeiro caso a estrategia aproveita a necessidade do sistema a
   355
   CAPITULO 8
   multiplas amostras. Assim, com a replicacao dos modulos Extracao de
   caracteristicas, cada amostra e direcionada para um dos modulos, que as processa
   simultaneamente. A estrategia utilizada foi a fazenda de processadores, atraves da
   utilizacao do CVMP processor farm. Conforme mostrado na Figura 8.23, o sistema
   fica dividido entre mestre e escravos. Cada modulo escravo e constituido por um
   modulo de extracao de caracteristicas, ficando no modulo mestre todo o restante do
   sistema. O Controle central, principal unidade do mestre, fica incumbido de
   supervisionar, controlar e distribuir as tarefas (amostras) para os escravos. Essa
   estrategia possui como vantagem o balanceamento automatico, podendo ser
   utilizado um conjunto de maquinas heterogeneas, sem a necessidade de ser
   realizado qualquer tipo de balanceamento de carga. A estrategia apresenta uma
   boa performance dependendo do numero de amostras utilizadas, quanto maior o
   numero destas melhor o resultado. Quando o numero de amostras e
   consideravelmente maior que o numero de processadores, a taxa de desempenho
   obtido se torna um fator proximo do numero de unidades de processamento
   (escravos) do sistema, uma vez que o tempo gasto com o processamento e muito
   maior que o gasto na transferencia dos dados.
   ESCRAVOS
   Imagens
   Niveis de
   Treinamento
   Cin
PA Ni zvaeis de
   e
   Descricoes
   Cin
   Ni zvaeis de
   Niveis de
   Identificacao
   Cinza
   Listas de
   Cor Cin
   Ni zvaeis de
   caracteristicas
   Cor Cin
   Ni zvaeis de
   Cor Cinza
   Forma Cor
   Forma Cor
   Forma Cor
   Textura eForma
   Controle
   Base de Dados
   Complexida
   Textur de
   a Forma
   Central
   Analise
   Complexida
   Textur de
   a Forma
   estatistica
   Complexida
   Textur de
   a
   Histogram
   Co a
   mplexida
   Textur de
   a
   Histogram
   Co a
   mplexida
   Textur de
   a
   Histogram
   Co a
   mplexidade
   Histograma
   Histograma
   Histograma
   Estrutura de
PA Extracao de caracteristicas
   Scanner
   amostragem
   MESTRE
   Fig. - 8.23 - TreeVis com a estrategia de paralelismo processor farm .
   No segundo caso, e explorado o paralelismo dentro do modulo, atraves de
   concorrencia entre seus submodulos e tambem atraves da implementacao paralela
   356
   APLICACOES PARALELAS EM VISAO
   dos metodos e tecnicas (Capitulo 7). A exploracao do paralelismo consiste na
   divisao do modulo Extracao de caracteristicas em partes, executando-as em
   concorrencia. Devido a independencia e autonomia de seus submodulos, a divisao
   do modulo de extracao de caracteristicas e uma tarefa simples. Contudo a
   dificuldade reside no balanceamento de cargas do sistema. Em sistemas
   homogeneos, as partes deverao possuir a mesma demanda computacional, ao
   passo que em sistemas heterogeneos, elas deverao possuir cargas proporcionais
   as maquinas em que serao executadas. Implementamos duas diferentes
   configuracoes dessa estrategia, uma dividindo o modulo em tres partes e a outra
   em seis, ambas voltadas para sistemas distribuidos homogeneos (3 e 6 maquinas
   iguais).
   Niveis de
   Cinza
   Textura e
   Imagens
   Complexidade
   Treinamento
   e
   Descricoes
   Identificacao
   Listas de
   Histograma
   caracteristicas
   niveis de cinza
   Controle
   Base de Dados
   Central
   Analise
   estatistica
   Forma
   Estrutura de
   Cor
   Scanner
   amostragem
   Histograma
   Cor
   MESTRE
   Fig. - 8.24 - TreeVis - Exploracao de paralelismo atraves da particao do
   modulo Extracao de caracteristicas em 3 partes, executadas simultaneamente
   em processadores diferentes.
   A Figura 8.24 contem um diagrama ilustrativo da versao na qual o modulo
PA de extracao de caracteristicas e dividido em 3 partes com performances
   aproximadamente equivalentes. Nesta abordagem, somente o submodulo
   responsavel pelas medidas relativas a histogramas foi particionado, a fim de
   aproveitar as convolucoes com a gaussiana (multi-escala) realizados no modulo de
   357
   CAPITULO 8
   Cor nos histogramas multi-escala cromaticos. Atraves desta configuracao o TreeVis
   fica especificado para sistemas distribuidos constituidos de 3 maquinas
   homogeneas. Cada uma das maquinas devera executar um dos fragmentos do
   modulo de extracao de caracteristicas. O modulo mestre, responsavel pela
   supervisao e controle do sistema, e alojado (multitarefa) juntamente com o
   fragmento que agrupa os submodulos: Niveis de cinza, Textura e complexidade e
   histograma de niveis de cinza; uma vez que este possui o menor tempo de
   execucao.
   Lado B
   Textura e
   Complexidade
   Lado A
   Niveis de
   Histograma
   Cinza
   niveis de cinza
   Textura e
   Imagens
   Ampl. textura
   Treinamento
   Complexidade
   e
   Descricoes
   Identificacao
   Listas de
   Histograma
   caracteristicas
   niveis de cinza
   Lado A
   Forma
   Controle
   Base de Dados
   Central
   Analise
   estatistica
   Lado B
   Forma
   Lado B
   Estrutura de
   Cor
   Scanner
   amostragem
   Histograma
   Cor
PA Lado A
   Cor
   Histograma
   Cor
   Fig. - 8.25 - TreeVis - Exploracao de paralelismo atraves da particao do
   modulo Extracao de caracteristicas em 6 partes, executadas simultaneamente
   em processadores diferentes.
   Na Figura 8.25 e apresentada a versao do sistema para seis maquinas.
   Neste caso, cada uma das partes da fragmentacao anterior (Figura 8.24) foi dividida
   em duas partes, correspondentes aos lados da amostra. Devido a sua natureza, o
   modulo de extracao de caracteristicas pode ser ainda dividido em muitos outros
   fragmentos, podendo ate mesmo atingir niveis de paralelismo nos metodos e
   358
   APLICACOES PARALELAS EM VISAO
   tecnicas de processamento de imagens e visao (como Hough por exemplo),
   possibilitando configuracoes para sistemas distribuidos com maior quantidade de
   maquinas. Neste trabalho a divisao do modulo foi realizada em ate seis partes.
   A terceira estrategia (i i) de paralelismo consiste na combinacao das
   estrategias processor farm (i) e fragmentacao do modulo de extracao de
   carateristicas (ii). Nesse caso, o sistema possui as duas configuracoes, e
   dependendo do numero de amostras utilizadas escolhe uma ou outra configuracao
   para executar o sistema. Em sistema homogeneos, a primeira estrategia (i)
   apresenta uma performance melhor que a (ii), quando o numero de amostras e
   multiplo do numero de processadores ou quando o numero de amostras e grande e
   proximo ao multiplo dos processadores. A segunda, entretanto, possui performance
   superior que a primeira, quando o numero de amostras e menor que o numero de
   processadores, ou quando o numero de amostras e muito diferente do multiplo do
   numero de processadores.
   8.4.6.1 - RESULTADOS EXPERIMENTAIS
   Nesta subsecao vamos apresentar duas series de experimentos que
   comparam a performance das versoes paralelas do TreeVis frente a sua versao
   sequencial. Em todos os experimentos foram utilizados sistemas distribuidos
   homogeneos constituidos por maquinas AMD K6 II - 375 MHz conectadas via rede
   ethernet (padrao NE-2000) de 10 Mb/s. Na primeira serie de experimentos foram
   utilizadas 3 maquinas e na segunda foi realizada a simulacao de 6 maquinas. Cada
   serie de experimentos contem duas experiencias, uma voltada para a estrategia de
   paralelismo processor farm (i) e a outra para a estrategia (i ) (fragmentacao do
   modulo de extracao de caracteristicas).
   Fig. - 8.26 - Grafico do tempo de execucao da versao paralela (processor
   farm ). Nove amostras foram processadas.
   359
   CAPITULO 8
   No primeiro experimento da primeira serie foi realizado o reconhecimento de
   um especime constituido por 9 amostras. O experimento consistiu na comparacao
   entre a performance da versao paralela ( processor farm) frente a versao
   sequencial. A Figura 8.26 apresenta os resultados obtidos no experimento, nela
   temos um grafico do tempo de execucao da versao paralela do sistema ( processor
   farm). Como pode ser observado, nao ocorreram bolhas na execucao e o tempo
   gasto com a transferencia de dados foi praticamente desprezivel, de modo que a
   taxa de desempenho ( speed-up) do sistema paralelo ficou proxima do numero de
PA processadores (3).
   Na Figura 8.27 e mostrado o grafico do tempo de execucao da versao
   paralela do TreeVis (explorando o paralelismo do modulo de extracao de
   caracteristicas), comparada com sua versao sequencial. Na Figura 8.27a temos o
   resultado do processamento de tres amostras. Na maquina 1 foram executados os
   submodulos de cor e histograma cromatico, alem do mestre. Na maquina 2 o
   submodulo Forma e na maquina 3 os submodulos de niveis de cinza, textura e
   complexidade e, histograma de niveis de cinza. Na Figura 8.27b o tempo de
   execucao sequencial de uma amostra.
   (a)
   (b)
   Fig. - 8.27 - Graficos do tempo de execucao, comparando as versoes paralela
   e sequencial do TreeVis. (a) Execucao de tres amostras na versao paralela
   (fragmentacao do modulo de extracao de caracteristicas). (b) Execucao de
   uma amostra na versao sequencial.
   Embora esta estrategia paralela apresente uma performance superior a
   versao sequencial, obtendo uma maxima taxa de desempenho (Speed-up) de
   360
   APLICACOES PARALELAS EM VISAO
   aproximadamente 2,7, devido a seu balanceamento de carga, nao tao equilibrado
   quanto na implementacao anterior ( processor farm), apresentou uma performance
   menor. Devemos, entretanto, lembrar que para situacoes onde o numero de
   amostras nao e igual ao multiplo do numero de maquinas, surgem bolhas e a
   performance da implementacao processor farm cai, fazendo com que a estrategia
   de exploracao do modulo de extracao de caracteristicas apresente um desempenho
   superior, uma vez que nao possui limitacoes quanto ao numero de amostras.
   As Figuras 8.28 e 8.29 apresentam a segunda serie de experimentos, na
   qual sao utilizadas versoes paralelas ( processor farm e fragmentacao do modulo de
   extracao de carateristicas) configuradas para sistemas distribuidos compostos de
   seis maquinas. Seus resultados sao proporcionais aos obtidos nos experimentos
   anteriores. Na versao processor farm, a taxa de desempenho ficou novamente
   muito proxima ao numero de processadores utilizados (6). A versao seguinte,
   entretanto, apresentou uma pequena queda da taxa de desempenho,
   proporcionalmente ao experimento anterior (fig. 8.27), ficando em torno de 4,6. Isso
   se deve a um desequilibrio no balanceamento de cargas do sistema, que no
   entanto pode ser melhorado atraves de uma nova configuracao.
   Fig. - 8.28 - Grafico do tempo de execucao da versao paralela (processor farm )
   em sistema distribuido com 6 maquinas. Doze amostras foram processadas.
   361
   CAPITULO 8
   Fig. - 8.29 - Graficos do tempo de execucao, comparando as versoes paralela
   e sequencial do TreeVis. (a) Execucao de tres amostras na versao paralela
   (fragmentacao do modulo de extracao de caracteristicas). (b) Execucao de
   uma amostra na versao sequencial.
   8.4.7 - RECONHECIMENTO DE PLANTAS ARBOREAS
   A Tabela 8.3 apresenta a listagem das especies utilizadas nos experimentos
   realizados com o TreeVis. Estas especies caracterizam a flora brasileira, sendo
   nativas da mata atlantica (maior parte) e do cerrado. Alem desta, utilizamos ainda,
   cerca de 30 especies nao catalogadas, contendo plantas ornamentais e frutiferas
   exoticas e nativas, a fim de somar 59 categorias na base de conhecimento do
PA sistema. Com bases nessas amostras, pudemos realizar experimentos para a
   conducao do projeto (metodos, tecnicas, caracteristicas, etc.).
   A avaliacao do sistema TreeVis e uma tarefa bastante dificil, uma vez que o
   processo de reconhecimento depende de um grande numero de fatores (coleta dos
   dados, escolha da amostra, diferenca entre individuos da mesma especie, etc.).
   Embora nao disponhamos do controle desses parametros, ficando como sugestao
   para trabalhos futuros, realizamos um experimento a fim de avaliar, mesmo que de
   maneira bastante aproximada, o desempenho do sistema no reconhecimento das
   especies.
   362
   APLICACOES PARALELAS EM VISAO
   Familia
   Denominacao cientifica
   Denominacao popular
   ANACARDIACEAE
   Schinus terebinthifolius Raddi
   Aroeira pimenteira
   ANACARDIACEAE
   Tapirira guianensis Aubl.
   Peito de pomba
   APOCYNACEAE
   Rauwolfia sellowii
   Casca d'anta
   BIGNONIACEAE
   Tabebuia impetiginosa (Mart.) Standl.
   Ipe roxo
   BIGNONIACEAE
   Tabebuia vellosoi (Tol.)
   Ipe amarelo
   BIGNONIACEAE
   Tabebuia roseo-alba (Ridl.) Sand.
   Ipe Branco
   BOMBACACEAE
   Pseudobombax grandiflorum Mart. & Zucc.
   Imbirucu
   BOMBACACEAE
   Eriotheca candoleana
   Paina da mata
   BOMBACACEAE
   Chorisia speciosa (St. Hil.)
   Paineira
   BORAGINACEAE
   Patagonula americana L.
   Guaiuvira
   BORAGINACEAE
   Cordia sellowiana Cham.
   Cha de bugre
   BORAGINACEAE
   Cordia trichotoma (Vell.)
   Louro pardo
PA CECROPIACEAE
   Cecropia cineria
   Embauba
   FABACEAE
   Platycianus regnelli Benth.
   Pau Pereira
   FABACEAE
   Miroxyon peruiferum (L.) Harms.
   Cabreuva
   LECYTHIDACEAE
   Cariniana estrellensis (Raddi) Kuntze
   Jequitiba
   LEGUMINOSAE
   Caesalpinia echinata L.
   Pau-brasil
   LEGUMINOSAE
   Hymenea courbaril L.
   Jatoba
   LEGUMINOSAE CAESALPINOIDEAE
   Bauhinia forficata (Link)
   Pata de Vaca
   LEGUMINOSAE-PAPILONOIDEAE
   Ormosia arborea (Vell.) Harms
   Olho de cabra
   MELASTOMACEAE
   Tibouchina pranulosa (Cogn.)
   Quaresmeira
   MELASTOMACEAE
   Tibouchina mutabilis (Cong.)
   Manaca da Serra
   MYRTACEAE
   Syzyngium jambolanum
   Jambolao
   MYRTACEAE
   Eugenia Uniflora (L)
   Pitanga
   MYRTACEAE
   Psidium cattleianum (Sabine)
   Araca
   MYRTACEAE
   Psidium guajava (L.)
   Goiabeira
   MYRTACEAE
   Eugenia pyriformis (Camb.)
   Uvaia
   MYRTACEAE
   Myrciaria trunciflora (Berg)
   Jabuticabeira
   NYCTAGINACEAE
   Bougainvillea glabra (Choisy)
PA Primavera
   Tabela 8.3 - Especies utilizadas no experimento.
   Conquanto o sistema necessita de varias amostras para efetuar um
   treinamento satisfatorio, no experimento, realizamos o treinamento das especies a
   partir de uma unica amostra, a qual julgamos caracterizar a planta. Efetuado o
   treinamento das 59 especies, realizamos o reconhecimento de 283 amostras.
   Assim como no treinamento, o reconhecimento tambem exige que diversas
   amostras sejam utilizadas para classificar uma especie de forma satisfatoria.
   Entretanto, visando colocar o sistema em um situacao extrema, efetuamos o
   reconhecimento atraves de amostras constituidas por apenas uma folha. Dentre as
   283 amostras, foram identificas corretamente 226, sendo que o sistema cometeu 57
   erros no reconhecimento, estabelecendo uma margem de erro de
   aproximadamente 20%.
   363
   CAPITULO 8
   364
   CAPITULO
   9
   CONCLUSAO
   "In my experience, the best creative work is never done when one is unhappy."
   Albert Einstein
   CAPITULO 9
   366
   CONCLUSAO
   CAPITULO 9 - CONCLUSAO
   9.1 - COMENTARIOS FINAIS E CONTRIBUICOES
   Discutimos nesta tese uma serie de aspectos relacionados ao paralelismo
   em visao natural e artificial. Uma vez que o paralelismo em visao artificial esta
   diretamente relacionado a Computacao Paralela, iniciamos a abordagem a partir de
   uma revisao dos conceitos fundamentais dessa area, tanto do ponto de vista da
   arquitetura (hardware) quanto da programacao (software), com o intuito de fornecer
   aos leitores uma base substancial em Computacao Paralela, permitindo uma
   melhor interacao e compreensao aos assuntos tratados no decorrer da tese. Em
   visao natural, apos realizarmos uma revisao de visao biologica, partimos para uma
   discussao sobre o sistema de visao dos primatas sob o ponto de vista do
   paralelismo, onde abordamos varios aspectos, dos quais podemos destacar: (i)
   modularidade do cortex visual, (ii) especializacao funcional, (ii ) independencia dos
   modulos e atributos, (iv) distribuicao das informacoes ao longo do caminho visual,
   (v) independencia e autonomia do caminho parvo e magno celular, (vi) arquitetura
   de paralelismo multiniveis, (vii) mapeamento das informacoes nas areas corticais e
   (vi i) a integracao dos sinais, modulos e atributos visuais.
   A integracao entre o paralelismo em visao natural e artificial ocorre com a
   abordagem do projeto Cyvis-1. Fortemente inspirado na visao biologica, o Cyvis-1,
   apresenta diversas caracteristicas baseadas no paralelismo dos sistemas de visao
   natural, que nos permitiu analisar, discutir e sugerir diversos aspectos do
   paralelismo natural que podem contribuir para a eficiencia e o realismo dos
   sistemas de visao artificial. Entre os aspectos levantados e discutidos, podemos
   destacar: (i) modularidade, (i ) hierarquia, (i i) especializacao funcional, (iv)
   cooperacao entre subsistemas, (v) representacao da informacao em varios niveis
   de conhecimento, (vi) distribuicao de informacoes em arquitetura paralela de visao,
PA (vi ) integracao de atributos e modulos concorrentes, (vi i) granularidade de pacotes
   entre os niveis hierarquicos, (ix) supervisao e controle dos processos visuais, (x)
   processamento visual em tempo real, etc. Realizamos tambem uma serie de
   comparacoes e analises criticas entre o projeto Cyvis-1 e outros sistemas de visao
   encontrados na literatura, que apresentam alguns aspectos semelhantes.
   367
   CAPITULO 9
   Neste trabalho verificamos que o paralelismo e inerente a visao natural,
   constituindo a base de sua arquitetura e podendo possibilitar uma serie de
   beneficios aos sistemas de visao artificial. No entanto, constatamos que o
   paralelismo e pouco explorado em visao computacional, estando praticamente
   ausente se considerarmos sua importancia, constituindo assim, uma lacuna no
   estudo da visao. Acreditamos que as razoes para a ausencia de paralelismo na
   visao artificial estao fundadas na propria Ciencia da Computacao, sendo esta o
   alicerce do estudo da visao artificial. Qualquer um que ja tenha um dia desenvolvido
   e implementado um algoritmo paralelo, sabe das inumeras dificuldades no
   desenvolvimento de software paralelo. A programacao concorrente e uma tarefa
   ardua e complicada que, alem de requerer um profundo conhecimento no assunto,
   exige um trabalho muito maior que o realizado nas solucoes sequenciais. Estas
   dificuldades sao acentuadas pela escassez de ferramentas computacionais
   amigaveis e intuitivas, baseadas na interacao homem-maquina, para o
   desenvolvimento de aplicacoes paralelas.
   Alem do perfil cientifico e tecnologico no projeto Cyvis-1, devemos levar em
   conta o trabalho humano envolvido sob o ponto de vista do desenvolvimento e
   implementacao. Estando o Cyvis-1 fortemente inspirado nos beneficios do
   paralelismo em visao, surge a tona as dificuldades da programacao concorrente.
   Uma vez que o Cyvis-1 e um projeto complexo, modular e de longa duracao, que
   abrange diferentes especializacoes em visao (atributos visuais) e portanto possui
   varios pesquisadores envolvidos, surgem tambem as questoes da manutencao e
   reutilizacao de codigo e da integracao e cooperacao entre os pesquisadores. Um
   dos principais objetivos deste trabalho foi apresentar as solucoes para estes
   problemas e assim propor uma plataforma de desenvolvimento para o projeto
   Cyvis-1.
   A fim de atender as necessidades de paralelismo do Cyvis-1 e dos demais
   projetos de nosso grupo (Cybernetic Vision Research Group), introduzimos uma
   nova plataforma de desenvolvimento de programacao concorrente denominada
   CVMP (Cybernetic Vision Message Passage). Baseado em programacao orientada
   a objetos, interface homem-maquina, engenharia de software e programacao visual,
   o CVMP e uma proposta para facilitar e simplificar o desenvolvimento de programas
   paralelos, seja atraves de sistemas distribuidos ou maquinas multiprocessadores.
   Atraves do CVMP, qualquer programador com um conhecimento reduzido em
   Computacao Paralela pode desenvolver com facilidade suas proprias aplicacoes
   368
   CONCLUSAO
   paralelas. Alem da facilidade de utilizacao, o CVMP tambem apresenta recursos
   para a reutilizacao de codigo, permitindo que as estruturas e algoritmos possam ser
   reaproveitados, agilizando o desenvolvimento de sistemas.
   Dentre os componentes que compoem o CVMP, o CVMP processor farm,
   em especial, ilustra as possibilidades de reutilizacao de codigo, facilidade e
   simplicidade no desenvolvimento de aplicacoes paralelas. Este componente possui
PA encapsulados todos os recursos necessarios para o desenvolvimento de uma
   aplicacao paralela baseada na estrategia processor farm, permitindo que o
   programador desenvolva um programa concorrente de forma visual.
   Diferente da programacao sequencial, na programacao concorrente e
   necessario ao programador analisar a execucao do programa, de modo a localizar
   os gargalos do sistema e efetuar o balanceamento de cargas, permitindo ampliar a
   sua performance e eficiencia. Uma grande limitacao dos ambientes de
   desenvolvimento paralelo esta na falta de suporte para tais analises, tornando-as
   uma tarefa ardua e dificil a ser realizada pelo programador. A fim de suprir essas
   limitacoes e auxiliar o programador nas analises estatisticas dos programas
   concorrentes, o CVMP apresenta ferramentas de analise estatistica, que permitem
   o monitoramento e a analise dos programas em duas diferentes modalidades:
   dados analisados apos o termino dos processos ou em tempo de execucao.
   O CVMP foi desenvolvido para ser utilizado na plataforma Delphi/C++
   Builder (Windows NT/9X), aproveitando os recursos computacionais destes
   ambientes de desenvolvimento (OOP, programacao visual, etc.), e permitindo que
   os programadores utilizem as linguagens e os ambientes sequenciais a que estao
   familiarizados no desenvolvimento das aplicacoes paralelas. Entretanto, gracas a
   sua concepcao, o CVMP se comporta como uma camada adicional de software,
   que gerencia as primitivas de comunicacao do sistemas operacional, podendo,
   deste modo, atuar em sistemas distribuidos ou multiprocessadores (memoria
   compartilhada). Devido a essa caracteristica, o CVMP pode ser desenvolvido de
   modo a utilizar sistemas de troca de mensagens ja existentes, tais como o PVM ou
   MPI, permitindo um desenvolvimento simples, amigavel, e os beneficios da OOP
   (programacao visual, reutilizacao de codigo, etc.).
   Outra caracteristica do CVMP, devido a sua versatilidade, e a possibilidade
   de fornecer a base para o desenvolvimento de novas arquiteturas paralelas. Uma
   vez que o CVMP apresenta um codigo simples e enxuto (componente CVMP basico
   com cerca de 980 linhas) e pode ser baseado em qualquer mecanismo de
   369
   CAPITULO 9
   comunicacao, ele pode ser utilizado como plataforma de desenvolvimento de
   software para novas arquiteturas. Um bom exemplo para essa aplicacao, seriam as
   arquiteturas baseadas em interface SCSI [Henry et al., 1998] [Mattson & Henry,
   1998] [Phillips, 1998] que, por estarem em desenvolvimento, podem nao apresentar
   dispositivos de comunicacao prontos para utilizarem por exemplo ferramentas
   convencionais de desenvolvimento paralelo (MPI, PVM, etc.). Uma vez que o
   CVMP pode ser facilmente adaptado a qualquer mecanismo de comunicacao, ele
   pode fornecer a base para o desenvolvimento para novas arquiteturas paralelas.
   No decorrer do trabalho, observamos que os problemas que afligiam o
   desenvolvimento do Cyvis-1 nao estavam apenas limitados ao seu universo, mas
   sim poderiam preencher de certo modo a lacuna do paralelismo em visao, e
   tambem de diversas outras areas cientificas que demandam solucoes paralelas.
   Deste modo, a proposta CVMP nao apenas cumpriu seus objetivos iniciais como
   tambem possibilitou um vasto campo de utilizacao, abrindo inumeras perspectivas
   para esta proposta. Voltaremos a este assunto na secao 9.3, na qual sao discutidos
   seus desenvolvimentos futuros.
   Uma vez definida a proposta de paralelismo, um dos objetivos foi avaliar,
   analisar e validar o CVMP, nos aspectos de funcionalidade, performance e
   utilizacao. Esse objetivo foi satisfeito atraves de uma serie de implementacoes de
PA algoritmos de visao computacional e de processamento de imagens. Foram
   implementados diversos algoritmos classicos na area, tais como operadores locais,
   transformada de Hough, transformada de Fourier e outros. Em cada um dos casos
   foi discutida a arquitetura e abordagem paralela, assim como analisada a
   performance e eficiencia da versao paralela dos algoritmos frente a sequencial. Os
   algoritmos foram analisados atraves dos modulos de estatistica do CVMP, os quais
   permitiram um estudo sobre seu comportamento, eficiencia e performance, gerando
   resultados que validaram a proposta e demonstraram sua performance e potencial
   para desenvolvimento de aplicacoes paralelas. Dentro dessa analise foi ainda
   introduzida uma nova tecnica de paralelismo para um novo algoritmo de
   segmentacao de imagens baseado em campos aleatorios de Markov [Bruno &
   Costa, 2000].
   Finalizando o trabalho, foram apresentadas 3 aplicacoes reais de visao
   artificial que utilizam diferentes conceitos de paralelismo. Tais aplicacoes nao
   apenas concluem a validacao da ferramenta de desenvolvimento paralelo
   desenvolvida no decorrer deste doutorado, como tambem demonstram diferentes
   370
   CONCLUSAO
   vantagens na utilizacao de paralelismo em sistemas de visao, tais como: aumento
   de performance, integracao entre atributos visuais, modularidade, independencia
   modular e integracao entre pesquisadores. Duas dessas aplicacoes foram
   desenvolvidas em conjunto com outros membros do grupo de Visao Cibernetica,
   assim permitindo avaliarmos o paralelismo e o CVMP como integradores de
   trabalho. A integracao entre pesquisadores ocorre devido a natureza do
   paralelismo, que exige uma estrutura modular e independente e que propicia o
   trabalho cooperativo. Quanto ao CVMP, a possibilidade de utiliza-lo em projetos
   cooperativos reais foi de grande valia para comprovar sua simplicidade de utilizacao
   (manuseio amigavel), facilidade, interacao homem-maquina, integrar pesquisadores
   em trabalhos paralelos cooperativos e reutilizacao de codigo. Deste modo, os
   otimos resultados obtidos com o CVMP na implementacao destas 3 aplicacoes foi
   uma convincente maneira de demonstrar que os objetivos da proposta foram
   satisfeitos.
   Todas as 3 aplicacoes discutidas nesta tese sao ineditas, constituindo por si
   so contribuicoes originais. A primeira delas contem uma proposta para a integracao
   de atributos visuais (cor e estereo) dentro do projeto Cyvis-1, a partir do
   paralelismo. Desenvolvida por Jander Moreira e Alan Salvany Felinto, em
   colaboracao com autor, o sistema foi implementado em CVMP, tendo como
   finalidade a identificacao de objetos poliedricos cromaticos atraves da integracao
   entre os atributos visuais cor e estereo. Aqui foi apresentado o primeiro prototipo do
   sistema Cyvis-1, e diferente das outras duas aplicacoes, o paralelismo e visto como
   um agente de integracao, uma vez que a implementacao nao objetiva a
   performance de processamento. Alem da integracao dos atributos visuais, a
   aplicacao ilustrou tambem o paralelismo como fonte de modularizacao e
   consequentemente como base de apoio para o trabalho cooperativo.
   Na segunda aplicacao foi implementado um experimento no projeto
   ynergos. Desenvolvido em colaboracao com Luis Augusto Consularo e Roberto
   Cesar Marcondes Jr. [Bruno et al., 2000], a aplicacao constitui um experimento para
   um modelo de complexidade baseado na percepcao humana. Atraves de um
   experimento psicofisico, sao coletados dados que refletem a percepcao de
   complexidade humana. O modelo e baseado em 4 tecnicas de medidas de
PA complexidade: (i) Entropia dos niveis de cinza, (ii) Tempo de decaimento multi-
   escala da variancia da distribuicao dos niveis de cinza da imagem (variancia do
   histograma), (i i) circularidade e (iv) dimensao fractal por salsichas de Minkowski.
   371
   CAPITULO 9
   Com base nos dados do experimento psicofisico, as tecnicas sao otimizadas
   atraves de um algoritmo genetico paralelo, implementado atraves do CVMP
   processor farm. Neste experimento, o paralelismo foi utilizado para aumentar a
   performance do processo de otimizacao realizado pelo algoritmo genetico. A
   performance da implementacao paralela foi bastante satisfatoria, apresentando uma
   taxa de desempenho proxima ao numero de processadores utilizados.
   Na terceira aplicacao foi introduzida uma proposta do autor, de um sistema
   de visao paralela para o reconhecimento automatico de plantas arboreas. A fim de
   desenvolvermos uma aplicacao real para visao paralela, procuramos identificar um
   problema de relevancia, onde pudessemos contribuir para sua solucao. Em
   botanica, e de extrema importancia o estudo da biodiversidade, sendo assim e vital
   o levantamento arboreo das florestas tropicais, uma vez que estas apresentam a
   maior biodiversidade do planeta. Foi introduzida nesta tese a proposta de um
   sistema, que fornece aos botanicos uma ferramenta complementar aos tradicionais
   herbarios. Intitulado TreeVis, o sistema de visao em questao extrai uma serie de
   atributos de folhas de plantas arboreas e, atraves de classificador estatistico,
   procura identificar o especime, funcionando como um herbario automatico. O
   sistema e baseado em uma arquitetura paralela, utilizada para aumentar o
   desempenho dos processos de treinamento e reconhecimento. Atraves de uma
   heuristica especial, tomada a partir do numero de amostras a ser processada, o
   sistema escolhe qual estrategia de paralelismo realiza a tarefa com a melhor
   performance. Os resultados obtidos comprovaram mais uma vez o potencial do
   CVMP no fornecimento das bases computacionais para o desenvolvimento de
   paralelismo, mesmo em situacoes complexas.
   9.2 - SINTESE DAS PRINCIPAIS CONTRIBUICOES
   Embora inter-relacionados, os assuntos abordados nesta tese podem ser
   divididos em tres modalidades, relacionadas da seguinte forma: (i) discussao do
   paralelismo em visao natural e artificial; (ii) proposta CVMP e (iii) aplicacoes
   paralelas reais em visao artificial. Seguindo essa divisao, foi montada a tabela 9.1,
   que apresenta a sintese das principais contribuicoes de cada modalidade.
   372
   CONCLUSAO
   ABORDAGEM
   CONTRIBUICOES
   * Revisao bibliografica critica e abrangente de computacao paralela.
   * Discussao do sistema de visao cortical dos primatas sob o ponto de
   vista do paralelismo.
   Discussao do
   * Levantamento das principais questoes, adotadas no sistema de visao
   paralelismo em visao
   dos primatas, que podem aperfeicoar os sistemas de visao artificial.
   natural e artificial
   * Levantamento de sistemas de visao e comparacao com o Cyvis-1.
   * Discussao das abordagens de paralelismo no projeto Cyvis-1
   * Levantamento das possiveis contribuicoes fornecidas pelo
PA paralelismo em visao artificial.
   * Proposta de um conjunto de ferramentas para o desenvolvimento de
   aplicacoes paralelas, com base na simplicidade de utilizacao
   (manuseio amigavel), facilidade, programacao visual e reutilizacao de
   codigo - CVMP (Cybernetic Vision Message Passage).
   * Desenvolvimento, implementacao e validacao da proposta CVMP.
   Proposta CVMP
   * Ferramentas para a analise estatistica de programas concorrentes.
   * Implementacao e avaliacao do desempenho de diversos algoritmos
   de visao e processamento de imagens.
   * Tecnica de paralelismo para um novo algoritmo de segmentacao de
   imagens baseado em campos aleatorios de Markov.
   * Estrutura de paralelismo para a integracao de atributos visuais
   (estereo e cor) no projeto Cyvis-1, em colaboracao com os colegas
   Jander Moreira e Alan Salvany Felinto.
   * Experimento para extrair um modelo de complexidade baseado na
   percepcao humana, atraves da Internet, com abordagem paralela.
   Desenvolvido em colaboracao com Luis Augusto Consularo e Roberto
   Aplicacoes paralelas
   Cesar Marcondes Junior [Bruno et al., 2000].
   reais em visao artificial * TreeVis - Proposta e implementacao de um sistema para o
   reconhecimento automatico de plantas arboreas (herbario digital).
   * Arquitetura de paralelismo com heuristica seletiva, para diagnosticar
   automaticamente a melhor performance de atuacao (projeto TreeVis).
   * Demonstracao do paralelismo como base para estruturacao e
   modularizacao de sistemas de visao, de forma a contribuir com o
   trabalho cooperativo entre pesquisadores da area.
   Tabela 9.1 - Sintese das principais contribuicoes desta tese.
   373
   CAPITULO 9
   9.3 - PESQUISAS FUTURAS
   Uma das caracteristicas dos trabalhos multidisciplinares esta na diversidade
   de direcoes que eles motivam, possibilitando perspectivas tanto para sua
   continuidade quanto para o surgimento de novas linhas de pesquisa. Como seria de
   se esperar, as contribuicoes desta tese proporcionam diversos caminhos para
   estudos futuros, complementacoes do trabalho e novas linhas de pesquisa. Vamos
   fazer algumas sugestoes para a continuidade deste trabalho, obedecendo a divisao
   modular apresentada na secao anterior: (i) estudos de paralelismo em visao natural
   e artificial; (ii) proposta CVMP e (iii) aplicacoes paralelas reais em visao artificial.
   Estaremos tecendo um breve comentario em cada um dos itens das subsecoes
   seguintes.
   9.3.1 - ESTUDOS DE PARALELISMO EM VISAO NATURAL
   E ARTIFICIAL
   (i) Acompanhar o desenvolvimento da neurociencia: O cortex visual ainda e muito
   pouco compreendido, tornando sua pesquisa uma area fertil e produtiva, da qual
   provem com frequencia considerada, novos modelos, teorias e descobertas. Deste
   modo, o estudo do paralelismo em visao e uma tarefa continua, que exige o
   acompanhamento constante do desenvolvimento da neurociencia e areas
   relacionadas.
   (ii) Experimentos em modelos corticais artificiais: Modelos corticais artificiais
PA contribuem para a compreensao dos mecanismos corticais. O estudo do
   paralelismo no cortex visual atraves de simuladores neurologicos pode elucidar
   questoes e apresentar novas abordagens para sistema paralelos de visao artificial.
   (ii ) Caracterizacao do paralelismo em visao: Os estudos e implementacoes de
   paralelismo em sistemas de visao artificial, realizados neste trabalho, podem ser
   aprimorados e estendidos a fim de se obter uma caracterizacao mais formal e
   generica do paralelismo em visao artificial. Atraves da implementacao e estudo de
   diversos sistemas de visao artificial, poderao ser estimadas estatisticas para o
   comportamento do fluxo de mensagem, dependencia de dados e gargalos, ao longo
   da hierarquia do processamento visual.
   374
   CONCLUSAO
   9.3.2 PROPOSTA CVMP:
   (i) Validar a versao CVMP multiprocessadores: Embora tenha sido implementado e
   discutido o componente CVMP para maquinas multiprocessadores, a sua validacao
   foi realizada atraves de simulacoes, utilizando o mecanismo de multitarefa, ficando
   como uma tarefa para futuros desenvolvimentos do CVMP a sua avaliacao e
   validacao mais concreta em maquinas realmente multiprocessadas.
   (ii) Portar o CVMP para UNIX: Acreditamos que seria de grande importancia portar
   a ferramenta CVMP para o sistema operacional UNIX, especialmente por este
   constituir uma plataforma particularmente utilizada no desenvolvimento de
   aplicacoes paralelas. Uma versao UNIX das ferramentas CVMP traria beneficios
   tanto para a proposta CVMP, atraves de sua divulgacao, criticas e eventualmente
   contribuicoes do mundo UNIX, assim como para a propria comunidade UNIX, que
   possui como uma de suas principais deficiencias a ausencia de ferramentas que
   priorizem a interacao homem-maquina e o manuseio amigavel e intuitivo. A
   viabilizacao do CVMP para UNIX, se tornara possivel e sera justificada com o
   lancamento do ambiente de desenvolvimento Delphi para Linux, o Kylix, previsto
   para o segundo semestre de 2000.
   (ii ) Desenvolver o CVMP sobre plataformas PVM ou MPI: O CVMP pode ser
   desenvolvido para atuar sobre uma plataforma de troca de mensagens ja
   estabelecida. Uma linha de pesquisa que deve ser considerada como continuidade
   deste trabalho e o desenvolvimento de versoes CVMP sobre as plataformas PVM
   ou MPI. Uma vez que existe uma serie de trabalhos cientificos para essas
   plataformas, este desenvolvimento traria inumeros beneficios para a proposta
   CVMP, ampliando seus recursos e possibilidades de desenvolvimento paralelo. Do
   mesmo modo, essa linha de pesquisa podera proporcionar uma serie de
   contribuicoes, levando para estas plataformas os beneficios CVMP
   (desenvolvimento
   visual,
   manuseio
   amigavel,
   reutilizacao
   de
   codigo,
   desenvolvimento OOP, etc.).
   (iv) Novas arquiteturas: O CVMP pode ser considerado como uma camada extra de
   software sobre as primitivas de comunicacao, que pode utilizar virtualmente
   qualquer mecanismo ou plataforma para troca de mensagens. Assim, uma
   interessante linha de pesquisa na qual pode ser utilizada essa proposta seria o
PA desenvolvimento de novas arquiteturas paralelas. Uma das dificuldades nesse tipo
   de projeto se encontra na base de plataformas de desenvolvimento de software.
   375
   CAPITULO 9
   Uma vez que as tradicionais plataformas de desenvolvimento paralelo necessitam
   " drivers" e bibliotecas especificas, o CVMP pode ser bastante promissor nesta area,
   uma vez que possui um codigo simples e enxuto, que pode ser facilmente adaptado
   a virtualmente qualquer mecanismo de comunicacao. Um prova disto esta no inicio
   de seu desenvolvimento. Antes de ser implementado para redes de computadores,
   o CVMP possuiu uma versao experimental que implementava maquinas paralelas
   atraves de comunicacao com o porto paralelo (LPT, porta de impressora).
   (v) Encapsular outras estrategias de paralelismo: Um grande sucesso na proposta
   CVMP foi o encapsulamento da estrategia de paralelismo processor farm. Atraves
   deste componente, o desenvolvimento de aplicacoes paralelas baseadas nesta
   estrategia se tornou uma tarefa simples e objetiva, uma vez que o componente
   apresenta encapsulado todo o mecanismo envolvido nesta abordagem. No entanto,
   apenas uma estrategia de paralelismo foi encapsulada fazendo parte do conjunto
   de ferramentas CVMP, ficando como sugestao para futuros desenvolvimentos a
   incorporacao de novos componentes que encapsulem outras abordagens de
   paralelismo.
   (vi) Desenvolver objetos para metodos de visao computacional e processamento de
   imagens: Uma das caracteristicas da proposta CVMP e permitir a criacao de
   componentes personalizados, que encapsulam metodos e tecnicas. Embora
   tenham sido realizados estudos sobre alguns algoritmos de visao, apenas duas
   tecnicas foram encapsuladas, gerando componentes prontos para utilizacao. De
   forma a auxiliar o desenvolvimento de aplicacoes paralelas, seria interessante a
   criacao de diversos componentes com diferentes tecnicas de processamento e
   visao computacional encapsuladas.
   (vi ) Aperfeicoar o modulo de estatistica: Uma das limitacoes das ferramentas de
   estatistica apresentadas nesta tese, especialmente a versao em tempo real, esta no
   seu condicionamento a maquina, ou seja, nao foi desenvolvido uma versao da
   ferramenta que possibilita concentrar em um unico modulo a analise de
   comportamento de todas as maquinas da rede. Embora esse tipo de abordagem
   possa acarretar uma sobre carga de mensagens na rede, diversas situacoes
   justificam sua utilizacao.
   376
   CONCLUSAO
   9.3.3 - APLICACOES PARALELAS REAIS EM VISAO
   ARTIFICIAL
   9.3.3.1 - PROJETO CYVIS-1
   (i) Incorporacao de novos atributos visuais: No prototipo desenvolvido no grupo,
   apenas duas modalidades visuais foram consideradas. A proposta do Cyvis-1,
   entretanto, e baseada na integracao de diversos atributos visuais. Portanto, novas
   pesquisas deverao ser realizadas, especialmente na estrutura de comunicacao e
   representacao de informacoes, a fim de permitir que atributos adicionais sejam
   acrescentados no sistema.
   (ii) Reestruturacao do sistema priorizando a performance: Embora o paralelismo
   tenha sido utilizado no sistema enfocando os estudos de integracao de atributos
   visuais, representacao de dados e trabalho corporativo, sua reestruturacao visando
   ampliar a performance e independencia de dados entre os modulos seria bastante
PA interessante, uma vez que este e um dos principais objetivos da Computacao
   Paralela.
   (ii ) Insercao de novas estrategias de comunicacao e fluxo inverso de dados: O
   projeto Cyvis-1 preve varias etapas de comunicacao realizadas entre os atributos
   visuais em diferentes niveis hierarquicos do processamento, assim como o fluxo de
   informacoes nos dois sentidos ("top-down" e "botton-up"). Pesquisas deverao ser
   realizadas a fim de incorporar tais caracteristicas ao sistema.
   9.3.3.2 - PROPOSTA TREEVIS
   (i) Avaliacao do prototipo (identificacao das plantas arboreas): A avaliacao do
   prototipo TreeVis, realizada nesta tese, foi bastante sucinta. Apresentamos apenas
   um resultado para uma situacao extrema do sistema (pior situacao), que embora
   tenha mostrado bons resultados, nao relatou com a devida determinacao cientifica
   sua validacao. Pretendemos realizar novos experimentos a fim de determinar de
   maneira mais acurada as caracteristicas do prototipo, contendo resultados para as
   situacoes extremas e para as situacoes onde o sistema se apresente mais
   promissor (maior quantidade de amostras por especie) e tambem, se possivel, com
   um numero maior de especies arboreas.
   377
   CAPITULO 9
   (ii) Realizacao de estudo abrangente da natureza e diversidade morfologica das
   folhas: Para implementar o primeiro prototipo do TreeVis, adotamos algumas
   metodologias para a extracao de caracteristicas, que embora tenham sido
   escolhidas experimentalmente atraves de analises em alguns tipos de folhas, a
   pesquisa realizada nao foi suficientemente abrangente e acurada da forma exigida
   pelo problema. Para a continuidade da proposta TreeVis seria necessaria, uma
   vasta e abrangente investigacao sobre as caracteristicas morfologicas das folhas
   de plantas arboreas, de modo a definir de maneira mais precisa quais as
   metodologias e medidas se adequam melhor ao processo de classificacao das
   especies. Devido a divergencia das especies, acreditamos que deverao ser
   acrescidas muitas tecnicas de processamento e visao, a fim de obter bons
   resultados em bases com centenas ou milhares de especies.
   (ii ) Desenvolvimento de novos prototipos, dando continuidade a proposta: O
   reconhecimento automatico de plantas arboreas e um problema que esta longe de
   ser resolvido na sua integra. O prototipo apresentado nesta tese contem apenas os
   primeiros passos para uma solucao. Muito trabalho e pesquisa ainda sao
   necessarios, sugerindo numerosos outros prototipos para consolidar uma
   ferramenta consistente e definitiva para que o TreeVis possa vir a ser utilizado
   como um herbario digital.
   (iv) Adaptacao e extensao do sistema para outros problemas em ciencia teorica e
   aplicada: Embora voltado para a botanica, o ambiente e as estruturas de
   paralelismo desenvolvidas no prototipo TreeVis podem ser adaptadas e estendidas
   para outros problemas em ciencia teorica e aplicada incluindo, por exemplo,
   mineracao de dados em engenharia biomolecular (genetica).
   378
   BIBLIOGRAFIA
   BIBLIOGRAFIA
   [Almasi & Gottlieb, 1994] ALMASI, G. S.; GOTTLIEB, A. Highly Paral el Computing.
   2.ed. California, The Benjamin/cummings Publishing, 1994.
   [Amorin et al.,1988] AMORIN, C. L.; BARBOSA, V. C.; FERNANDES, E. S. T. Uma
   introducao a computacao paralela e distribuida. VI Escola de
PA Computacao, Campinas, UNICAMP, 1988.
   [Andrews & Schneider, 1983] ANDREWS, G. R.; SCHNEIDER, F. B. Concepts and
   Notations for Concurrent Processing. ACM Computing Surveys, v.15
   pp3-43, 1983.
   [Atkin, 1987] ATKIN, P. Performance Maximization. Technical note 17, Inmos Ltd.,
   Bristol, 1987.
   [Baber et al., 1993] BABER, C. ; HOYES, T. ; STANTON, N. A. Comparison of
   GUIs and CUIs: appropriate ranges of actions and the ease of use.
   Displays, v14, n4, pp207-215, 1993.
   [Bal ard & Brown, 1982] BALLARD, D. H ; BROWN, C. M. Computer Vision.
   Prentice-Hall, 1982.
   [Barlow & Mollom, 1982] BARLOW, H. B. ; MOLLON, J. D. The Senses, Cambridge
   University Press, 1982.
   [Bem-Ari, 1990] BEM-ARI, M. Principles of Concurrent and Distributed
   Programming. New York, Prentice Hall, 1990.
   [Benchmark] http://webopedia.internet.com/TERM/b/benchmark.html
   [Bennett, 1997] BENNETT, G. Designing TCP/IP Internetworks. John Wiley &
   Sons, 1997.
   [Besag, 1986] Besag, J. On the statistical analysis of dirty pictures. J. Roy.
   Statist.Soc. B, 48(3):259-302, 1986.
   [Biswas et al., 1998] BISWAS, M. K. ; GHOSE, T. ; GUHA, S. ; BISWAS, K. K.
   Fractal dimension estimation for texture images: A parallel approach.
   Pattern Recognition Letters, 19(1998) pp.309-313, 1998.
   [Blasdel, 1986] BLASDEL, G. Differential imaging of ocular dominance and
   orientation selectivity in monkey striate cortex. Nature, 321:579-585,
   1986.
   [Bogni & Marrone, 1991] BOGNI, C. J.; MARRONE, L. Arquitectura de
   379
   BIBLIOGRAFIA
   Computadoras. Rio de Janeiro, V Escola Brasileiro - Argentina de
   Informatica, 1991.
   [Bonhoeffer & Grinvald, 1991] BONHOEFFER, T. ; GRINVALD, A. Iso-orientation
   domains in cat visual cortex are arranged in pinwheel-like patterns.
   Nature, 353: 429-431, 1991.
   [Bonner, 1995] BONNER, P. Programacao Visual: Promessa/Realidade Windows
   Computing, v. 2, n.1, p.64-6, 68, 70, 72, 74-5, 1995.
   [Braham, 1996] BRAHAM, R. Toward an artificial eye, IEEE Spectrum, p.20-29,
   May 1996.
   [Braitenberg & Braitenberg, 1979] BRAITENBERG, V ; BRAITENBERG, C.
   Geometry of orientation columns in the visual cortex. Biological
   Cybernetics, 33:179-186. 1979.
   [Brawer, 1989] BRAWER, S. Introduction to Paral el Programming. San Diego, CA
   (USA), Academic Press, 1989.
   [Breton, 1991] BRETON, Philippe Historia da Informatica Sao Paulo, Ed. UNESP,
   1991
   [Brigham, 1988] BRIGHAM, E. O. The Fast Fourier Transform and its Applications.
   Prentice Hall, 1988.
   [Broca, 1861] BROCA, P. P. Perte de la parole, ramol isement chronique et
   destructuion partielle du lobe anterieure gauche du cerveau. Bull. Soc.
   Anthropol, v. 2, pp. 235-238.
PA [Bruce & Green, 1990] BRUCE, V. ; GREEN, P. Visual perception: physiology,
   psychology and ecology 2ed. London, Lawrence Erlbaum Associates,
   1990.
   [Bruno & Costa, 1996] BRUNO, O. M. ; COSTA, L da F. Towards Cost-Effective
   and Versatile Real-Time Vision Based on a Distributed System of
   Personal Computers. IEEE Proceedings - II Workshop on Cybernetic
   Vision. Sao Carlos, Brasil, 1996.
   [Bruno & Costa, 1997] BRUNO, O. M.; COSTA, L. da F. Versatile Real-Time Vision
   Based on a Distributed System of Personal Computers. Proceedings -
   Third IEEE International Conference on Engineering of Complex
   Computer Systems. Como, Italia, 1997.
   [Bruno & Costa, 2000] BRUNO, O. M.; COSTA, L. da F. Effective Image
   Segmentation with Flexible ICM-Based Markov Random Fields in a
   Distributed Systems of Personal Computers. Real-Time Imaging, artigo
   380
   BIBLIOGRAFIA
   submetido e aceito, aguardando publicacao.
   [Bruno et al., 1998] BRUNO, O. M., CESAR Jr., R.M., CONSULARO, L.A., and
   COSTA, L. F. Automatic feature selection for biological shape
   classification in ynergos. Proceedings 1998 International Symposium on
   Computer Graphics, Image Processing and Vision, Rio de Janeiro, RJ,
   IEEE Computer Society Press, pp 363-370, 1998.
   [Bruno et al., 2000] BRUNO, O. M., CESAR Jr., R.M., CONSULARO, L.A., and
   COSTA, L. F. ynergos - Synergetic Vision Research. Real Time Journal,
   artigo submetido e aceito, aguardando publicacao.
   [Bruno, 1995] BRUNO, O. M. Sistema Automatizado de Medidas TSC em
   Plataforma GUI Dissertacao de Mestrado, IFSC - USP, 1995.
   [Bruno, 1999] BRUNO, O. M. Exame de qualificacao, IFSC-USP, 1999.
   [Calvert, 1997] CALVERT, C. Borland C++ Builder unleashed. Sams, 1997.
   [Calvert, 1999] CALVERT, C. Delphi 4 unleashed. Sams, 1999.
   [Cantoni & Lombardi, 1999] CANTONI, V. ; LOMBARDI, L. Visual attention in
   artificial systems. Proceedings 1999 I International Seminar on
   Bioelectronic Interfaces and III Workshop on Cybernetic Vision,
   Campinas, Brazil, 1999.
   [Cantu,1995] CANTU, M. Mastering Delphi Sybex, 1995
   [Caserta et al., 1995] CASERTA, F. ; ELDRED, W. D. ;FERNANDEZ, E. ;
   HAUSMAN, R. E. ; STANFORD, L. R. ; BULDEREV, S. V. ;
   SCHWARZER, S. ; STANLEY, H. E. Determination of fractal dimension of
   physiological y characterized neurons in two and three dimensions.
   Journal of Neuroscience Methods. 56, pp. 133-144, 1995.
   [Castleman, 1996] CASTLEMAN, K.R. Digital Image Processing, Prentice-Hal ,
   Englewood Cliffs, NJ, 1996.
   [Cesar & Costa, 1998] CESAR Jr., R.M. and COSTA, L. F. Neural cel classification
   by wavelets and multiscale curvature, Biological Cybernetics, v.79, n.4,
   pp.347-360, 1998.
   [Cesar, 1997] CESAR Jr., R. M. Analise Multi-escala de formas bidimensionais.
   Tese de doutorado, IFSC - USP, 1997.
   [Chappel , 1998] CHAPPELL, L. A. Novel 's Guide to Lan/Wan Analysis : Ipx/Spx.
   Novell Press, 1998.
   [Chel appa & Jain, 1993] CHELLAPPA, R. ; JAIN, A, (eds.). Markov Random Fields.
PA Academic Press, 1993.
   381
   BIBLIOGRAFIA
   [Chu & George, 1999] CHU, E. ; GEORGE, A. Inside the FFT Black Box: Serial and
   Parallel Fast Fourier Transform Algorithms. CRC Press LLC, 1999.
   [Clark, 1986] CLARK, N. N. Three Techniques for Implementing Digital Fractal
   Analysis of Particle Shape .Powder Technology. 46, 1986.
   [Codenoti & Leoncini, 1994] CODENOTI, Bruno ; LEONCINI, Mauro.. Introducing to
   Paral el Processing. New York, Addison-Wesley, 1994.
   [Coelho, 1998] COELHO, R. C. Sintese, modelagem e simulacao de estruturas
   neurais morfologicamente realisticas. Tese de doutorado, IFSC - USP,
   1998.
   [Consularo & Costa, 1998] CONSULARO, L. A. ; COSTA, L. da F. MATCOM
   Integrates MATLAB Resources Into Standalone Applications. Computers
   in Physics, v12 n5 p460, 1998.
   [Consularo et al., 1999] CONSULARO, L. A. ; CESAR JR, R. M. ; COSTA, L. da F.
   ynergos and its application to contour segmentation. Proceedings 1999 I
   International Seminar on Bioelectronic Interfaces and III Workshop on
   Cybernetic Vision, Campinas, Brazil, 1999.
   [Costa & Sandler, 1993] COSTA, L. da F. ; SANDLER, M. B. Effective detection of
   digital bar segments with Hough transform. CVGIP: Gr. Models Imge
   Process: v.55, n.3, pp.180-191, 1993.
   [Costa & Slaets, 1991] COSTA, L. da F. ; SLAETS, J. F. W. On the efficiency of
   parallel pipelined architectures, IEEE Transactions on Signal Processing,
   39(9):2086-2089, 1991.
   [Costa & Velte, 1999] COSTA, L. F. and VELTE, T. Automatic characterization and
   classification of ganglion cells from the salamander retina, Journal of
   Comparative Neurology, v.404, n.1, pp.33-51, 1999
   [Costa et al., 1994] COSTA, L. da F. ; RODA, V. O. ; KOBERLE, R. A biological y-
   inspired system for visual pattern recognition. Proceedings - IEEE
   International Symposium on Industrial Electronics, Santiago, Chile, 1994.
   [Costa, 1996] COSTA, L. da F. Novas perspectivas em neuromorfologia e
   neuromodelagem, Tese de livre-docencia, IFSC - USP, 1996.
   [Cox, 1986] COX, Brad J. Object-Oriented Programming - AN Evolutionary
   Approach. New York, Addison-Wesley, 1986.
   [Darwin, 1859] DARWIN, C. R. On the Origin of Species by Means of Natural
   Selection - The Preservation of Favored Races in the Struggle for Life,
   London, 1859 (disponivel em http://www.literature.org/authors/darwin-
   382
   BIBLIOGRAFIA
   charles/the-origin-of-the-species/index.html).
   [Deatz, 1997] DEATZ, G. Sharing memory. Delphi Informant, v.3, n.11, 1997.
   [Dowling, 1992] DOWLING, J. E. Neurons and networks - An introduction to
   neurocience. The Belknap Press of Harvard University Press, 1992.
   [Duda & Hart, 1972] DUDA, R. O. ; HART, P. E. Use of the Hough transformation to
   detect lines and curves in pictures. Comunications of the ACM, v.15, n.1,
   pp11-15, 1972.
   [Duda & Hart, 1973] DUDA, R. O. ; HART, P. E. Pattern classification and scene
   analysis. John Wiley and Sons, Inc., New York, 1973.
   [Dumas, 1995] DUMAS, A. Programando winsock. Axcel Books, 1995.
PA [Duncan, 1990] DUNCAN, R. A Survey of Paral el Computer Architectures.
   Computer IEEE, v23, n 2, p 5-16, 1990.
   [Etter, 1995] ETTER, D. M. Introduction to MATLAB for engineers and scientists.
   Prentice-Hall, 1995.
   [Faber et al., 1987] FABER, V ; LUBECK, O. M. ; WHITE, A. B. Jr. Comments on
   the paper "Paral el efficiency can be greater than unity", Paral el
   Computing, 4:209-210, 1987.
   [Falconer, 1990] FALCONER, K. Fractal Geometry-Mathematical Foundations and
   Applications. John Wiley & Sons, 1990.
   [Faugeras, 1996] FAUGERA, O. Three-dimensional computer vision: a geometric
   viewpoint. MIT Press, 2nd ed. 1996.
   [Fernades et al., 1993] FERNANDES, Edil S. T.; AMORIN, Claudio, L. de
   Arquiteturas Paralelas Avancadas. Embalse, VI Escuela Brasileno -
   Argentina de Informatica, 1993.
   [Fernades, 1997] FERNANDES, I. Taxonomia e fitogeografia de Cyatheaceae e
   Dicksoniaceae nas Regioes Sul e Sudeste do Brasil. Tese de doutorado,
   IB (Instituto de Botanica) USP, 1997.
   [Flynn, 1966] FLYNN, M. J., Very High Speed Computing Systems Proc.IEEE Vol
   54, p 1901-9, 1966
   [Flynn, 1972] FLYNN, M. J. Some Computer Organizations and Their Effectiveness.
   IEEE Trans. Comput. C-21 p948-60, 1972
   [Foster, 1995] FOSTER, I. Designing and Building Paral el Program - Concepts and
   Tools for Paral el Software Engineering. New York, Addison-Wesley,
   1995.
   [Fritsch & Hitzig, 1870] Fritsch, G. ; Hitzig, E. Uber die elektriche erregbakeit des
   383
   BIBLIOGRAFIA
   grosshirns. Arch. F. Anat. Physiol. U. Wiss. Med., v.37, pp. 300-332.
   [Gazzaniga, 1998] GAZZANIGA, m. S. The split brain revisited Scientific American
   v. 279, n. 1, p 34-39, July, 1998.
   [Gehani, 1988] GEHANI, N. Ed. ; MCGETTRICK, A. Ed. Concurrent Programming.
   Wokingham, England, Addison-Wesley, 1988.
   [Geist et al., 1996] GEIST, BEGUELIN, DONGARRA, et al. PVM: Paral el Virtual
   Machine, A User's Guide and Tutorial for Paral el Computing, MIT Press,
   1996.
   [Geman & Geman, 1984] GEMAN, S. ; GEMAN, D. Stochastic relaxation, Gibbs
   distributions, and the Bayesian restoration of images. IEEE Transactions
   on Pattern Analysis and Machine Intel igence, vol. PAMI-6, n.6, november
   1984.
   [Gerig & Klein, 1986] GERIG, G. & KLEIN, F. Fast contour identification through
   efficient Hough transform and simplified interpretation strategy. In: Proc.
   8th Int. Conference on Pattern Recognition, vol. 1, pp. 498-500, Paris,
   France, October 27-31, 1986.
   [Gimarc & Milutinovic, 1987] GIMARC, C. E.; MILUTINOVIC, V. M. A survey of
   RISC processors and computers in the mid-1980s. IEEE Computer, 20(9),
   p59-69, Sep. 1987.
   [GNOME] www.gnome.org
   [Goldberg, 1989] GOLDBERG, D. E. Genetic algorithms in search, optimization, and
   machine learning, Addison-Wesley, 1989.
   [Goldstein, 1989] GOLDSTEIN, E. B. Sensation and Perception. Wadsworth
PA Publish Company, 1989.
   [Goldstine, 1993] GOLDSTINE. Herman H. The Computer from Pascal to Von
   Neumann. Princeton, Princeton University Press, 1993.
   [Gomes et al., 1999] GOMES, C. ; BUNKS C. ; CHANCELIER, J. ; STEER, S. ;
   NIKOUKHAH, R. Engineering and scientific computing with Scilab.
   Springer Verlag, 1999.
   [Goncalves, 1999] GONCALVES, S. E. Reconhecimento Visual Atencional. Tese
   de doutorado, COPPE, UFRJ, 1999.
   [Gonzalez & Woods, 1993] GONZALEZ, R. C. ; WOODS, R. E. Digital Image
   Processing. Addison-Wesley, 1993.
   [Gregory, 1987] GREGORY, S. Paral el Logic Programming in PARLOG, Addison-
   Wesley, 1987.
   384
   BIBLIOGRAFIA
   [Grimes, 1997] GRIMES, R. Professional DCOM programming. Wrox Press, 1997.
   [Guil & Zapata, 1997] GUIL, N.; ZAPATA, E. L. Fast Hough transform on
   multiprocessors: A branch and bound approach. Journal of Paral el and
   Distributed Computing, 45(1):82-89, August 1997.
   45(1):82-89, 25 August 1997. [BibTeX entry]
   [Hayes, 1990] HAYES, Frank From TTY to VUI. Byte, p205-211, Ap. 1990.
   [Henry et al., 1998] HENRY, G. ; FAY, P. ; COLE, B. ; MATTSON, T. G. The
   performance of the Intel TFLOPS supercomputer.
   http://developer.intel.com/technology/itj/q11998/articles/art_2.htm , 1998.
   [Hockney & Jesshope, 1988] HOCKNEY, R. W.; JESSHOPE, C. R. Paral el
   Computers 2. Philadelphia, IOP, 1988
   [Hodges, 1992] HODGES, Andrew Alan Turing: The Enigma London, Vintage,
   1992.
   [Hough, 1959] HOUGH, P. V .C. Machine Analysis of Bubble Chamber Pictures.
   International
   Conference
   on
   High
   Energy
   Accelerators
   and
   Instrumentation, CERN, 1959.
   [Hubel & Wiesel, 1977] Functional architecture of macaque monkey visual cortex.
   Ferrier Lecture, Proc. R. Soc. Lond. B. 198:1-59.
   [Hubel et al., 1977] HUBEL, D. H.; WIESEL, T. N.; STRYKER, M. P. Orientation
   columns in macaque monkey visual cortex demonstrated by the 2-
   deoxyglucose autoradiograph technique. Science, 269:328-330.
   [Hubel, 1995] HUBEL, D. H. Eye, brain and vision Scientific American Library,
   1995.
   [Hudak, 1989] HUDAK, P. Functional Programming Languages, ACM Computing
   Surveys, v. 21, pp359-411, 1989.
   [Hundert, 1995] HUNDERT, E. M. Lessons from an optical il usion: On nature and
   nurture, knowledge and values. Harvard University Press, 1995.
   [Hurson et al., 1993] HURSON, A. R. ; PAKZAD, S. H. ; CHENG, J. Object-
   Oriented Database Management Systems: Evolution and Performance
   Issues, Computer, v.26, n. 2, p. 48-60, 1993.
PA [Hwang et al., 1984] HWANG, Kai; BRIGGS, Faye A. Computer Architecture and
   Paral el Processing. New York, McGraw-Hil , 1984.
   [Inmos, 1988] INMOS Limited. Transputer Reference Manual. New York, Prentice
   Hall, 1988.
   [Inmos, 1988b] INMOS Limited. Occam2 Programming Manual, Prentice Hal , 1988.
   385
   BIBLIOGRAFIA
   [Inmos, 1989] Transputer Applications Notebook - Architecture and Software.
   Inmos, 1989.
   [Joly, 1993 JOLY, A. B. Botanica - Introducao a taxonomia vegetal. Companhia
   Editora Nacional, 11 edicao, 1993.
   [Julesz, 1995] JULESZ, B. Dialogues on perception. The MIT Press, 1995.
   [Kaye, 1989] KAYE, B. H. Image Analysis Techniques for Characterizing Fractal
   Structures. from The Fractal Approach to Heterogeneous Chemistry (D.
   Avnir, editor). John Wiley & Sons Ltd., 1989.
   [Kaye, 1994] KAYE, B. H. A Random Walk Through Fractal Dimensions: 2nd Edition.
   New York, VCH Publishers, 1994.
   [Kindermann and Snel , 1980] KINDERMANN, R. ; SNELL, J. L. Markov random
   fields and their applications. Contemporary Mathematics, American
   Mathematical Society, 1980.
   [Konopka, 1997] Konopka, R. Developing custom Delphi 3 components.
   Scottsdale, Arizona (USA), The Coriolis Group, 1997.
   [Kosslyn, 1996] KOSSLYN, S. M. Image and Brain: The resolution of the imagery
   debate. The MIT Press, 1996.
   [Kovacs, 1996] KOVACS, Z. L. Redes neurais artificiais: Fundamentos e
   aplicacoes. Sao Paulo, Edicao Academica, 1996.
   [Kovacs, 1997] KOVACS, Z. L. O cerebro e a sua mente: Uma introducao a
   neurociencia computacional. Sao Paulo, Edicao Academica, 1997.
   [Krishnamurthy, 1989] KRISHNAMURTHY, E. V. Paral el Processing: Principles
   and practice. Sydney, Addison-Wesley, 1989.
   [Kung et al., 1987] KUNG, S. Y. et al. Wavefront Array Processors - Concept to
   Implemention. Computer IEEE, 20(7), p18-33, Jun. 1987.
   [Kylix] http://www.borland.com/about/press/2000/kylixkickstart.html , Abril, 2000.
   [Leventhal, 1988] LEVENTHAL, Lance Lance Leventhal's 80386 Programming
   Guide Toronto, Bantam Book, 1988.
   [Levine & Shefner, 1991] LEVINE, M. W. ; SHEFNER, J. M. Fundamentals of
   sensation and perception. Brooks/Cole Publishing, 1991.
   [Levine, 1985] LEVINE, M. D. Vision in man and machine. N. York, McGraw-Hil ,
   1985.
   [Li, 1995] LI, S. Z. Markov random field modeling in computer vision. Springer-
   Verlag, 1995.
   [Livingstone & Hubel, 1988] LIVINGSTONE, M. ; HUBEL, D. Segregation of form,
   386
   BIBLIOGRAFIA
   color, movement and depht: anatomy, physiology and perception.
   Science, v.240 p.740-749, 6 May 1988.
   [Lorenzi, 1992] LORENZI, H. Arvores brasileiras: Manual de identificacao e cultivo
   de plantas arboreas nativas do Brasil. Editora Plantarum, 1992.
   [Machado, 1993] MACHADO, A. B. M. Neuroanatomia funcional. 2.ed. Sao Paulo,
   Atheneu, 1993.
PA [Mandelbrot, 1977] MANDELBROT, B. B. Fractals: Form, Chance and Dimension.
   W. H. Freeman and Company, 1977.
   [Mandelbrot, 1983] MANDELBROT, B. B. The fractal geometry of nature. W. H.
   Freeman and Company, 1983.
   [Marr, 1982] MARR, D. Vision - A computational investigation into the human
   representation and processing of visual information. New York, W. H.
   Freeman and Company, 1982.
   [Mattson & Henry, 1998] MATTSON, T. G. ; HENRY, G. An overview of the Intel
   TFLOPS supercomputer.
   http://developer.intel.com/technology/itj/q11998/articles/art_1.htm , 1998.
   [McCulloch & Pitts, 1943] MCCULLOCH, W. ; PITTS, W. A logical calculus of the
   ideas immanent in nervous activity. Bulletin of Mathematical Biophysics,
   1943.
   [Mel, 1997] MEL, B. W. SEEMORE: Combining color, shape, and texture
   histogramming in a neurally inspired approach to visual object recognition.
   Neural Computation, v.9 pp.777-804, 1997.
   [Morante et al., 1999] MORANTE, S. ; ROSSI, G. ; SALINA, G. A paral el fast
   Fourier transform. International Journal of Modern Physics C, Vol. 10, No.
   5, pp. 781-805, 1999.
   [Moreira et al., 1999] MOREIRA, J. ; FELINTO, A. S. ; COSTA, L. F. Cyvis-1:
   Integration of Color and Stereo. International Workshop on Synthetic-
   Natural Hybrid Coding on 3D imaging. Santorini, Greece, September 15-
   17, 1999.
   [Moreira, 1999] MOREIRA, J. Uma proposta de estruturacao e integracao de
   processamento de cores em sistemas artificiais de visao. Tese de
   doutorado, IFSC - USP, 1999.
   [Mullender et al., 1990] MULLENDER, S. J.; ROSSUM, G.; TANENBAUM, A. S.;
   RENESSE, R.; STAVEREN, H. Amoeba: A Distributed Operating System
   for the 1990s. IEEE Computer, vol. 23, pp. 44-53, May 1990.
   387
   BIBLIOGRAFIA
   [Naiditch, 1995] NAIDITCH, D. Rendezvous with Ada 95, John Wiley & Sons, 1995.
   [Nazif & Levine, 1984] NAZIF, A. M. ; LEVINE, M. D. Low level image
   segmentation: An expert system. IEEE Transactions on Pattern Analysis
   and Machine Intelligence. V.PAMI-6, n.5, September, 1984.
   [Nelson, 1989] NELSON, M. LZW data compression. Dr. Dobb's Journal, October
   1989.
   [Oppenheim & Schafer, 1975] OPPENHEIM, A.V. ; SCHAFER, R.W. Digital Signal
   Processing, Prentice Hall, 1975.
   [Pacheco, 1997] PACHECO, Peter. Paral el Programming with MPI, Morgan
   Kaufmann, 1997.
   [Parker, 1997] PARKER, J. R. Algorithms for Image Processing and Computer
   Vision. John Wiley & Sons, 1997.
   [Peddie, 1992] PEDDIE, Jon Graphical User Interfaces and Graphic Standards.
   New York, McGraw Hil , 1992.
   [Peitgen & Saupe, 1988] PEITGEN, H. O. ; SAUPE, D. The science of fractal
   images. Springer-Verlag, New York, 1988.
   [Peixoto & Barbosa, 1998] PEIXOTO, A. L. ; BARBOSA, M. R. V. Os herbarios
   brasileiros e a flora nacional: Desafios para o seculo 21. Sistemas de
   informacao sobre biodiversidade/biotecnologia para o desenvolvimento
PA sustentavel, 1998. - http://www.bdt.org.br/oea/sib/
   [Penrose, 1989] PENROSE, R. The emperor's new mind: Concerning computers,
   minds, and the laws of physics. Oxford University Press, 1989.
   [Petzold & Yao, 1996] PETZOLD, C. ; YAO P. Programming Windows 95.
   Redmond, Microsoft Press, 1996
   [Pfister, 1995] PFISTER, G. F. In Search of Clusters, New York, Prentice Hal , 1995.
   [Phil ips, 1998] PHILLIPS, B. Have storage area networks coming out of age? IEEE
   Computer, p10-12, July, 1998.
   [Poggio & Weinshal , 1993] POGGIO, T. ; WEINSHALL, D. The MIT vision
   machine: Progress in the integration of vision modules. In: CHELLAPA,
   R. ; JAIN, A. Markov random fields: Theory and application. Academic
   Press, Boston, 1993.
   [Poggio et al., 1985] Poggio, T. ; Torre, T. ; Koch, C. Computational vision and
   regularization theory. Nature, 317:314-319, 1985.
   [Pratt, 1984] PRATT, T. W. Programming Languages - Design and Implementation,
   New York, Prentice Hall, 1984.
   388
   BIBLIOGRAFIA
   [Preece et al., 1994] PREECE, J. ; ROGERS, Y. ; SHARP, H. ; BENYON, D.
   Human-Computer interaction. Addison-Wesley, 1994.
   [Pressman, 1988] PRESSMAN, R. Software Engineering. New York, McGraw Hil ,
   1988.
   [PVM]
   Paral el
   Virtual
   Machine
   -
   Home-Page.
   http://www.epm.ornl.gov/pvm/pvm_home.html
   [Qian, 1997]Qian, N. Physiological computation of binocular disparity . Vision Res.,
   37(13):1811-1827, 1997
   [Quinn, 1987] QUINN, M. J. Designing efficient algorithms for paral el computers.
   [Richter, 1995] RICHTER, J. Advanced Windows. Microsoft Press, 1995.
   [Rol s et al., 1994] ROLLS, E. T ; TOVEE, M. J. ; PURCELL, D. G. ; STEWART A.
   L. ; AZZOPARDI, P. The responses of neurons in the temporal cortex of
   primates and face identification and detection. Experimental Brain
   Research, n. 101, p473-484, 1994.
   [Rosenberry et al., 1992] ROSENBERRY, W.; KENNEY, D.; FISHER, G.
   Understanding DCE. Sebastopol, O'Reilly, 1992.
   [Ryan, 1992] RYAN, B. Built for speed Byte, p123-129, Feb. 1992.
   [Schalkoff, 1989] SCHALKOFF, R. F. Digital image processing and computer
   vision. John Wiley and Sons, 1989.
   [Schmidt, 1980] SCHMIDT, R. F. Fisiologia Sensorial. EDUSP, 1980.
   [Shapley & Perry 1986] SHAPLEY, R. ; PERRY, V. Cat and monkey retinal
   ganglion cel s and their visual functional roles. Trends in Neuroscience, v9
   p.229-235, 1986.
   [Shirai, 1987] SHIRAI, Y. Three-dimensional computer vision. Springer-Verlag,
   1987.
   [Smith et al., 1996] SMITH, T. G. ; LANGE, G. D. ; MARKS, W. B. Fractal Methods
   and results in cellular morphology - dimensions, lacunarity and
PA multifractals. Journal of Neuroscience Methods. 69, pp.123-136, 1996
   [Snow, 1992] SNOW, C. R. Concurrent Programming. Cambridge, Cambridge
   University Press, 1992.
   [Sobel, 1970] SOBEL, I. E. Camera models and machine perception. Ph.D. Thesis,
   Stanford University, 1970.
   [Spufford & Uglow, 1997] SPUFFORD, F. ; UGLOW, J. Cultural Babbage -
   Technology, Time and Invention London, Faber and Faber, 1997.
   [Stace, 1984] STACE, C. A. Plant Taxonomy and Biosystematics, London, Edward
   389
   BIBLIOGRAFIA
   Arnold, 1984.
   [Stanley, 1986] STANLEY, H. E. Form: An introduction to self-similarity and fractal
   behavior, in: STANLEY, H. E. ; OSTROWSKY, N. On Growth and form -
   Fractal and non-fractal patterns in physics. Martinus Nijhoff Publishers,
   Dordrecht, The Netherlands, p. 21-53, 1986.
   [Stuessy, 1990] STUESSY, T. F. Plant Taxonomy (The systematic Evaluation of
   Comparative data). New York, Columbia University Press, 1990.
   [Tabak, 1990] TABAK, Daniel RISC systems Taunton, Research Studies Press,
   1990.
   [Tanenbaum, 1989] TANENBAUM, Andrew S. Computer Networks. Englewood
   Cliffs, Prentice-Hall, 1989.
   [Tanenbaum, 1990] TANENBAUM, Andrew S. Structured Computer Organization.
   Upper Saddle River, Prentice-Hall, 1990.
   [Tanenbaum, 1992] TANENBAUM, Andrew S. Modern Operating Systems.
   Englewood Cliffs, Prentice-Hall, 1992.
   [Tanenbaum, 1995] TANENBAUM, Andrew S. Distributed Operating Systems.
   Englewood Cliffs, Prentice-Hall, 1995.
   [Thazhuthaveetil & Shah, 1991] THAZHUTHAVEETIL, M.J. ; A.V. SHAH Parallel
   Hough transform algorithm performance. Image and Vision Computing,
   volume 9 (1991), number 2, pp. 88-92, 1991.
   [Theimer & Mallot, 1994] THEIMER, W. M., MALLOT, H. A. Phase-based binocular
   vergence control and depth reconstruction using active vision. CVGIP:
   Image Understanding. 60(3):343-358. November 1994.
   [Tovee, 1996] TOVEE, M. J. An introduction to the visual system. Cambridge
   University Press, 1996.
   [Tricot, 1995] TRICOT, C. Curves and Fractal Dimensions. Springer-Verlag, Paris,
   1995.
   [Tsai, 1987] TSAI, R. A versatile camera calibration technique for high accuracy 3D
   machine vision metrology using off-the-shelf TV and lenses. IEEE Journal
   of Robotics and Automation, 3(4):323-344, August 1987
   [Unger, 1958] UNGER, S. H. A computer oriented towards spatial problems.
   Proceedings Inst. Radio Engineering, USA, 1958.
   [Voorhees & Poggio, 1988] VOORHESS, H. ; POGGIO, T. Computing texture
   boundaries from images. Nature, v.333 p364-367, 1988.
   [Wilder, 1993] WILDER, F. A guide to the TCP/IP protocol suite. Artech House,
   390
   BIBLIOGRAFIA
   1993.
   [Wil iams, 1994] WILLIAMS, A. OLE 2.0 and DDE distil ed: A programmer's crash
   course. Addison-Wesley, 1994.
PA [Zeki & Shipp, 1988] ZEKI, S. ; SHIPP, S. The functional logic of cortical
   connections, Nature, v.355, p311-317, September 1988.
   [Zeki, 1993] ZEKI, S. A vision of the brain. Blackwel Science, 1993.
   [Zuffo, 1978] ZUFFO, J. A. Fundamentos da arquitetura e organizacao dos
   microprocessadores. Sao Paulo, Edit. Edgard Blucher, 1978.
   391
   290 14457
